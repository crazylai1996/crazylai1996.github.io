<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>分布式事务 -两阶段提交及Atomikos在Spring Boot的使用</title>
    <url>/2022/05/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8F%8AAtomikos%E5%9C%A8Spring%20Boot%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="基于XA规范的两阶段提交方式"><a href="#基于XA规范的两阶段提交方式" class="headerlink" title="基于XA规范的两阶段提交方式"></a>基于XA规范的两阶段提交方式</h2><p>事务在业务的开发中有着至关重要的作用，事务具有的ACID的特性能保证业务处理前后数据的一致性：<br><strong>原子性（Atomicity）：</strong> 事务执行的所有操作，要么全部执行，要么全部不执行；<br><strong>一致性（Consistency）：</strong> 事务的执行前后，数据的完整性保持一致；<br><strong>隔离性（Isolation）：</strong> 两个或多个事务并行执行时是互不干扰的；<br><strong>持久性（Durability）：</strong> 事务执行完成后，其对数据库数据的更改会被永久保存下来；<br>在单机环境下，数据库系统对事务的支持是比较完善的；但当对数据进行水平或垂直拆分，一个数据库节点变为多个数据库节点时，分布式事务就出现了。</p>
<h3 id="XA规范"><a href="#XA规范" class="headerlink" title="XA规范"></a>XA规范</h3><p>XA是X/Open组织提出的一个分布式事务的规范，其定义了一个分布式事务的处理模型——DTP。在DTP中定义了三个组件：<br>Application Program（AP）：应用程序，即业务层，它定义了事务的边界，以及构成该事务的特定操作；<br>Resource Manager（RM）：资源管理器，可以理解为一个DBMS系统，或者消息服务器管理系统；<br>Transaction Manager（TM）：事务管理器，也称为协调者，负责协调和管理事务；</p>
<p>AP与RM之间，AP通过RM提供的API进行交互，当需要进行分布式事务时，则向TM发起一个全局事务，TM与RM之间则通过XA接口进行交互，TM管理了到RM的链接，并实现了两阶段提交。</p>
<h3 id="两阶段提交流程（2PC）"><a href="#两阶段提交流程（2PC）" class="headerlink" title="两阶段提交流程（2PC）"></a>两阶段提交流程（2PC）</h3><p>XA规范中，多个RM状态之间的协调通过TM进行，而这个资源协调的过程采用了两阶段提交协议（2PC），2PC实际上是一种在多节点之间实现事务原子提交的算法，它用来确保所有节点要么全部提交，要么全部中止。</p>
<p>在2PC中，分为准备阶段和提交阶段：<br>第一阶段：发送一个准备请求到所有参与者节点，询问他们是否可以提交；</p>
<p>第二阶段：如果所有参与者节点回答“是”，则表示他们已准备好提交，那么协调者将在阶段2发出提交请求；</p>
<p><img src="http://storage.laixiaoming.space/blog/1p.jpg" alt="1p"></p>
<p><img src="http://storage.laixiaoming.space/blog/2p.jpg" alt="2p"></p>
<p>如果在准备阶段，有一个RM返回失败时，则在第二个阶段将回滚所有资源</p>
<p><img src="http://storage.laixiaoming.space/blog/1pc-error.jpg" alt="1pc-error"></p>
<p><img src="http://storage.laixiaoming.space/blog/2pc-error.jpg" alt="2pc-error"></p>
<h3 id="2PC的局限性"><a href="#2PC的局限性" class="headerlink" title="2PC的局限性"></a>2PC的局限性</h3><p>2PC能基本满足了事务的 ACID 特性，但也存在着明显的缺点：</p>
<ul>
<li>在事务的执行过程中，所有的参与节点都是阻塞型的，在并发量高的系统中，性能受限严重；</li>
<li>如果TM在commit前发生故障，那么所有参与节点会因为无法提交事务而处于长时间锁定资源的状态；</li>
<li>在实际情况中，由于分布式环境下的复杂性，TM在发送commit请求后，可能因为局部网络原因，导致只有部分参与者收到commit请求时，系统便出现了数据不一致的现象；</li>
<li>XA协议要求所有参与者需要与TM进行直接交互，但在微服务架构下，一个服务与多个RM直接关联常常是被不允许的；</li>
</ul>
<h2 id="Atomikos在Spring-Boot的使用"><a href="#Atomikos在Spring-Boot的使用" class="headerlink" title="Atomikos在Spring Boot的使用"></a>Atomikos在Spring Boot的使用</h2><p>Atomikos在XA中作为一个事务管理器（TM）存在。在Spring Boot应用中，可以通过Atomikos在应用中方便的引入分布式事务。<br>下面以一个简单的订单创建流程的为例：</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jta-atomikos&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.11&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.22&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><p>application.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">      order-db:</span><br><span class="line">        name: order-db</span><br><span class="line">        url: jdbc:mysql:&#x2F;&#x2F;localhost:3307&#x2F;order?useSSL&#x3D;false&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: mysql</span><br><span class="line">      product-db:</span><br><span class="line">        name: order-db</span><br><span class="line">        url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;product?useSSL&#x3D;false&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: mysql</span><br><span class="line">  jta:</span><br><span class="line">    transaction-manager-id: order-product-tx-manager</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; &quot;gdou.laixiaoming.atomikos.demo.mapper.order&quot;, sqlSessionFactoryRef &#x3D; &quot;orderSqlSessionFactory&quot;)</span><br><span class="line">public class OrderDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;druidOrderDataSource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.druid.order-db&quot;)</span><br><span class="line">    public DruidXADataSource druidOrderDataSource()&#123;</span><br><span class="line">        DruidXADataSource xaDataSource &#x3D; new DruidXADataSource();</span><br><span class="line">        return xaDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;orderDataSource&quot;)</span><br><span class="line">    public DataSource orderDataSource(</span><br><span class="line">            @Qualifier(&quot;druidOrderDataSource&quot;) DruidXADataSource druidOrderDataSource) &#123;</span><br><span class="line">        AtomikosDataSourceBean ds &#x3D; new AtomikosDataSourceBean();</span><br><span class="line">        ds.setXaDataSource(druidOrderDataSource);</span><br><span class="line">        ds.setXaDataSourceClassName(&quot;com.alibaba.druid.pool.xa.DruidXADataSource&quot;);</span><br><span class="line">        ds.setUniqueResourceName(&quot;orderDataSource&quot;);</span><br><span class="line">        return ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactory orderSqlSessionFactory(</span><br><span class="line">            @Qualifier(&quot;orderDataSource&quot;) DataSource orderDataSource) throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(orderDataSource);</span><br><span class="line">        return sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; &quot;gdou.laixiaoming.atomikos.demo.mapper.product&quot;, sqlSessionFactoryRef &#x3D; &quot;productSqlSessionFactory&quot;)</span><br><span class="line">public class ProductDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;druidProductDataSource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.druid.product-db&quot;)</span><br><span class="line">    public DruidXADataSource druidProductDataSource()&#123;</span><br><span class="line">        DruidXADataSource xaDataSource &#x3D; new DruidXADataSource();</span><br><span class="line">        return xaDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;productDataSource&quot;)</span><br><span class="line">    public DataSource productDataSource(</span><br><span class="line">            @Qualifier(&quot;druidProductDataSource&quot;) DruidXADataSource druidProductDataSource) &#123;</span><br><span class="line">        AtomikosDataSourceBean ds &#x3D; new AtomikosDataSourceBean();</span><br><span class="line">        ds.setXaDataSource(druidProductDataSource);</span><br><span class="line">        ds.setXaDataSourceClassName(&quot;com.alibaba.druid.pool.xa.DruidXADataSource&quot;);</span><br><span class="line">        ds.setUniqueResourceName(&quot;productDataSource&quot;);</span><br><span class="line">        return ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactory productSqlSessionFactory(</span><br><span class="line">            @Qualifier(&quot;productDataSource&quot;) DataSource productDataSource) throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(productDataSource);</span><br><span class="line">        return sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="构建商品服务"><a href="#构建商品服务" class="headerlink" title="构建商品服务"></a>构建商品服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ProductServiceImpl implements ProductService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductMapper productMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void updateInventory(Long productId) &#123;</span><br><span class="line">    	&#x2F;&#x2F;模拟异常流程</span><br><span class="line">        if(productId &#x3D;&#x3D; 2)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;更新库存失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        productMapper.updateInventory(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建订单服务"><a href="#构建订单服务" class="headerlink" title="构建订单服务"></a>构建订单服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderMapper orderMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor &#x3D; RuntimeException.class)</span><br><span class="line">    @Override</span><br><span class="line">    public void order(Long productId) &#123;</span><br><span class="line">        orderMapper.addOrder(productId);</span><br><span class="line">        productService.updateInventory(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class ServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testCommit() &#123;</span><br><span class="line">        orderService.order(1L);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testRollback() &#123;</span><br><span class="line">        orderService.order(2L);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过运行测试用例，我们可以发现testCommit()方法在订单库以及商品库的成功完成的修改；而testRollback()方法则因为商品服务异常进行了回滚，回滚后的订单库和商品库数据都恢复到了事务开启前的状态。</p>
<p>参考：<br>《大型网站系统与Java中间件实践》<br><a href="https://www.jianshu.com/p/f9bac5822d30">SpringBoot Atomikos 多数据源分布式事务</a></p>
]]></content>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
</search>
