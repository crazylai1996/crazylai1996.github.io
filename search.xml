<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>认识高性能队列——Disruptor</title>
    <url>/2023/05/01/%E8%AE%A4%E8%AF%86%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Disruptor/</url>
    <content><![CDATA[<h2 id="Disruptor是什么"><a href="#Disruptor是什么" class="headerlink" title="Disruptor是什么"></a>Disruptor是什么</h2><p>Disruptor是一个由英国外汇交易公司LMAX研发并开源的高性能的有界内存队列，其主要用于在线程之间完成数据的传递。<a href="https://github.com/LMAX-Exchange/disruptor">github地址</a><br>那么，以高性能著称的Disruptor到底有多快呢？</p>
<span id="more"></span>

<p>我将常用的2种线程安全队列（ArrayBlockingQueue和LinkedBlockingQueue）与Disruptor作了个简单对比，场景是启动两个线程，一个线程往队列填充自增数字，另一个线程取数字进行累加，其对比结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000w</span><br><span class="line">ArrayBlockingQueue耗时：927ms</span><br><span class="line">LinkedBlockingQueue耗时：1495ms</span><br><span class="line">Disruptor耗时：598ms</span><br><span class="line">5000w</span><br><span class="line">ArrayBlockingQueue耗时：4044ms</span><br><span class="line">LinkedBlockingQueue耗时：11145ms</span><br><span class="line">Disruptor耗时：2824ms</span><br><span class="line">1e</span><br><span class="line">ArrayBlockingQueue耗时：7514ms</span><br><span class="line">LinkedBlockingQueue耗时：23144ms</span><br><span class="line">Disruptor耗时：4668ms</span><br></pre></td></tr></table></figure>
<p>可以看到，Disruptor在速度上较其他两个队列有着明显的优势。</p>
<h2 id="为什么可以这么快"><a href="#为什么可以这么快" class="headerlink" title="为什么可以这么快"></a>为什么可以这么快</h2><h3 id="内存预分配"><a href="#内存预分配" class="headerlink" title="内存预分配"></a>内存预分配</h3><p>在Disruptor里，底层存储为数组结构，而事件（Event）作为真实数据的一个载体，在初始化时会调用预设的EventFactory创建对应数量的Event填充数组，加上其环形数组的设计，数组中的Event对象可以很方便地实现复用，这在一定程度可以减少GC的次数，提升了性能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void fill(EventFactory&lt;E&gt; eventFactory)&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; bufferSize; i++)&#123;</span><br><span class="line">        entries[BUFFER_PAD + i] &#x3D; eventFactory.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消除“伪共享”，充分利用硬件缓存"><a href="#消除“伪共享”，充分利用硬件缓存" class="headerlink" title="消除“伪共享”，充分利用硬件缓存"></a>消除“伪共享”，充分利用硬件缓存</h3><h4 id="什么是“伪共享”"><a href="#什么是“伪共享”" class="headerlink" title="什么是“伪共享”"></a>什么是“伪共享”</h4><p>每个CPU核心都有自己独立的cache和寄存器，主存与CPU之间存在着多级cache，L3，L2，L1，而越靠近CPU核心，速度也越快，为也提高处理速度，处理器不直接与主存通信，主存的访问首先会进入cache，所有的修改默认会异步刷新到主存。同时在多核心处理器下，为了保证各个核心的缓存是一致的，会实现缓存一致性协议。<br>而伪共享指的是由于共享缓存行（通常为64个字节）导致缓存无效的场景：</p>
<p><img src="http://storage.laixiaoming.space/blog/cpu_cache.jpg" alt="cpu_cache"></p>
<p>就上图场景而言，线程1和线程2运行分别运行在两个核心上，线程1对putIndex读写，线程2对takeIndex读写，由于putIndex与takeIndex内存的相邻性，在加载到缓存时将被读到同一个缓存行中，而由于对其中一个变量的写操作会使缓存回写到主存，造成整个缓存行的失效，这也导致了同处于同一个缓存行的其他变量的缓存失效。</p>
<h4 id="它是如何被消除的"><a href="#它是如何被消除的" class="headerlink" title="它是如何被消除的"></a>它是如何被消除的</h4><p>一方面，底层采用数组结构，CPU在加载数据时，会根据空间局部性原理，把相邻的数据一起加载进来，由于由于数组上结构的内存分配是连续的，也就能更好地利用CPU的缓存；<br>另一方面，通过增加无意义变量，增大变量间的间隔，使得一个变量可以独占一个缓存行，以空间换取时间（注： Java 8 可以使用@Contended注解，配合JVM参数-XX:-RestrictContended，来消除“伪共享”）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LhsPadding</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;7*8个字节</span><br><span class="line">    protected long p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Value extends LhsPadding</span><br><span class="line">&#123;</span><br><span class="line">    protected volatile long value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RhsPadding extends Value</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;7*8个字节</span><br><span class="line">    protected long p9, p10, p11, p12, p13, p14, p15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无锁数据结构RingBuffer"><a href="#无锁数据结构RingBuffer" class="headerlink" title="无锁数据结构RingBuffer"></a>无锁数据结构RingBuffer</h3><p><img src="http://storage.laixiaoming.space/blog/ringbuffer.jpg" alt="ringbuffer"></p>
<p>RingBuffer作为Disruptor的底层数据结构，其内部有一个cursor变量，表示当前可读的最大下标，cursor是Sequence类的一个对象，其内部维护了一个long类型的value成员，value使用了volatile修饰，在不使用锁的前提下保证了线程之间的可见性，并通过Unsafe工具封装了对value变量的CAS系列操作。<br>关于volatile变量，有以下两个特性：<br>可见性：对一个volatile变量读，总能看到（任意线程）对这个变量的最后写入；<br>原子性：对任意单个volatile变量的读/写具有原子性；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Sequence extends RhsPadding</span><br><span class="line">&#123;</span><br><span class="line">	static final long INITIAL_VALUE &#x3D; -1L;</span><br><span class="line">    private static final Unsafe UNSAFE;</span><br><span class="line">    private static final long VALUE_OFFSET;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h4><p>RingBuffer数据的写入分为两个阶段，在第一阶段会先申请下一个可写入节点（cursor+1），多写入者模式下通过CAS操作移动cursor，来保存线程安全性；第二阶段，数据提交，提交时为保证顺序写，需要保证cursor追上当前提交的写入位置。<br>写入成功后，再调用具体的WaitStrategy实现通知其他消费线程</p>
<p><img src="http://storage.laixiaoming.space/blog/ringbuffer_write.jpg" alt="ringbuffer_write"></p>
<h4 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h4><p>在读取数据的时候，多个消费者可以同时消费，每个消费者都会维护有一个读取位置，在没有可读数据时，通过具体的WaitStrategy进行等待（阻塞等待或自旋等）。</p>
<p><img src="http://storage.laixiaoming.space/blog/ringbuffer_read.jpg" alt="ringbuffer_read"></p>
<h2 id="简单上手-生产者-消费者模型"><a href="#简单上手-生产者-消费者模型" class="headerlink" title="简单上手(生产者-消费者模型)"></a>简单上手(生产者-消费者模型)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DisruptorStart &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; RingBuffer大小，2的幂次</span><br><span class="line">        int bufferSize &#x3D; 1024;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建Disruptor</span><br><span class="line">        Disruptor&lt;LongEvent&gt; disruptor &#x3D; new Disruptor&lt;&gt;(</span><br><span class="line">                LongEvent::new,</span><br><span class="line">                bufferSize,</span><br><span class="line">                DaemonThreadFactory.INSTANCE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 事件消费</span><br><span class="line">        disruptor.handleEventsWith((event, sequence, endOfBatch) -&gt; System.out.println(&quot;Event: &quot; + event));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 启动</span><br><span class="line">        disruptor.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 拿到RingBuffer，用于向队列传输数据</span><br><span class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer &#x3D; disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">        ByteBuffer bb &#x3D; ByteBuffer.allocate(8);</span><br><span class="line">        for (long l &#x3D; 0; true; l++) &#123;</span><br><span class="line">            bb.putLong(0, l);</span><br><span class="line">            &#x2F;&#x2F;往队列填充数据</span><br><span class="line">            ringBuffer.publishEvent((event, sequence, buffer) -&gt; event.set(buffer.getLong(0)), bb);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考：<br><a href="https://ifeve.com/disruptor">并发框架Disruptor译文</a><br><a href="https://tech.meituan.com/2016/11/18/disruptor.html">高性能队列——Disruptor</a><br><a href="https://blog.csdn.net/twypx/article/details/80398886">Disruptor系列3：Disruptor样例实战</a></p>
]]></content>
      <tags>
        <tag>内存队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：自动配置原理</title>
    <url>/2023/05/02/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“约定优于配置”是Spring Boot倡导的一个思想，而其自动配置的特性则恰好体现了这一思想。而有了自动配置，不仅简化了Maven的依赖配置，更重要的是摆脱了以往使用Spring框架开发时，所必须编写的一堆繁琐的xml配置文件。</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<h2 id="从-SpringBootApplication注解说起"><a href="#从-SpringBootApplication注解说起" class="headerlink" title="从@SpringBootApplication注解说起"></a>从@SpringBootApplication注解说起</h2><p>我们都知道，一个Spring Boot主启动类上必须标注@SpringBootApplication注解，点开这个注解我们可以看到这是一个组合注解，其中关键的注解有@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan这3个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点开@SpringBootConfiguration，可以看到它被@Configuration标注，这表明了我们的启动类同时也是一个配置类，这一点需要注意，因为Spring Boot整个启动流程可以说都是围绕着我们的主启动类进行的。</p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Import注解的作用是将目标类作为Bean添加到IOC容器，通常用于将多个分散的配置类融合成一个更大的配置类。@Import支持导入<strong>普通类</strong>、<strong>配置类</strong>、<strong>ImportSelector 的实现类</strong>以及<strong>ImportBeanDefinitionRegistrar 的实现类</strong>。</p>
<h4 id="AutoConfigurationImportSelector的作用"><a href="#AutoConfigurationImportSelector的作用" class="headerlink" title="AutoConfigurationImportSelector的作用"></a>AutoConfigurationImportSelector的作用</h4><p><img src="http://storage.laixiaoming.space/blog/AutoConfigurationImportSelector.jpg" alt="AutoConfigurationImportSelector"></p>
<p>AutoConfigurationImportSelector是DeferredImportSelector的实现类，而DeferredImportSelector继承了ImportSelector，而ImportSelector#selectImports方法正是用来获取需要实际导入到IOC容器的类名数组的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,</span><br><span class="line">                                                                              annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，在selectImports方法中，获取类名数组的关键方法就在于getAutoConfigurationEntry方法</p>
<h5 id="AutoConfigurationImportSelector-getAutoConfigurationEntry"><a href="#AutoConfigurationImportSelector-getAutoConfigurationEntry" class="headerlink" title="AutoConfigurationImportSelector#getAutoConfigurationEntry"></a>AutoConfigurationImportSelector#getAutoConfigurationEntry</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">			AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//获取候选的自动配置类</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到getCandidateConfigurations方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">                                                                         getBeanClassLoader());</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面调用了SpringFactoriesLoader的loadFactoryNames方法，并传入了<strong>EnableAutoConfiguration.class</strong>这样一个参数，继续深入可以发现在里面又调用了loadSpringFactories方法：</p>
<h5 id="SpringFactoriesLoader-loadFactoryNames"><a href="#SpringFactoriesLoader-loadFactoryNames" class="headerlink" title="SpringFactoriesLoader#loadFactoryNames"></a>SpringFactoriesLoader#loadFactoryNames</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">					classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">					ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">    URL url = urls.nextElement();</span><br><span class="line">    UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">    Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">        String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">        <span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">            result.add(factoryClassName, factoryName.trim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>通过代码可以看出，loadSpringFactories方法做的事情就是：</p>
<ol>
<li>扫描所有jar包路径下<strong>META-INF/spring.factories</strong>文件；</li>
<li>以Properties的形式加载加载该文件，将将其收集到Map返回；</li>
</ol>
<p>回到loadFactoryNames方法，在前面拿到了<strong>META-INF/spring.factories</strong>的Map内容后，会取出<strong>EnableAutoConfiguration.class</strong>对应的值，随后便将其添加到容器中。</p>
<p>那么<strong>META-INF/spring.factories</strong>都有着什么内容呢</p>
<h5 id="META-INF-spring-factories文件"><a href="#META-INF-spring-factories文件" class="headerlink" title="META-INF/spring.factories文件"></a><code>META-INF/spring.factories</code>文件</h5><p>这个文件可以在<strong>spring-boot-autoconfiguration</strong>包下找到，我在其中截取了部分<strong>EnableAutoConfiguration.class</strong>内容，不难看到，这些都是我们在日常开发中常见的配置类，这其实也解释了，为什么即便我们在项目中没有显示添加任何配置，而只要我们添加了对应的starter依赖，Spring Boot便会帮助我们创建对应的Bean：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>



<h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是@Import注解，点进AutoConfigurationPackages.Registrar可以发现其手动注册了一个<strong>BasePackages.class</strong>的Bean，并把主启动类的成员设置到<strong>BasePackages</strong>对象成员里；</p>
<p>那这样做有什么用呢？其实AutoConfigurationPackages类上的注释已经告诉了我们答案，它是设计来给其他模块或组件用的，相当于提供给了其他模块或组件获取根包的一个入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class <span class="keyword">for</span> storing auto-<span class="function">configuration packages <span class="keyword">for</span> reference <span class="title">later</span> <span class="params">(e.g. by JPA entity</span></span></span><br><span class="line"><span class="function"><span class="params">scanner)</span></span></span><br></pre></td></tr></table></figure>



<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>开启组件扫描，可以指定扫描路径，在不指定的情况下，会扫描当前配置类所在包及子包的所有组件，这也解释了，为什么我们在使用Spring Boot的时候，启动类要放在最外层。</p>
<p>到这里，不知道读者是否会有疑问，启动类被@Configuration修饰，它既然也是一个配置类，那么它是什么时候被注册到IOC容器的呢？</p>
<p>通过dubug启动过程，其实不难发现是在SpringApplication#prepareContext方法进行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//获取主启动类位置</span></span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line"><span class="comment">//加载</span></span><br><span class="line">load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Spring Boot通过 AutoConfigurationImportSelector，并扫描所有jar包目录中<strong>META-INF/spring.factories</strong>配置文件，并加载<code>org.springframework.boot.autoconfigure.EnableutoConfiguration</code>配置项中对应的自动配置类，这也是自动配置生效的原理；</li>
<li>主启动类也是一个配置类，而**@ComponentScan**会默认扫描当前配置类所在包及子包的所有组件；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务 -两阶段提交及Atomikos在Spring Boot的使用</title>
    <url>/2023/05/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20-%20%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8F%8AAtomikos%E5%9C%A8Spring%20Boot%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="基于XA规范的两阶段提交方式"><a href="#基于XA规范的两阶段提交方式" class="headerlink" title="基于XA规范的两阶段提交方式"></a>基于XA规范的两阶段提交方式</h2><p>事务在业务的开发中有着至关重要的作用，事务具有的ACID的特性能保证业务处理前后数据的一致性：<br><strong>原子性（Atomicity）：</strong> 事务执行的所有操作，要么全部执行，要么全部不执行；<br><strong>一致性（Consistency）：</strong> 事务的执行前后，数据的完整性保持一致；<br><strong>隔离性（Isolation）：</strong> 两个或多个事务并行执行时是互不干扰的；<br><strong>持久性（Durability）：</strong> 事务执行完成后，其对数据库数据的更改会被永久保存下来；<br>在单机环境下，数据库系统对事务的支持是比较完善的；但当对数据进行水平或垂直拆分，一个数据库节点变为多个数据库节点时，分布式事务就出现了。</p>
<span id="more"></span>

<h3 id="XA规范"><a href="#XA规范" class="headerlink" title="XA规范"></a>XA规范</h3><p>XA是X/Open组织提出的一个分布式事务的规范，其定义了一个分布式事务的处理模型——DTP。在DTP中定义了三个组件：<br>Application Program（AP）：应用程序，即业务层，它定义了事务的边界，以及构成该事务的特定操作；<br>Resource Manager（RM）：资源管理器，可以理解为一个DBMS系统，或者消息服务器管理系统；<br>Transaction Manager（TM）：事务管理器，也称为协调者，负责协调和管理事务；</p>
<p>AP与RM之间，AP通过RM提供的API进行交互，当需要进行分布式事务时，则向TM发起一个全局事务，TM与RM之间则通过XA接口进行交互，TM管理了到RM的链接，并实现了两阶段提交。</p>
<h3 id="两阶段提交流程（2PC）"><a href="#两阶段提交流程（2PC）" class="headerlink" title="两阶段提交流程（2PC）"></a>两阶段提交流程（2PC）</h3><p>XA规范中，多个RM状态之间的协调通过TM进行，而这个资源协调的过程采用了两阶段提交协议（2PC），2PC实际上是一种在多节点之间实现事务原子提交的算法，它用来确保所有节点要么全部提交，要么全部中止。</p>
<p>在2PC中，分为准备阶段和提交阶段：<br>第一阶段：发送一个准备请求到所有参与者节点，询问他们是否可以提交；</p>
<p>第二阶段：如果所有参与者节点回答“是”，则表示他们已准备好提交，那么协调者将在阶段2发出提交请求；</p>
<p><img src="http://storage.laixiaoming.space/blog/1p.jpg" alt="1p"></p>
<p><img src="http://storage.laixiaoming.space/blog/2p.jpg" alt="2p"></p>
<p>如果在准备阶段，有一个RM返回失败时，则在第二个阶段将回滚所有资源</p>
<p><img src="http://storage.laixiaoming.space/blog/1pc-error.jpg" alt="1pc-error"></p>
<p><img src="http://storage.laixiaoming.space/blog/2pc-error.jpg" alt="2pc-error"></p>
<h3 id="2PC的局限性"><a href="#2PC的局限性" class="headerlink" title="2PC的局限性"></a>2PC的局限性</h3><p>2PC能基本满足了事务的 ACID 特性，但也存在着明显的缺点：</p>
<ul>
<li>在事务的执行过程中，所有的参与节点都是阻塞型的，在并发量高的系统中，性能受限严重；</li>
<li>如果TM在commit前发生故障，那么所有参与节点会因为无法提交事务而处于长时间锁定资源的状态；</li>
<li>在实际情况中，由于分布式环境下的复杂性，TM在发送commit请求后，可能因为局部网络原因，导致只有部分参与者收到commit请求时，系统便出现了数据不一致的现象；</li>
<li>XA协议要求所有参与者需要与TM进行直接交互，但在微服务架构下，一个服务与多个RM直接关联常常是被不允许的；</li>
</ul>
<h2 id="Atomikos在Spring-Boot的使用"><a href="#Atomikos在Spring-Boot的使用" class="headerlink" title="Atomikos在Spring Boot的使用"></a>Atomikos在Spring Boot的使用</h2><p>Atomikos在XA中作为一个事务管理器（TM）存在。在Spring Boot应用中，可以通过Atomikos在应用中方便的引入分布式事务。<br>下面以一个简单的订单创建流程的为例：</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jta-atomikos&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.11&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.22&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><p>application.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">      order-db:</span><br><span class="line">        name: order-db</span><br><span class="line">        url: jdbc:mysql:&#x2F;&#x2F;localhost:3307&#x2F;order?useSSL&#x3D;false&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: mysql</span><br><span class="line">      product-db:</span><br><span class="line">        name: order-db</span><br><span class="line">        url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;product?useSSL&#x3D;false&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: mysql</span><br><span class="line">  jta:</span><br><span class="line">    transaction-manager-id: order-product-tx-manager</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; &quot;gdou.laixiaoming.atomikos.demo.mapper.order&quot;, sqlSessionFactoryRef &#x3D; &quot;orderSqlSessionFactory&quot;)</span><br><span class="line">public class OrderDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;druidOrderDataSource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.druid.order-db&quot;)</span><br><span class="line">    public DruidXADataSource druidOrderDataSource()&#123;</span><br><span class="line">        DruidXADataSource xaDataSource &#x3D; new DruidXADataSource();</span><br><span class="line">        return xaDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;orderDataSource&quot;)</span><br><span class="line">    public DataSource orderDataSource(</span><br><span class="line">            @Qualifier(&quot;druidOrderDataSource&quot;) DruidXADataSource druidOrderDataSource) &#123;</span><br><span class="line">        AtomikosDataSourceBean ds &#x3D; new AtomikosDataSourceBean();</span><br><span class="line">        ds.setXaDataSource(druidOrderDataSource);</span><br><span class="line">        ds.setXaDataSourceClassName(&quot;com.alibaba.druid.pool.xa.DruidXADataSource&quot;);</span><br><span class="line">        ds.setUniqueResourceName(&quot;orderDataSource&quot;);</span><br><span class="line">        return ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactory orderSqlSessionFactory(</span><br><span class="line">            @Qualifier(&quot;orderDataSource&quot;) DataSource orderDataSource) throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(orderDataSource);</span><br><span class="line">        return sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; &quot;gdou.laixiaoming.atomikos.demo.mapper.product&quot;, sqlSessionFactoryRef &#x3D; &quot;productSqlSessionFactory&quot;)</span><br><span class="line">public class ProductDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;druidProductDataSource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.druid.product-db&quot;)</span><br><span class="line">    public DruidXADataSource druidProductDataSource()&#123;</span><br><span class="line">        DruidXADataSource xaDataSource &#x3D; new DruidXADataSource();</span><br><span class="line">        return xaDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;productDataSource&quot;)</span><br><span class="line">    public DataSource productDataSource(</span><br><span class="line">            @Qualifier(&quot;druidProductDataSource&quot;) DruidXADataSource druidProductDataSource) &#123;</span><br><span class="line">        AtomikosDataSourceBean ds &#x3D; new AtomikosDataSourceBean();</span><br><span class="line">        ds.setXaDataSource(druidProductDataSource);</span><br><span class="line">        ds.setXaDataSourceClassName(&quot;com.alibaba.druid.pool.xa.DruidXADataSource&quot;);</span><br><span class="line">        ds.setUniqueResourceName(&quot;productDataSource&quot;);</span><br><span class="line">        return ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactory productSqlSessionFactory(</span><br><span class="line">            @Qualifier(&quot;productDataSource&quot;) DataSource productDataSource) throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(productDataSource);</span><br><span class="line">        return sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="构建商品服务"><a href="#构建商品服务" class="headerlink" title="构建商品服务"></a>构建商品服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ProductServiceImpl implements ProductService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductMapper productMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void updateInventory(Long productId) &#123;</span><br><span class="line">    	&#x2F;&#x2F;模拟异常流程</span><br><span class="line">        if(productId &#x3D;&#x3D; 2)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;更新库存失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        productMapper.updateInventory(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建订单服务"><a href="#构建订单服务" class="headerlink" title="构建订单服务"></a>构建订单服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderMapper orderMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor &#x3D; RuntimeException.class)</span><br><span class="line">    @Override</span><br><span class="line">    public void order(Long productId) &#123;</span><br><span class="line">        orderMapper.addOrder(productId);</span><br><span class="line">        productService.updateInventory(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class ServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testCommit() &#123;</span><br><span class="line">        orderService.order(1L);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testRollback() &#123;</span><br><span class="line">        orderService.order(2L);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过运行测试用例，我们可以发现testCommit()方法在订单库以及商品库的成功完成的修改；而testRollback()方法则因为商品服务异常进行了回滚，回滚后的订单库和商品库数据都恢复到了事务开启前的状态。</p>
<p>参考：<br>《大型网站系统与Java中间件实践》<br><a href="https://www.jianshu.com/p/f9bac5822d30">SpringBoot Atomikos 多数据源分布式事务</a></p>
]]></content>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务-基于可靠消息的最终一致性实现</title>
    <url>/2023/05/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20-%20%E5%9F%BA%E4%BA%8E%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="CAP与BASE"><a href="#CAP与BASE" class="headerlink" title="CAP与BASE"></a>CAP与BASE</h2><p>我们都知道，传统数据库事务具有ACID的特性，但在分布式环境下，追求强一致性在大多数情况下无法满足高性能需求。<br>分布式系统的CAP理论告诉我们，一致性、可用性、分区容忍性无法同时满足，最多只能满足其他两项。CAP理论描述如下：</p>
<ul>
<li>一致性（Consistency）：所有节点在同一时间读到同样的数据；</li>
<li>可用性（Availability）：无论是成功还是失败，每个请求都能收到一个反馈。可用性强调的是服务可用，不保证数据的正确性；</li>
<li>分区容忍性（Partition-Tolerance）：即使系统中有部分问题或者有消息的丢失，但系统仍然能够继续运行。分区容忍性强调的是集群对分区故障的容错能力；</li>
</ul>
<span id="more"></span>

<p>对于分布式系统而言，分区故障无法避免，因而分区容忍性在一个分布式系统中是必须要考虑的，这也意味着，设计一个分布式系统，我们只能在CAP中的C、A中作出选择，而BASE就是在C和A的选择中作出的一种权衡。<br>BASE可以说是AP系统的一种延伸，其描述如下：</p>
<ul>
<li>基本可用（Basically Available）：基本可用，允许分区失败；</li>
<li>软状态（Soft state）：软状态，一种中间状态，接受一段时间的状态不同步；</li>
<li>最终一致（Eventually consistent）：最终一致，系统在短暂时间内可能是不一致的，但能够保证最终的数据是一致的；<br>BASE通过牺牲了强一致性来获取高可用性，允许数据存在短暂的不一致，到这里其实我们可以发现，ACID强调的是数据一致性，而BASE强调的则是服务可用；</li>
</ul>
<h2 id="基于可靠消息的最终一致性"><a href="#基于可靠消息的最终一致性" class="headerlink" title="基于可靠消息的最终一致性"></a>基于可靠消息的最终一致性</h2><p>基于可靠消息实现的分布式事务遵循了BASE理论，它通过引入消息中间件，在基于可靠消息的前提下，协商多个节点异步完成整个分布式事务，如果某一步骤出现失败时，则进行一定次数的重试，必要情况下需要人工介入处理。<br>以下单为例，用户下单后，会给用户增加一定的积分，在这个流程中涉及了订单服务以及积分服务，如下图所示：</p>
<p><img src="http://storage.laixiaoming.space/blog/add-order.jpg" alt="add-order"></p>
<p>但这个流程其实存在3个问题：</p>
<ol>
<li>如果在订单服务的订单创建事务（1.2）执行成功了，在发送订单创建消息（1.3）后，由于网络不可达等因素，订单服务无法收到来自消息中间件的响应时，订单服务的本地事务是应该继续提交还是回滚呢；</li>
<li>如果订单创建消息发送成功，得到了消息中间件的正确响应，但订单服务的本地事务却提交失败了，但消息却已经投递出去了，这种情况又应该怎么处理呢；</li>
<li>订单创建消息已经成功投递到下游应用（积分服务），但积分服务的本地事务却执行失败了，又应该怎么处理呢<br>以上第1和第2个问题，其实可以归结于同一个问题，即如何保证消息发送的一致性，而第3个问题，即是如何确保消息一定能够消息成功；</li>
</ol>
<h3 id="如何保证消息发送的一致性"><a href="#如何保证消息发送的一致性" class="headerlink" title="如何保证消息发送的一致性"></a>如何保证消息发送的一致性</h3><p>我们可以采用两阶段提交的方式，但并不是所有的消息中间件都支持XA，况且，出现问题的概率不大，为此引入了两阶段提交，性能方面就需要有所妥协，这样的方案实现是否有点得不偿失？<br>这个问题其实RocketMQ有了实现方案，RocketMQ支持事务消息，其通过引入了“半消息”的概念（半消息对下游系统不可见），保证了本地事务执行与消息发送的一致性。其发送的正向流程如下：</p>
<ol>
<li>业务系统发送“半消息”；</li>
<li>消息中间件将“半消息”进行持久化；</li>
<li>业务系统得到消息发送结果，成功的话则执行本地事务，失败则结束流程；</li>
<li>本地事务执行，并将业务操作结果发送给消息中间件；</li>
<li>消息中间件根据业务系统的事务执行结果，选择将消息投放或者删除；</li>
</ol>
<p>但实际上仅凭以上这个流程其实还是没有办法保证消息发送的一致性的，比如<br>(1) 在业务系统接收消息中间件对“半消息”的处理结果时，由于网络、或者业务系统和消息中间件自身故障时，业务系统无法得知消息中间件的处理结果时，就会按照消息发送失败来处理，这个时候，就有可能存在，’本地事务未执行，但“半消息”却发送成功的不一致情况’；<br>(2) 本地事务执行后，将业务操作结果返回到消息中间件时，如果出现问题，那么消息中间件将不知道如何处理已经存在的“半消息”；<br>为应对以上两种不一致情况，RocketMQ在消息中间件一方引入了“事务回查”的反向流程，其执行流程如下：</p>
<ol>
<li>对于超过一定时长未处理的“半消息”，消息中间件将会回调业务系统询问本地事务的处理结果；</li>
<li>业务系统在检查事务操作结果，将结果返回给消息中间件；</li>
<li>消息中间件根据业务系统的事务执行结果，选择将消息投放或者删除；</li>
</ol>
<p>发送消息的正向流程和反向流程结合起来，就是解决消息发送一致性的整个方案。</p>
<p>以上面的下单流程为例，在引入了RocketMQ事务消息后，基本流程可以表示为：</p>
<p><img src="http://storage.laixiaoming.space/blog/add-order-rocketmq.jpg" alt="add-order-rocketmq"></p>
<h3 id="如何保证消息一定会被消费"><a href="#如何保证消息一定会被消费" class="headerlink" title="如何保证消息一定会被消费"></a>如何保证消息一定会被消费</h3><p>确保消息一定能够被消息的流程比较简单，我们只需要保证消息的持久化，并引入消息确认机制，只有在消息被明确消费完成后，将确认消息返回到消息中间时，消息才能够被丢弃，否则则进行一定次数的重试，需要注意的是，引入重试操作后，消费方的操作需要保证幂等性。</p>
<h2 id="RocketMQ整合实例"><a href="#RocketMQ整合实例" class="headerlink" title="RocketMQ整合实例"></a>RocketMQ整合实例</h2><p>该例子基于Spring Boot构建：</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.rocketmq&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.1.0&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="applition-yml配置"><a href="#applition-yml配置" class="headerlink" title="applition.yml配置"></a>applition.yml配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rocketmq:</span><br><span class="line">  name-server: localhost:9876</span><br><span class="line">  producer:</span><br><span class="line">    group: default-group</span><br><span class="line">    sendMessageTimeout: 5000</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  rocketmq:</span><br><span class="line">    orderTopic: order-paid-topic</span><br></pre></td></tr></table></figure>

<h3 id="构建订单服务"><a href="#构建订单服务" class="headerlink" title="构建订单服务"></a>构建订单服务</h3><h4 id="发送半消息"><a href="#发送半消息" class="headerlink" title="发送半消息"></a>发送半消息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;demo.rocketmq.orderTopic&#125;&quot;)</span><br><span class="line">    private String orderTopic;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addOrder() &#123;</span><br><span class="line">        int orderId &#x3D; new Random().nextInt(3) + 1;</span><br><span class="line">        Message message &#x3D; MessageBuilder.withPayload(orderId).build();</span><br><span class="line">        log.info(&quot;发送半消息, orderId &#x3D; &#123;&#125;&quot;, orderId);</span><br><span class="line">        rocketMQTemplate.sendMessageInTransaction(orderTopic, message, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="本地事务执行回调与事务状态回查"><a href="#本地事务执行回调与事务状态回查" class="headerlink" title="本地事务执行回调与事务状态回查"></a>本地事务执行回调与事务状态回查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RocketMQTransactionListener</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderTransactionListener implements RocketMQLocalTransactionListener &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;</span><br><span class="line">        &#x2F;&#x2F;执行本地事务</span><br><span class="line">        Integer orderId &#x3D; Integer.valueOf(new String((byte[])msg.getPayload()));</span><br><span class="line">        int status &#x3D; new Random().nextInt(3);</span><br><span class="line">        if (status &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            log.info(&quot;提交事务消息, orderId &#x3D; &#123;&#125;&quot;, orderId);</span><br><span class="line">            return RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (status &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            log.info(&quot;回滚事务消息, orderId &#x3D; &#123;&#125;&quot;, orderId);</span><br><span class="line">            return RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(&quot;事务消息中间状态, MQ需要回查事务状态&quot;);</span><br><span class="line">        return RocketMQLocalTransactionState.UNKNOWN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RocketMQLocalTransactionState checkLocalTransaction(Message msg) &#123;</span><br><span class="line">        Integer orderId &#x3D; Integer.valueOf(new String((byte[])msg.getPayload()));</span><br><span class="line">        RocketMQLocalTransactionState retState;</span><br><span class="line">        int status &#x3D; new Random().nextInt(3);</span><br><span class="line">        switch (status) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                retState &#x3D; RocketMQLocalTransactionState.UNKNOWN;</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                retState &#x3D; RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">            default:</span><br><span class="line">                retState &#x3D; RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;回查事务状态, orderId &#x3D; &#123;&#125;, status &#x3D; &#123;&#125;, retState &#x3D; &#123;&#125;&quot;,</span><br><span class="line">                orderId, status, retState);</span><br><span class="line">        return retState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建积分服务"><a href="#构建积分服务" class="headerlink" title="构建积分服务"></a>构建积分服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@RocketMQMessageListener(topic &#x3D; &quot;$&#123;demo.rocketmq.orderTopic&#125;&quot;, consumerGroup &#x3D; &quot;order_paid_consumer_default_group&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderPaidConsumer implements RocketMQListener&lt;MessageExt&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(MessageExt message) &#123;</span><br><span class="line">        Integer orderId &#x3D; Integer.valueOf(new String((byte[])message.getBody()));</span><br><span class="line">        log.info(&quot;orderId &#x3D; &#123;&#125;, 增加积分&quot;, orderId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<br>《大型网站系统与Java中间件实践》</p>
]]></content>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：@Configuration类的解析</title>
    <url>/2023/05/04/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A@Configuration%E7%B1%BB%E7%9A%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用@Configuration注解可以为一个类声明为配置类，一个配置类声明了一个或多个@Bean方法，这些方法返回值将作为bean定义注册到Spring IoC容器中，并允许在配置类中通过调用同一类中的其他@Bean方法来定义bean之间的依赖关系。</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<h2 id="Configuration类解析流程"><a href="#Configuration类解析流程" class="headerlink" title="@Configuration类解析流程"></a>@Configuration类解析流程</h2><p>Spring Boot是如何解析@Configuration配置类的呢？要弄懂这个过程，首先我们需要先了解一个BeanFactoryPostProcessor的概念。</p>
<h3 id="BeanFactoryPostProcessor是什么"><a href="#BeanFactoryPostProcessor是什么" class="headerlink" title="BeanFactoryPostProcessor是什么"></a>BeanFactoryPostProcessor是什么</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Modify the application context&#x27;s internal bean factory after its standard</span></span><br><span class="line"><span class="comment">	 * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment">	 * will have been instantiated yet. This allows for overriding or adding</span></span><br><span class="line"><span class="comment">	 * properties even to eager-initializing beans.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>BeanFactoryPostProcessor是Spring 提供的一个接口，从代码注释中我们可以了解到，我们可以利用BeanFactoryPostProcessor实现对内部bean工厂进行修改，允许我们通过它完成bean定义或者属性的修改，另外需要注意的一点是，BeanFactoryPostProcessor的执行时机是在BeanFactory标准初始化后，并且是在Bean实例化之前。</p>
<p>而@Configuration配置类的解析正是由BeanFactoryPostProcessor的实现类<strong>ConfigurationClassPostProcessor</strong>处理的：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20220511233922833.png" alt="image-20220511233922833"></p>
<p>由ConfigurationClassPostProcessor的类继承关系图，我们可以发现ConfigurationClassPostProcessor并不直接实现BeanFactoryPostProcessor接口，而是实现了BeanFactoryPostProcessor的子接口BeanDefinitionRegistryPostProcessor，那么BeanDefinitionRegistryPostProcessor是什么呢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Modify the application context&#x27;s internal bean definition registry after its</span></span><br><span class="line"><span class="comment">	 * standard initialization. All regular bean definitions will have been loaded,</span></span><br><span class="line"><span class="comment">	 * but no beans will have been instantiated yet. This allows for adding further</span></span><br><span class="line"><span class="comment">	 * bean definitions before the next post-processing phase kicks in.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry the bean definition registry used by the application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor，它额外定义了一个方法，通过这个方法参数BeanDefinitionRegistry我们可以看出，它与BeanFactoryPostProcessor的区别在于，我们可以通过这个方法新增Bean定义，另外，它的执行时机是在BeanFactoryPostProcessor之前。</p>
<p>回到ConfigurationClassPostProcessor，这个BeanDefinitionRegistryPostProcessor的实现类到底做了哪些事情呢，我们一起来看下它的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConfigurationClassPostProcessor#processConfigBeanDefinitions：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充配置类的full或lite属性</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">        BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">            configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类解析器</span></span><br><span class="line">    ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">        <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//解析配置类（处理@ComponentScan，@Import，@Bean方法等注解），但这里实际上只会把@ComponentScan注解扫描的类注册为BeanDefinition</span></span><br><span class="line">        parser.parse(candidates);</span><br><span class="line">        parser.validate();</span><br><span class="line"></span><br><span class="line">        Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">        configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">                registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">                <span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里会解析上一步parse操作中获取到的ConfigurationClass，比如由@Import生成的配置类、或标注了@Bean注解的方法等注册为BeanDefinition</span></span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">        alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">        candidates.clear();</span><br><span class="line">        <span class="comment">//判断经过loadBeanDefinitions处理后，是否有新增配置类，有则继续解析</span></span><br><span class="line">        <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">            String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">            Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">            Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">                    BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">                    <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                        !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                        candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            candidateNames = newCandidateNames;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="full和lite的区别"><a href="#full和lite的区别" class="headerlink" title="full和lite的区别"></a>full和lite的区别</h3><p>ConfigurationClassUtils#checkConfigurationClassCandidate：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkConfigurationClassCandidate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    <span class="keyword">if</span> (isFullConfigurationCandidate(metadata)) &#123;</span><br><span class="line">        beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isLiteConfigurationCandidate(metadata)) &#123;</span><br><span class="line">        beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It&#x27;s a full or lite configuration candidate... Let&#x27;s determine the order value, if any.</span></span><br><span class="line">    Integer order = getOrder(metadata);</span><br><span class="line">    <span class="keyword">if</span> (order != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanDef.setAttribute(ORDER_ATTRIBUTE, order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConfigurationClassUtils#isFullConfigurationCandidate：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFullConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> metadata.isAnnotated(Configuration.class.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConfigurationClassUtils#isLiteConfigurationCandidate：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; candidateIndicators = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    candidateIndicators.add(Component.class.getName());</span><br><span class="line">    candidateIndicators.add(ComponentScan.class.getName());</span><br><span class="line">    candidateIndicators.add(Import.class.getName());</span><br><span class="line">    candidateIndicators.add(ImportResource.class.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLiteConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do not consider an interface or an annotation...</span></span><br><span class="line">    <span class="keyword">if</span> (metadata.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Any of the typical annotations found?</span></span><br><span class="line">    <span class="keyword">for</span> (String indicator : candidateIndicators) &#123;</span><br><span class="line">        <span class="keyword">if</span> (metadata.isAnnotated(indicator)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, let&#x27;s look for @Bean methods...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> metadata.hasAnnotatedMethods(Bean.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Failed to introspect @Bean methods on class [&quot;</span> + metadata.getClassName() + <span class="string">&quot;]: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以知道：</p>
<p><strong>full：</strong>@Configuration标注的类；</p>
<p><strong>lite：</strong>@Component、@ComponentScan、@Import、@ImportResource或者存在@Bean方法的类；</p>
<p>那么问题来了，区分full和lite有什么作用呢？</p>
<p>通过查找ConfigurationClassUtils#isFullConfigurationClass的调用位置，我们可以定位到ConfigurationClassPostProcessor#enhanceConfigurationClasses：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">			BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">            <span class="comment">//判断是否full配置类</span></span><br><span class="line">			<span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;</span><br><span class="line">				<span class="comment">//省略...</span></span><br><span class="line">				configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">		ConfigurationClassEnhancer enhancer = <span class="keyword">new</span> ConfigurationClassEnhancer();</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">			AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line">			<span class="comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">			beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">				Class&lt;?&gt; configClass = beanDef.resolveBeanClass(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">				<span class="keyword">if</span> (configClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//对full配置类进行增强</span></span><br><span class="line">					Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">					<span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">						<span class="comment">//省略...</span></span><br><span class="line">						beanDef.setBeanClass(enhancedClass);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="comment">//省略...</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Boot会对full配置类进行增强，那么为什么要对其进行增加呢？想必大家都看到过以下这种用法，这实际上就是为了支持@Bean方法能够在同一配置类相互调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B(a());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="parser-pase"><a href="#parser-pase" class="headerlink" title="parser.pase()"></a>parser.pase()</h3><p>通过查看其调用链路，定位到具体处理解析代码processConfigurationClass：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">ConfigurationClassParser#parse(java.util.Set&lt;org.springframework.beans.factory.config.BeanDefinitionHolder&gt;)</span><br><span class="line">-&gt;</span><br><span class="line">ConfigurationClassParse#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String)</span><br><span class="line">-&gt;</span><br><span class="line">ConfigurationClassParser#processConfigurationClass</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//省略...</span></span><br><span class="line">		<span class="comment">//递归处理配置类及其父类</span></span><br><span class="line">		SourceClass sourceClass = asSourceClass(configClass);</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>来到doProcessConfigurationClass：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">        <span class="comment">// 处理内部类，如果内部类也是一个配置类，将会递归去解析</span></span><br><span class="line">        processMemberClasses(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理@PropertySource注解</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">        org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">            processPropertySource(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//省略...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@ComponentScan注解，扫描指定包下的所有.class，这里也是一个递归解析的过程</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">        !<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">            <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                <span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">            <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                <span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bdCand = holder.getBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@Import注解</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@ImportResource注解</span></span><br><span class="line">    AnnotationAttributes importResource =</span><br><span class="line">        AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">    <span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">        Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">            String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">            configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@Bean方法</span></span><br><span class="line">    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">        configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理接口默认方法</span></span><br><span class="line">    processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取父类并返回，用以递归解析</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">        String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">            !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">            <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="this-reader-loadBeanDefinitions"><a href="#this-reader-loadBeanDefinitions" class="headerlink" title="this.reader.loadBeanDefinitions()"></a>this.reader.loadBeanDefinitions()</h3><p>定位到具体处理逻辑，ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForConfigurationClass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">        <span class="comment">//对于被导入的类，将其注册为BeanDefinition</span></span><br><span class="line">        registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">        <span class="comment">//将@Bean方法，注册为BeanDefinition</span></span><br><span class="line">        loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@ImportResource</span></span><br><span class="line">    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">    <span class="comment">//处理@Import注解中，导入的是ImportBeanDefinitionRegistrar接口实现类，调用其registerBeanDefinitions方法</span></span><br><span class="line">    loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>我们可以通过实现BeanFactoryPostProcessor对bean进行定义或修改，而Spring Boot是也是通过其实现类ConfigurationClassPostProcessor进行配置类的解析；</li>
<li>配置类分为full和lite，区别为前者会被增强处理；</li>
<li>我们常用的@ComponentScan包扫描，@Import注解，@Bean注解方法等也都是通过ConfigurationClassPostProcessor处理的；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：@Autowired的解析</title>
    <url>/2023/05/18/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A@Autowired%E7%9A%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>@Autowired是开发中常用的注解，我们可以使用@Autowired将其标记在构造函数、成员变量、setter方法上，并由Spring自动完成依赖注入的工作。但是，这个过程是怎么完成的呢？</p>
<span id="more"></span>

<p>理解这个之前，我们需要先了解一下<strong>BeanPostProcessor</strong>概念。</p>
<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<h3 id="BeanPostProcessor是什么"><a href="#BeanPostProcessor是什么" class="headerlink" title="BeanPostProcessor是什么"></a>BeanPostProcessor是什么</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory hook that allows for custom modification of new bean instances,</span></span><br><span class="line"><span class="comment"> * e.g. checking for marker interfaces or wrapping them with proxies.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;ApplicationContexts can autodetect BeanPostProcessor beans in their</span></span><br><span class="line"><span class="comment"> * bean definitions and apply them to any beans subsequently created.</span></span><br><span class="line"><span class="comment"> * Plain bean factories allow for programmatic registration of post-processors,</span></span><br><span class="line"><span class="comment"> * applying to all beans created through this factory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Typically, post-processors that populate beans via marker interfaces</span></span><br><span class="line"><span class="comment"> * or the like will implement &#123;<span class="doctag">@link</span> #postProcessBeforeInitialization&#125;,</span></span><br><span class="line"><span class="comment"> * while post-processors that wrap beans with proxies will normally</span></span><br><span class="line"><span class="comment"> * implement &#123;<span class="doctag">@link</span> #postProcessAfterInitialization&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由注释我们可以看到，我们可以通过<strong>BeanPostProcessor</strong>修改bean的实例，例如检查bean的接口或将将bean包装为代理对象。接口中提供了两个方法，通常情况下，<strong>postProcessBeforeInitialization</strong>被用于填充bean的属性，而<strong>postProcessAfterInitialization</strong>用于返回bean的代理对象，另外需要注意的是，如果该方法返回了null，则表示后续的BeanPostProcessors不会再被调用。</p>
<p>了解<strong>BeanPostProcessor</strong>，我们不禁猜测，@Autowire注解会不会也是由<strong>BeanPostProcessor</strong>解析和注入的呢，没错，它正是由<strong>BeanPostProcessor</strong>的实现类<strong>AutowiredAnnotationBeanPostProcessor</strong>处理的。</p>
<h2 id="理解AutowiredAnnotationBeanPostProcessor"><a href="#理解AutowiredAnnotationBeanPostProcessor" class="headerlink" title="理解AutowiredAnnotationBeanPostProcessor"></a>理解AutowiredAnnotationBeanPostProcessor</h2><p><img src="http://storage.laixiaoming.space/blog/AutowiredAnnotationBeanPostProcessor.jpg" alt="AutowiredAnnotationBeanPostProcessor"></p>
<p>但查看<strong>AutowiredAnnotationBeanPostProcessor</strong>的类继承关系图我们会发现，<strong>AutowiredAnnotationBeanPostProcessor</strong></p>
<p>并不是直接实现<strong>BeanPostProcessor</strong>，而是实现自<strong>BeanPostProcessor</strong>的子接口，<strong>MergedBeanDefinitionPostProcessor</strong>和<strong>SmartInstantiationAwareBeanPostProcessor</strong>。</p>
<p>回到<strong>AutowiredAnnotationBeanPostProcessor</strong>的源码，我们看到它主要有实现了几个关键的方法：determineCandidateConstructors、postProcessMergedBeanDefinition、postProcessProperties，我们逐个看。</p>
<h3 id="determineCandidateConstructors"><a href="#determineCandidateConstructors" class="headerlink" title="determineCandidateConstructors"></a>determineCandidateConstructors</h3><p>这个方法是<strong>SmartInstantiationAwareBeanPostProcessor</strong>接口中定义的，从方法注释我们可以知道，该方法用于确定给定bean的构造函数，这里我们不展开细说。</p>
<h3 id="postProcessMergedBeanDefinition"><a href="#postProcessMergedBeanDefinition" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h3><p>这个方法是<strong>MergedBeanDefinitionPostProcessor</strong>接口中定义的，查看其实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">    InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">    metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="findAutowiringMetadata"><a href="#findAutowiringMetadata" class="headerlink" title="findAutowiringMetadata"></a>findAutowiringMetadata</h4><p>该方法作用是构建Autowired的元数据，深入发现，其核心是调用了org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    List&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Class&lt;?&gt; targetClass = clazz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;InjectionMetadata.InjectedElement&gt; currElements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="comment">//解析类所有属性字段，将其封装为AutowiredFieldElement</span></span><br><span class="line">        ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">            <span class="comment">//解析该字段上的@Autowired注解，查看该方法可以发现，该处理器不仅解析了@Autowired注解，还有@Value及@Inject注解</span></span><br><span class="line">            AnnotationAttributes ann = findAutowiredAnnotation(field);</span><br><span class="line">            <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//忽略static字段</span></span><br><span class="line">                <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;Autowired annotation is not supported on static fields: &quot;</span> + field);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析类方法，将其封装为AutowiredMethodElement</span></span><br><span class="line">        ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">            Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">            <span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//解析该方法上的@Autowire注解</span></span><br><span class="line">            AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">            <span class="keyword">if</span> (ann != <span class="keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">                <span class="comment">//忽略静态方法</span></span><br><span class="line">                <span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;Autowired annotation is not supported on static methods: &quot;</span> + method);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//忽略无参方法</span></span><br><span class="line">                <span class="keyword">if</span> (method.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;Autowired annotation should only be used on methods with parameters: &quot;</span> +</span><br><span class="line">                                    method);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">                currElements.add(<span class="keyword">new</span> AutowiredMethodElement(method, required, pd));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">        targetClass = targetClass.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环解析父类</span></span><br><span class="line">    <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjectionMetadata(clazz, elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，buildAutowiringMetadata主要是收集被@Autowired修饰的字段以及方法。</p>
<h4 id="checkConfigMembers"><a href="#checkConfigMembers" class="headerlink" title="checkConfigMembers"></a>checkConfigMembers</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkConfigMembers</span><span class="params">(RootBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    Set&lt;InjectedElement&gt; checkedElements = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.injectedElements.size());</span><br><span class="line">    <span class="keyword">for</span> (InjectedElement element : <span class="keyword">this</span>.injectedElements) &#123;</span><br><span class="line">        Member member = element.getMember();</span><br><span class="line">        <span class="keyword">if</span> (!beanDefinition.isExternallyManagedConfigMember(member)) &#123;</span><br><span class="line">            beanDefinition.registerExternallyManagedConfigMember(member);</span><br><span class="line">            checkedElements.add(element);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Registered injected element on class [&quot;</span> + <span class="keyword">this</span>.targetClass.getName() + <span class="string">&quot;]: &quot;</span> + element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.checkedElements = checkedElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会缓存已经检验过的注入点，但是这个作用是什么，查看checkConfigMembers的调用位置，发现除了被 用于<strong>AutowiredAnnotationBeanPostProcessor</strong>这个处理器外，还在<strong>CommonAnnotationBeanPostProcessor</strong>中出现，而<strong>CommonAnnotationBeanPostProcessor</strong>是用于解析@Resource注解的，不难看出，这里主要是避免重复注入的问题。</p>
<h3 id="postProcessProperties"><a href="#postProcessProperties" class="headerlink" title="postProcessProperties"></a>postProcessProperties</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line"> 	<span class="comment">//省略...</span></span><br><span class="line">    <span class="comment">//注入</span></span><br><span class="line">    metadata.inject(bean, beanName, pvs);</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Collection&lt;InjectedElement&gt; checkedElements = <span class="keyword">this</span>.checkedElements;</span><br><span class="line">    Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line">        (checkedElements != <span class="keyword">null</span> ? checkedElements : <span class="keyword">this</span>.injectedElements);</span><br><span class="line">    <span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line">            element.inject(target, beanName, pvs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到了前面解析过程得到的@Autowired元数据后，进行值的注入，我们以字段的注入为例，查看其注入流程，来到AutowiredFieldElement#inject方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object bean, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Field field = (Field) <span class="keyword">this</span>.member;</span><br><span class="line">    Object value;</span><br><span class="line">    <span class="comment">//从缓存中读取值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cached) &#123;</span><br><span class="line">        value = resolvedCachedArgument(beanName, <span class="keyword">this</span>.cachedFieldValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        DependencyDescriptor desc = <span class="keyword">new</span> DependencyDescriptor(field, <span class="keyword">this</span>.required);</span><br><span class="line">        desc.setContainingClass(bean.getClass());</span><br><span class="line">        Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        Assert.state(beanFactory != <span class="keyword">null</span>, <span class="string">&quot;No BeanFactory available&quot;</span>);</span><br><span class="line">        TypeConverter typeConverter = beanFactory.getTypeConverter();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从beanFactory中解析依赖的bean</span></span><br><span class="line">            value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(<span class="keyword">null</span>, beanName, <span class="keyword">new</span> InjectionPoint(field), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.cached) &#123;</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span> || <span class="keyword">this</span>.required) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cachedFieldValue = desc;</span><br><span class="line">                    <span class="comment">//注册依赖关系</span></span><br><span class="line">                    registerDependentBeans(beanName, autowiredBeanNames);</span><br><span class="line">                    <span class="keyword">if</span> (autowiredBeanNames.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                        String autowiredBeanName = autowiredBeanNames.iterator().next();</span><br><span class="line">                        <span class="keyword">if</span> (beanFactory.containsBean(autowiredBeanName) &amp;&amp;</span><br><span class="line">                            beanFactory.isTypeMatch(autowiredBeanName, field.getType())) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.cachedFieldValue = <span class="keyword">new</span> ShortcutDependencyDescriptor(</span><br><span class="line">                                desc, autowiredBeanName, field.getType());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cachedFieldValue = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.cached = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//通过反射设置依赖值</span></span><br><span class="line">        ReflectionUtils.makeAccessible(field);</span><br><span class="line">        field.set(bean, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中关键是使用DefaultListableBeanFactory#resolveDependency解析依赖值，查看其实现，主要逻辑在DefaultListableBeanFactory#doResolveDependency：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object shortcut = descriptor.resolveShortcut(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (shortcut != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> shortcut;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理@Value注解，并获取对应值</span></span><br><span class="line">        Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">        Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String strVal = resolveEmbeddedValue((String) value);</span><br><span class="line">                BeanDefinition bd = (beanName != <span class="keyword">null</span> &amp;&amp; containsBean(beanName) ?</span><br><span class="line">                                     getMergedBeanDefinition(beanName) : <span class="keyword">null</span>);</span><br><span class="line">                value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">            &#125;</span><br><span class="line">            TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (UnsupportedOperationException ex) &#123;</span><br><span class="line">                <span class="comment">// A custom TypeConverter which does not support TypeDescriptor resolution...</span></span><br><span class="line">                <span class="keyword">return</span> (descriptor.getField() != <span class="keyword">null</span> ?</span><br><span class="line">                        converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">                        converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理集合bean的注入</span></span><br><span class="line">        Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">        <span class="keyword">if</span> (multipleBeans != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> multipleBeans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理单个bean的注入</span></span><br><span class="line">        Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">        <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String autowiredBeanName;</span><br><span class="line">        Object instanceCandidate;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果获取到的bean有多个，将根据@Primary及@Priority确定最优的一个</span></span><br><span class="line">        <span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line">                    <span class="comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line">                    <span class="comment">// (before 4.3 in particular when we didn&#x27;t even look for collection beans).</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We have exactly one match.</span></span><br><span class="line">            Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">            autowiredBeanName = entry.getKey();</span><br><span class="line">            instanceCandidate = entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (instanceCandidate <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            <span class="comment">//根据beanName，从beanFactory获取bean实例</span></span><br><span class="line">            instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = instanceCandidate;</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ClassUtils.isAssignableValue(type, result)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解了<strong>AutowiredAnnotationBeanPostProcessor</strong>的处理流程，那该处理器是在什么时候被调用的呢？</p>
<h3 id="AutowiredAnnotationBeanPostProcessor的调用时机"><a href="#AutowiredAnnotationBeanPostProcessor的调用时机" class="headerlink" title="AutowiredAnnotationBeanPostProcessor的调用时机"></a>AutowiredAnnotationBeanPostProcessor的调用时机</h3><p>查看其方法调用位置，不难看出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory#createBean</span><br><span class="line">	-&gt;AbstractAutowireCapableBeanFactory#doCreateBean</span><br><span class="line">        -&gt;AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors</span><br><span class="line">        	-&gt;MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition</span><br><span class="line">        -&gt;AbstractAutowireCapableBeanFactory#populateBean</span><br><span class="line">            -&gt;InstantiationAwareBeanPostProcessor#postProcessProperties</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>@Autowired、@Value等是由<strong>AutowiredAnnotationBeanPostProcessor</strong>处理的；</li>
<li><strong>AutowiredAnnotationBeanPostProcessor</strong>的postProcessMergedBeanDefinition方法用于解析构建@Autowired元数据，而postProcessProperties方法则用于@Autowired解析后值的注入；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：getBean方法解析</title>
    <url>/2023/05/30/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9AgetBean%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>getBean方法是BeanFactory定义的一系列方法，用于从Spring容器中获取bean实例。</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20220531064102379.png" alt="image-20220531064102379"></p>
<p>这些方法在AbstractBeanFactory均得到了具体实现，而这几个getBean方法最终都是调用了doGetBean方法，本文一起来看下</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<h2 id="doGetBean"><a href="#doGetBean" class="headerlink" title="doGetBean"></a>doGetBean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理别名，去除FactoryBean名称前缀&#x27;&amp;&#x27;</span></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果之前已经实例化好了，直接返回</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                             <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理FactoryBean的情况</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果该bean在当前线程下处于创建中状态，则认为其产生了循环依赖并抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果该bean在当前容器中不存在，则从其父容器获取</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                    nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理@DependsOn依赖，先实例化依赖的bean</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                        <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                        <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建单例bean</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                        <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//创建原型bean</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">finally</span> &#123;</span><br><span class="line">                            afterPrototypeCreation(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                                    <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                                                    <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                                                    ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查所需类型是否与bean实际类型一致，不一致则异常</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">            <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> convertedBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">                             ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取bean的时候，会尝试先从单例缓存中获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试从一级缓存获取</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">//一级缓存获取不到，并且当bean正在创建中时，尝试从二级缓存中获取</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">//二级缓存中获取不到时，尝试从三级缓存中获取，在三级缓存中存在时，将提前暴露AOP代理对象，并将其放于二级缓存</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面涉及到了三级缓存：</p>
<p><strong>singletonObjects：</strong>用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用；</p>
<p><strong>earlySingletonObjects：</strong>二级缓存，提前暴露出的代理对象，未填充属性及初始化的单例对象；</p>
<p><strong>singletonFactories：</strong>三级缓存，存放单例对象工厂，用于提前暴露bean的代理对象；</p>
<p>如果从缓存获取不到，bean的创建会根据bean的作用域进行创建，这里以单例bean的创建为例。</p>
<h3 id="getSingleton"><a href="#getSingleton" class="headerlink" title="getSingleton"></a>getSingleton</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">//尝试从缓存中获取单例bean</span></span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">                                                          <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">                                                          <span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将当前bean标记为正在创建中</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">                <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">                singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">                        ex.addRelatedCause(suppressedException);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">//将创建好的bean放入单例缓存中</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从getSingleton方法中可以看出，它与原型bean的创建的主要区别在于，单例bean的创建多了一层缓存，用于复用已经创建好的bean，而两者最终都是调用了AbstractAutowireCapableBeanFactory#createBean进行bean的创建。</p>
<h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取bean的类型</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  lookup method和replace method的校验和准备工作</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                                               beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//提交创建代理对象并返回，不走后续创建bean的流程，深入查看可以发现，</span></span><br><span class="line">        <span class="comment">//里面会寻找InstantiationAwareBeanPostProcessor处理器，并调用postProcessBeforeInstantiation方法</span></span><br><span class="line">        <span class="comment">//查找InstantiationAwareBeanPostProcessor实现类，会发现只有AbstractAutoProxyCreator这个类中有具体实现</span></span><br><span class="line">        <span class="comment">//并且在实现中，只有存在自定义targetsource的情况下，该方法才有可能返回非空</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                                        <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里开始bean的创建</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">        <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="doCreateBean"><a href="#doCreateBean" class="headerlink" title="doCreateBean"></a>doCreateBean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化bean，将bean封装为BeanWrapper</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition处理器调用</span></span><br><span class="line">    <span class="comment">// 我们前面讲到的@Autowired正是在这里，由AutowiredAnnotationBeanPostProcessor解析的</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在允许循环依赖（单例&amp;&amp;允许循环依赖&amp;&amp;当前bean正在创建中）的前提下，</span></span><br><span class="line">    <span class="comment">//将bean工厂（用于提前暴露AOP代理对象）放于三级缓存</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                         <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getEarlyBeanReference方法里会寻找SmartInstantiationAwareBeanPostProcessor处理器，</span></span><br><span class="line">        <span class="comment">//并调用其getEarlyBeanReference方法提前返回代理对象</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bean的初始化</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//bean属性的填充，InstantiationAwareBeanPostProcessor#postProcessProperties的调用</span></span><br><span class="line">        <span class="comment">//我们前面讲到的@Autowired是在这里进行真正的注入操作</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">//初始化bean对象</span></span><br><span class="line">        <span class="comment">//Aware方法</span></span><br><span class="line">        <span class="comment">//BeanPostProcessor#postProcessBeforeInitialization</span></span><br><span class="line">        <span class="comment">//InitializingBean#afterPropertiesSet，init-method方法</span></span><br><span class="line">        <span class="comment">//BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line">        <span class="comment">//将在这里被依次调用</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//尝试从二级缓存中重新获取一遍，将提前暴露的aop代理对象（如果有的话）替换原bean实例并返回</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                                                               <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                                                               StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                                               <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，doCreateBean做的事情：</p>
<ol>
<li>createBeanInstance：bean的实例化；</li>
<li>addSingletonFactory：将bean放入三级缓存；</li>
<li>populateBean：依赖注入；</li>
<li>initializeBean：bean后置处理器的调用，bean的初始化等；</li>
</ol>
<p>这里有一个细节点，那就是三级缓存的放入是在bean的实例化之后的，而三级缓存是用于解决循环依赖的，这也是为什么当构造函数注入存在循环依赖时而无法解决的原因。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后以A实例及B实例循环场景为例，bean的创建流程如下：</p>
<p><img src="http://storage.laixiaoming.space/blog/circular_dependency.jpg" alt="circular_dependency"></p>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>实现延时任务可以有几种方式</title>
    <url>/2023/06/13/%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在开发中，延时任务属于比较常见的需求，比如，订单在限定时间内未支付则自动取消并释放库存；外卖的商家端在设置特定时间后仍未接单时则自动接单等这都需要延时任务来完成。<br>实现延时任务的方式可以有许多种：<br> 1 DelayQueue(JDK提供实现)<br> 2 ScheduledExecutorService(JDK提供实现)<br> 3 Redis(使用ZSET数据结构实现)<br> 4 RabbitMQ实现<br> 5 ……</p>
<span id="more"></span>

<p>下面我们来简单看看这几种方式的实现，并分析其优缺点。</p>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>DelayQueue属于JDK并发包<strong>java.util.concurrent</strong>中提供的一个类，它是一个无界阻塞队列，元素只有在延迟时间到达时才能被获取。该队列的元素必须实现Delayed接口，队列头部是剩余延迟时间最小的元素。<br>使用过程中，添加任务时使用add()方法，获取任务时使用poll()或take()方法，poll()方法和take()方法的区别是take()方法是阻塞的，如果没有到点的任务可取，take()方法会等待直到可用，而poll()方法则会直接返回null。<br>首先自定义延时任务类型，实现Delayed接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//延迟时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> delayTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务开始时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务消息</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayTask</span><span class="params">(<span class="keyword">long</span> delayTime, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delayTime = delayTime;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.startTime = System.currentTimeMillis() + delayTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelayTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delayTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDelayTime</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delayTime = delayTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStartTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStartTime</span><span class="params">(<span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startTime = startTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(startTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> diff = <span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="keyword">return</span> diff &gt; <span class="number">0</span> ? <span class="number">1</span> : (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过DelayQueue进行存取即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DelayQueue&lt;DelayTask&gt; delayQueue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line"><span class="comment">//添加任务</span></span><br><span class="line">delayQueue.add(t1);</span><br><span class="line"><span class="comment">//获取任务</span></span><br><span class="line">delayQueue.take();</span><br></pre></td></tr></table></figure>



<p>该方式实现非常简单，但缺点也是显而易见的，其适用于单机环境下，而且延迟任务没有进行持久化存储，一旦关机断电，任务便不存在。</p>
<h2 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h2><p>与DelayQueue一样，ScheduledExecutorService同属于<code>java.util.concurrent</code>包中，使用起来也是拿来即用，非常简单的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">executorService.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1s后执行&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>其优缺点与DelayQueue一般，这里就不多说了。</p>
<h2 id="Redis-使用ZSET数据结构实现"><a href="#Redis-使用ZSET数据结构实现" class="headerlink" title="Redis(使用ZSET数据结构实现)"></a>Redis(使用ZSET数据结构实现)</h2><p>ZSET是Redis提供的一种有序集合数据结构，集合的元素value会关联一个double类型的分数(score)，集合会根据这个分数来对元素进行从小到大的排序。<br>我们可以将延时任务消息序列化成一个字符串作为 zset 的value，这个任务消息的到期处理时间作为score进行存储，另外启用一个或者多个线程对集合中的任务进行到期判断处理（以当前时间为界限，获取到集合的首个元素，进行处理并从集合中删除元素），其中，在多线程环境下，为了使获取元素和移除元素的操作的原子性，我们可以使用lua脚本：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> minVal = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> maxVal = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> todolist = redis.call(<span class="string">&quot;ZRANGEBYSCORE&quot;</span>, key, minVal, maxVal, <span class="string">&quot;limit&quot;</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">local</span> todo = todolist[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> todo == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	redis.call(<span class="string">&quot;ZREM&quot;</span>, key, todo)</span><br><span class="line">	<span class="keyword">return</span> todo</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>使用Redis的这种延时任务实现适用于分布式环境，消息也能够保证持久化存储，但获取到期任务的时间间隔较难把握，同时也不能保证任务消息消费过程中的可靠性，就上面的实现来说，如果我们获取到了任务，但还没处理完成出现了异常，操作被中断了，那么这条任务是彻底丢失了。</p>
<h2 id="RabbitMQ实现"><a href="#RabbitMQ实现" class="headerlink" title="RabbitMQ实现"></a>RabbitMQ实现</h2><p>RabbitMQ本身并不提供延时任务功能的实现，但可以通过它的Time-To-Live Extensions 与 Dead Letter Exchange 的特性模拟出延迟队列的功能。<br>RabbitMQ支持为队列或者消息设置TTL（存活时间）。TTL表明了一条消息可在队列中存活的最大时间。当某条消息被设置了TTL或者当某条消息进入了设置了TTL的队列时（如果既配置了消息的TTL，又配置了队列的TTL，那么较小的那个值会被取用），这条消息会在TTL时间后死亡成为Dead Letter。如果为这个队列设置了<strong>x-dead-letter-exchange</strong>和<strong>x-dead-letter-routing-key</strong>，那么这些Dead Letter就会被重新发送到<strong>x-dead-letter-exchange</strong>指定的exchange中，然后通过根据<strong>x-dead-letter-routing-key</strong>路由到相应队列，这时我们通过监听<strong>x-dead-letter-exchange</strong>中绑定的队列，即可实现延迟队列的功能。<br>实例（Spring Boot下）：<br>配置文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.rabbitmq.virtual-host</span>=<span class="string">/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消息发送确认</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirms</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#消息没有相应队列和交换器绑定时是否返回，好像没有用？</span></span><br><span class="line"><span class="comment">#spring.rabbitmq.publisher-returns=true</span></span><br><span class="line"><span class="comment">#与return机制结合配置此属性，true返回消息，false丢弃消息</span></span><br><span class="line"><span class="comment">#spring.rabbitmq.template.mandatory=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消息消费手动确认</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class="string">manual</span></span><br></pre></td></tr></table></figure>

<p>RabbitMQ配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>, <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Dead Letter Exchange</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXEC_EXCHANGE_NAME = <span class="string">&quot;delayed.exec.exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Dead Letter Queue</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXEC_QUEUE_NAME = <span class="string">&quot;delayed.exec.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Dead Letter Routing Key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXEC_ROUTING_KEY = <span class="string">&quot;delayed.exec.routing.key&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXCHANGE_NAME = <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_QUEUE_NAME = <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_ROUTING_KEY = <span class="string">&quot;delayed.routing.key&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(CachingConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">        RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">        rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;correlationData:&quot;</span> + correlationData + <span class="string">&quot;,cause:&quot;</span> + cause);</span><br><span class="line">        <span class="keyword">if</span>(!ack)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送失败！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有找到对应的队列!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;message:&quot;</span> + message +</span><br><span class="line">                <span class="string">&quot;,replyCode:&quot;</span> + replyCode +</span><br><span class="line">                <span class="string">&quot;,replyText:&quot;</span> + replyText +</span><br><span class="line">                <span class="string">&quot;,exchange:&quot;</span> + exchange +</span><br><span class="line">                <span class="string">&quot;,routingKey:&quot;</span> + routingKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delayedQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DELAYED_EXEC_EXCHANGE_NAME);</span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, DELAYED_EXEC_ROUTING_KEY);</span><br><span class="line"><span class="comment">//        params.put(&quot;x-message-ttl&quot;, 5 * 1000);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAYED_QUEUE_NAME, <span class="keyword">true</span>,<span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">delayedExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(DELAYED_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">delayedBind</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayedExchange()).with(DELAYED_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delayedExecQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAYED_EXEC_QUEUE_NAME,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">delayedExecExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(DELAYED_EXEC_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">delayedExecBind</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedExecQueue()).to(delayedExecExchange()).with(DELAYED_EXEC_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RabbitMQ延迟消息发送：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDelayedMsg</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.DELAYED_EXCHANGE_NAME, RabbitMQConfig.DELAYED_ROUTING_KEY, data, message -&gt; &#123;</span><br><span class="line">            message.getMessageProperties().setExpiration(<span class="number">5</span> * <span class="number">1000</span> + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延迟队列监听：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConfig.DELAYED_EXEC_QUEUE_NAME&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delayedExec</span><span class="params">(String data, Message message, Channel channel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;data:&quot;</span> + data);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">//消息确认</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用RabbitMQ的延迟任务实现适用于分布式环境，并且消息也支持持久化，消息的发送和消费也因为有了确认机制的支持而有了更高的可靠性。但需要注意的是，用这种方式实现的延时任务，如果需要实现不同消息的消息有不同的延迟时间的话，共用一个队列是不可行的。比如两条消息，一条延迟时间为20s的消息先抵达队列，另一条延迟时间为10s的消息后抵达，那么此时的消息消费顺序是，经过20s后，第一条消息将会先被消费，第二条消息在紧接其后被消费（与入队顺序保持了一致），在这种情况下，就只能通过设置多个不同延时时间的队列来实现了。</p>
]]></content>
      <tags>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：AOP代理对象的创建</title>
    <url>/2023/06/14/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9AAOP%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AOP是Spring中的核心功能之一，使用AOP，可以让关注点代码与业务代码分离，并且动态地添加和删除在切面上的逻辑而不影响原来的执行代码，从而可以在不修改源代码的情况下，实现对功能的增强。</p>
<p>AOP的应用场景很多，日志记录、性能监控、事务管理等都可以通过AOP去实现。</p>
<p>AOP的原理就是动态代理，在 Spring 中，存在两种实现机制， JDK 动态代理以及 CGLIB 动态代理。</p>
<p>在Spring Boot中，AOP可以通过**@EnableAspectJAutoProxy**注解开启，那该注解是怎么起作用的呢，代理对象又是如何被创建的呢？</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<h2 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed</span></span><br><span class="line"><span class="comment">	 * to standard Java interface-based proxies. The default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Indicate that the proxy should be exposed by the AOP framework as a &#123;<span class="doctag">@code</span> ThreadLocal&#125;</span></span><br><span class="line"><span class="comment">	 * for retrieval via the &#123;<span class="doctag">@link</span> org.springframework.aop.framework.AopContext&#125; class.</span></span><br><span class="line"><span class="comment">	 * Off by default, i.e. no guarantees that &#123;<span class="doctag">@code</span> AopContext&#125; access will work.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.3.1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该注解@Import了<strong>AspectJAutoProxyRegistrar</strong>这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers an &#123;<span class="doctag">@link</span> org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line"><span class="comment"> * AnnotationAwareAspectJAutoProxyCreator&#125; against the current &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment"> * as appropriate based on a given @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy&#125; annotation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span></span><br><span class="line"><span class="comment">	 * of the @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">		AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">				AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">		<span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">				AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line">				AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由类注释可以看出，<strong>AspectJAutoProxyRegistrar</strong>的作用是向IOC容器注册<strong>AnnotationAwareAspectJAutoProxyCreator</strong>。那么<strong>AnnotationAwareAspectJAutoProxyCreator</strong>是什么呢?</p>
<h2 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h2><p>我们先来看下<strong>AnnotationAwareAspectJAutoProxyCreator</strong>的类继承关系图：</p>
<p><img src="http://storage.laixiaoming.space/blog/AnnotationAwareAspectJAutoProxyCreator.jpg" alt="AnnotationAwareAspectJAutoProxyCreator"></p>
<p>可以发现，<strong>AnnotationAwareAspectJAutoProxyCreator</strong>：</p>
<ol>
<li>实现了<strong>BeanPostProcessor **接口，其关键方法</strong>postProcessBeforeInitialization<strong>和</strong>postProcessAfterInitialization<strong>将会在bean创建过程中的初始化流程中</strong>AbstractAutowireCapableBeanFactory#initializeBean<strong>被调用，而AOP代理代理对象也是通过</strong>postProcessAfterInitialization**得到；</li>
<li>实现了<strong>InstantiationAwareBeanPostProcessor</strong>接口，其关键方法<strong>postProcessBeforeInstantiation</strong>会在bean实例化前尝试被调用；</li>
<li>实现了<strong>SmartInstantiationAwareBeanPostProcessor</strong>接口，其关键方法<strong>getEarlyBeanReference</strong>将会作为提前暴露代理对象的入口放入bean的三级缓存中；</li>
</ol>
<p>在本文中，我们主要关注<strong>postProcessAfterInitialization **方法，该方法在</strong>AbstractAutoProxyCreator**中被实现。</p>
<h2 id="AbstractAutoProxyCreator-postProcessAfterInitialization"><a href="#AbstractAutoProxyCreator-postProcessAfterInitialization" class="headerlink" title="AbstractAutoProxyCreator#postProcessAfterInitialization"></a>AbstractAutoProxyCreator#postProcessAfterInitialization</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="earlyProxyReferences"><a href="#earlyProxyReferences" class="headerlink" title="earlyProxyReferences"></a>earlyProxyReferences</h2><p>查看其引用，可以发现只在<strong>getEarlyBeanReference</strong>中被使用，而<strong>getEarlyBeanReference</strong>是在循环引用发生的情况下被调用，结合这里的判断不难看出，这里主要是防止代理对象的重复生成。</p>
<h3 id="wrapIfNecessary"><a href="#wrapIfNecessary" class="headerlink" title="wrapIfNecessary"></a>wrapIfNecessary</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前bean是否在targetSourcedBeans中存在，存在则表示已处理过</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否无需处理</span></span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//isInfrastructureClass判断是否基础设施类型，这里过滤了Advice、PointCut、Advisor、AopInfrastructureBean类型，</span></span><br><span class="line">    <span class="comment">//以及被@Advice标注的类</span></span><br><span class="line">    <span class="comment">//shouldSkip判断是否需要跳过该bean</span></span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取能对该bean进行增强的切面</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="shouldSkip"><a href="#shouldSkip" class="headerlink" title="shouldSkip"></a>shouldSkip</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加载所有的增强器，并将其缓存</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line">        <span class="comment">//跳过增强器类</span></span><br><span class="line">        <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;</span><br><span class="line">            ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用父类实现，如果是原始类型，则跳过</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.shouldSkip(beanClass, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用父类实现，加载Advisor类型的bean</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//加载被@Aspect标注的类，</span></span><br><span class="line">        <span class="comment">//并将@Around、@Before、@After、@AfterReturning、@AfterThrowing标注的方法等构建为Advisor并返回</span></span><br><span class="line">        advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="getAdvicesAndAdvisorsForBean"><a href="#getAdvicesAndAdvisorsForBean" class="headerlink" title="getAdvicesAndAdvisorsForBean"></a>getAdvicesAndAdvisorsForBean</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">			Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line">	<span class="comment">//找到符合条件的增强器</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加载所有的增加器，该方法在shouldSkip中调用过一次，再次调用将从缓存中获取</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="comment">//过滤出匹配到的增强器，这里会根据切入点（@Pointcut）表达式去匹配该bean</span></span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="createProxy"><a href="#createProxy" class="headerlink" title="createProxy"></a>createProxy</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建代理工厂</span></span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    <span class="comment">//从当前类复制配置</span></span><br><span class="line">    proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组合所有增强器，并将其放入代理工厂</span></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过代理工厂创建代理对象</span></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="getProxy"><a href="#getProxy" class="headerlink" title="getProxy"></a>getProxy</h4><p>创建代理对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">        activate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">                                         <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终来到DefaultAopProxyFactory，然后是我们熟悉的逻辑：</p>
<ol>
<li>如果目标对象有接口，用JDK动态代理；</li>
<li>如果没有接口，用CGLIB动态代理；</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>AOP代理对象的创建通过<strong>AnnotationAwareAspectJAutoProxyCreator</strong>实现，该类是<strong>BeanPostProcessor</strong>的子类，并且在不存在循环依赖的情况下，是在<strong>postProcessAfterInitialization</strong>方法中创建的；</li>
<li><strong>postProcessAfterInitialization</strong>中，会匹配出所有和当前Bean相关的增强器，并最终根据实际情况判断是使用JDK动态代理，还是CGLIB动态代理；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：事务生效原理</title>
    <url>/2024/04/13/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E4%BA%8B%E5%8A%A1%E7%94%9F%E6%95%88%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们都知道，在使用Spring进行项目开发时，开启事务只需要在类或者上标注一个**@Transactional**注解即可实现，那么这个是怎么做到的呢？</p>
<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<p>探究其实现原理之前，我们先来看一个**@EnableTransactionManagement**注解。</p>
<span id="more"></span>

<h3 id="从-EnableTransactionManagement说起"><a href="#从-EnableTransactionManagement说起" class="headerlink" title="从@EnableTransactionManagement说起"></a>从@EnableTransactionManagement说起</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(TransactionManagementConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，该注解导入了<strong>TransactionManagementConfigurationSelector</strong>类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TransactionManagementConfigurationSelector extends AdviceModeImportSelector&lt;EnableTransactionManagement&gt; &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">		switch (adviceMode) &#123;</span><br><span class="line">			case PROXY:</span><br><span class="line">				return new String[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">						ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">			case ASPECTJ:</span><br><span class="line">				return new String[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line">			default:</span><br><span class="line">				return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在默认的PROXY模式下，<strong>TransactionManagementConfigurationSelector</strong>类注册了<strong>AutoProxyRegistrar</strong>和<strong>ProxyTransactionManagementConfiguration</strong>类：</p>
<h4 id="AutoProxyRegistrar"><a href="#AutoProxyRegistrar" class="headerlink" title="AutoProxyRegistrar"></a>AutoProxyRegistrar</h4><p>通过深入<strong>AutoProxyRegistrar</strong>可以看到，该类最终又调用了<strong>AopConfigUtils#registerAutoProxyCreatorIfNecessary</strong>注册了<strong>InfrastructureAdvisorAutoProxyCreator</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AopConfigUtils &#123;</span><br><span class="line">	private static final List&lt;Class&lt;?&gt;&gt; APC_PRIORITY_LIST &#x3D; new ArrayList&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">	static &#123;</span><br><span class="line">		&#x2F;&#x2F; Set up the escalation list...</span><br><span class="line">		APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);</span><br><span class="line">		APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class);</span><br><span class="line">		APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">	@Nullable</span><br><span class="line">	public static BeanDefinition registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		return registerAutoProxyCreatorIfNecessary(registry, null);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static BeanDefinition registerAutoProxyCreatorIfNecessary(</span><br><span class="line">			BeanDefinitionRegistry registry, @Nullable Object source) &#123;</span><br><span class="line"></span><br><span class="line">		return registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Nullable</span><br><span class="line">	private static BeanDefinition registerOrEscalateApcAsRequired(</span><br><span class="line">			Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source) &#123;</span><br><span class="line"></span><br><span class="line">		Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;如果该bean已存在，将根据APC_PRIORITY_LIST中定义的优先级进行加载&#x2F;替换</span><br><span class="line">		if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">			BeanDefinition apcDefinition &#x3D; registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">			if (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">				int currentPriority &#x3D; findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">				int requiredPriority &#x3D; findPriorityForClass(cls);</span><br><span class="line">				if (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">					apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		RootBeanDefinition beanDefinition &#x3D; new RootBeanDefinition(cls);</span><br><span class="line">		beanDefinition.setSource(source);</span><br><span class="line">		beanDefinition.getPropertyValues().add(&quot;order&quot;, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">		beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">		registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">		return beanDefinition;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，<strong>InfrastructureAdvisorAutoProxyCreator</strong>有什么作用呢</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Auto-proxy creator that considers infrastructure Advisor beans only,</span><br><span class="line"> * ignoring any application-defined Advisors.</span><br><span class="line"> *</span><br><span class="line"> * @author Juergen Hoeller</span><br><span class="line"> * @since 2.0.7</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SuppressWarnings(&quot;serial&quot;)</span><br><span class="line">public class InfrastructureAdvisorAutoProxyCreator extends AbstractAdvisorAutoProxyCreator &#123;</span><br><span class="line"></span><br><span class="line">	@Nullable</span><br><span class="line">	private ConfigurableListableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected void initBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">		super.initBeanFactory(beanFactory);</span><br><span class="line">		this.beanFactory &#x3D; beanFactory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected boolean isEligibleAdvisorBean(String beanName) &#123;</span><br><span class="line">		return (this.beanFactory !&#x3D; null &amp;&amp; this.beanFactory.containsBeanDefinition(beanName) &amp;&amp;</span><br><span class="line">				this.beanFactory.getBeanDefinition(beanName).getRole() &#x3D;&#x3D; BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码注释中可以看出，这是一个代理对象创建器。</p>
<p>了解过**@EnableAspectJAutoProxy<strong>注解原理的可能会发现，这俩走的是同一个注册方法，而对于同时开启</strong>EnableAspectJAutoProxy<strong>和</strong>EnableTransactionManagement<strong>的情况下，在注册的时候会根据定义的优先级</strong>AnnotationAwareAspectJAutoProxyCreator &gt; AspectJAwareAdvisorAutoProxyCreator &gt; InfrastructureAdvisorAutoProxyCreator<strong>，保留其中一个，通过对比其实现可以知道，</strong>AnnotationAwareAspectJAutoProxyCreator**具有的功能更全面。</p>
<h4 id="ProxyTransactionManagementConfiguration"><a href="#ProxyTransactionManagementConfiguration" class="headerlink" title="ProxyTransactionManagementConfiguration"></a>ProxyTransactionManagementConfiguration</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ProxyTransactionManagementConfiguration extends AbstractTransactionManagementConfiguration &#123;</span><br><span class="line"></span><br><span class="line">	@Bean(name &#x3D; TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span><br><span class="line">	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">	public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor() &#123;</span><br><span class="line">		BeanFactoryTransactionAttributeSourceAdvisor advisor &#x3D; new BeanFactoryTransactionAttributeSourceAdvisor();</span><br><span class="line">		advisor.setTransactionAttributeSource(transactionAttributeSource());</span><br><span class="line">		advisor.setAdvice(transactionInterceptor());</span><br><span class="line">		if (this.enableTx !&#x3D; null) &#123;</span><br><span class="line">			advisor.setOrder(this.enableTx.&lt;Integer&gt;getNumber(&quot;order&quot;));</span><br><span class="line">		&#125;</span><br><span class="line">		return advisor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">	public TransactionAttributeSource transactionAttributeSource() &#123;</span><br><span class="line">		return new AnnotationTransactionAttributeSource();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">	public TransactionInterceptor transactionInterceptor() &#123;</span><br><span class="line">		TransactionInterceptor interceptor &#x3D; new TransactionInterceptor();</span><br><span class="line">		interceptor.setTransactionAttributeSource(transactionAttributeSource());</span><br><span class="line">		if (this.txManager !&#x3D; null) &#123;</span><br><span class="line">			interceptor.setTransactionManager(this.txManager);</span><br><span class="line">		&#125;</span><br><span class="line">		return interceptor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ProxyTransactionManagementConfiguration</strong>注册了3个bean。</p>
<h5 id="transactionAdvisor"><a href="#transactionAdvisor" class="headerlink" title="transactionAdvisor"></a>transactionAdvisor</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BeanFactoryTransactionAttributeSourceAdvisor extends AbstractBeanFactoryPointcutAdvisor &#123;</span><br><span class="line"></span><br><span class="line">	@Nullable</span><br><span class="line">	private TransactionAttributeSource transactionAttributeSource;</span><br><span class="line"></span><br><span class="line">	private final TransactionAttributeSourcePointcut pointcut &#x3D; new TransactionAttributeSourcePointcut() &#123;</span><br><span class="line">		@Override</span><br><span class="line">		@Nullable</span><br><span class="line">		protected TransactionAttributeSource getTransactionAttributeSource() &#123;</span><br><span class="line">			return transactionAttributeSource;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Set the transaction attribute source which is used to find transaction</span><br><span class="line">	 * attributes. This should usually be identical to the source reference</span><br><span class="line">	 * set on the transaction interceptor itself.</span><br><span class="line">	 * @see TransactionInterceptor#setTransactionAttributeSource</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void setTransactionAttributeSource(TransactionAttributeSource transactionAttributeSource) &#123;</span><br><span class="line">		this.transactionAttributeSource &#x3D; transactionAttributeSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Set the &#123;@link ClassFilter&#125; to use for this pointcut.</span><br><span class="line">	 * Default is &#123;@link ClassFilter#TRUE&#125;.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void setClassFilter(ClassFilter classFilter) &#123;</span><br><span class="line">		this.pointcut.setClassFilter(classFilter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Pointcut getPointcut() &#123;</span><br><span class="line">		return this.pointcut;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAttributeSourcePointcut</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcut</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (TransactionalProxy.class.isAssignableFrom(targetClass) ||</span><br><span class="line">				PlatformTransactionManager.class.isAssignableFrom(targetClass) ||</span><br><span class="line">				PersistenceExceptionTranslator.class.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">		<span class="keyword">return</span> (tas == <span class="keyword">null</span> || tas.getTransactionAttribute(method, targetClass) != <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<strong>BeanFactoryTransactionAttributeSourceAdvisor</strong>的类继承关系图可以看出，它是一个事务增强器，并且其切入点实现依赖于<strong>TransactionAttributeSource</strong>，在这里的具体实现是<strong>AnnotationTransactionAttributeSource</strong>，其关键的方法是<strong>TransactionAttributeSource#getTransactionAttribute</strong>。</p>
<h5 id="AnnotationTransactionAttributeSource"><a href="#AnnotationTransactionAttributeSource" class="headerlink" title="AnnotationTransactionAttributeSource"></a>AnnotationTransactionAttributeSource</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">This class reads Spring&#39;s JDK 1.5+ Transactional annotation and exposes corresponding transaction attributes to Spring&#39;s transaction infrastructure. Also supports JTA 1.2&#39;s javax.transaction.Transactional and EJB3&#39;s javax.ejb.TransactionAttribute annotation (if present). This class may also serve as base class for a custom TransactionAttributeSource, or get customized through TransactionAnnotationParser strategies.</span><br><span class="line">**&#x2F;</span><br><span class="line">public class AnnotationTransactionAttributeSource extends AbstractFallbackTransactionAttributeSource</span><br><span class="line">		implements Serializable &#123;</span><br><span class="line">		&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从该类的注释可以看出，该类主要用于解析**@Transactional<strong>注解，并将其属性提供给事务框架使用，而从其构造函数可以知道，它使用了</strong>SpringTransactionAnnotationParser**作为事务属性配置的解析器。</p>
<h5 id="transactionInterceptor"><a href="#transactionInterceptor" class="headerlink" title="transactionInterceptor"></a>transactionInterceptor</h5><p><img src="http://storage.laixiaoming.space/blog/image-20240413174621857.png" alt="image-20240413174621857"></p>
<p>从该类的继承关系图可以看出，<strong>TransactionInterceptor</strong>实现了<strong>MethodInterceptor</strong>，是一个方法拦截器，不验证猜出事务是行为是在这个类中实现的，接下来我们具体看下<strong>TransactionInterceptor</strong> 到底做了什么。</p>
<h3 id="TransactionInterceptor工作原理"><a href="#TransactionInterceptor工作原理" class="headerlink" title="TransactionInterceptor工作原理"></a>TransactionInterceptor工作原理</h3><p><strong>invoke</strong>是<strong>MethodInterceptor</strong>的核心方法，其主要逻辑在<strong>invokeWithinTransaction</strong>体现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="comment">// Work out the target class: may be &#123;@code null&#125;.</span></span><br><span class="line">	<span class="comment">// The TransactionAttributeSource should be passed the target class</span></span><br><span class="line">	<span class="comment">// as well as the method, which may be from an interface.</span></span><br><span class="line">	Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...</span></span><br><span class="line">	<span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="invokeWithinTransaction事务整体流程"><a href="#invokeWithinTransaction事务整体流程" class="headerlink" title="invokeWithinTransaction事务整体流程"></a>invokeWithinTransaction事务整体流程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,</span><br><span class="line">		final InvocationCallback invocation) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; If the transaction attribute is null, the method is non-transactional.</span><br><span class="line">	TransactionAttributeSource tas &#x3D; getTransactionAttributeSource();</span><br><span class="line">	&#x2F;&#x2F;获取@Transaction属性配置</span><br><span class="line">	final TransactionAttribute txAttr &#x3D; (tas !&#x3D; null ? tas.getTransactionAttribute(method, targetClass) : null);</span><br><span class="line">	&#x2F;&#x2F;获取事务管理器</span><br><span class="line">	final PlatformTransactionManager tm &#x3D; determineTransactionManager(txAttr);</span><br><span class="line">	final String joinpointIdentification &#x3D; methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">	if (txAttr &#x3D;&#x3D; null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">		&#x2F;&#x2F; Standard transaction demarcation with getTransaction and commit&#x2F;rollback calls.</span><br><span class="line">		&#x2F;&#x2F;创建事务</span><br><span class="line">		TransactionInfo txInfo &#x3D; createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">		Object retVal;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; This is an around advice: Invoke the next interceptor in the chain.</span><br><span class="line">			&#x2F;&#x2F; This will normally result in a target object being invoked.</span><br><span class="line">			retVal &#x3D; invocation.proceedWithInvocation();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			&#x2F;&#x2F; target invocation exception</span><br><span class="line">			&#x2F;&#x2F;回滚事务</span><br><span class="line">			completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			cleanupTransactionInfo(txInfo);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;提交事务</span><br><span class="line">		commitTransactionAfterReturning(txInfo);</span><br><span class="line">		return retVal;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F;...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出，这里使用的是环绕通知处理器，事务的开启-提交-回滚操作均在这体现。</p>
<h4 id="createTransactionIfNecessary开启事务"><a href="#createTransactionIfNecessary开启事务" class="headerlink" title="createTransactionIfNecessary开启事务"></a>createTransactionIfNecessary开启事务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,</span><br><span class="line">		@Nullable TransactionAttribute txAttr, final String joinpointIdentification) &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; If no name specified, apply method identification as transaction name.</span><br><span class="line">	if (txAttr !&#x3D; null &amp;&amp; txAttr.getName() &#x3D;&#x3D; null) &#123;</span><br><span class="line">		txAttr &#x3D; new DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public String getName() &#123;</span><br><span class="line">				return joinpointIdentification;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TransactionStatus status &#x3D; null;</span><br><span class="line">	if (txAttr !&#x3D; null) &#123;</span><br><span class="line">		if (tm !&#x3D; null) &#123;</span><br><span class="line">			&#x2F;&#x2F;获取事务状态</span><br><span class="line">			status &#x3D; tm.getTransaction(txAttr);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Skipping transactional joinpoint [&quot; + joinpointIdentification +</span><br><span class="line">						&quot;] because no transaction manager has been configured&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="事务的传播机制"><a href="#事务的传播机制" class="headerlink" title="事务的传播机制"></a>事务的传播机制</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException &#123;</span><br><span class="line">	Object transaction &#x3D; doGetTransaction();</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Cache debug flag to avoid repeated checks.</span><br><span class="line">	boolean debugEnabled &#x3D; logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">	if (definition &#x3D;&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F; Use defaults if no transaction definition given.</span><br><span class="line">		definition &#x3D; new DefaultTransactionDefinition();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;是否存在当前事务</span><br><span class="line">	if (isExistingTransaction(transaction)) &#123;</span><br><span class="line">		&#x2F;&#x2F; Existing transaction found -&gt; check propagation behavior to find out how to behave.</span><br><span class="line">		return handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Check definition settings for new transaction.</span><br><span class="line">	if (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">		throw new InvalidTimeoutException(&quot;Invalid transaction timeout&quot;, definition.getTimeout());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;当前事务不存在，则根据事务传播行为做不同处理</span><br><span class="line">	&#x2F;&#x2F; No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span><br><span class="line">	if (definition.getPropagationBehavior() &#x3D;&#x3D; TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">		throw new IllegalTransactionStateException(</span><br><span class="line">				&quot;No existing transaction found for transaction marked with propagation &#39;mandatory&#39;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (definition.getPropagationBehavior() &#x3D;&#x3D; TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">			definition.getPropagationBehavior() &#x3D;&#x3D; TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">			definition.getPropagationBehavior() &#x3D;&#x3D; TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">		&#x2F;&#x2F;挂起当前事务，当前事务为不存在，不需要挂起</span><br><span class="line">		SuspendedResourcesHolder suspendedResources &#x3D; suspend(null);</span><br><span class="line">		if (debugEnabled) &#123;</span><br><span class="line">			logger.debug(&quot;Creating new transaction with name [&quot; + definition.getName() + &quot;]: &quot; + definition);</span><br><span class="line">		&#125;</span><br><span class="line">		try &#123;</span><br><span class="line">			boolean newSynchronization &#x3D; (getTransactionSynchronization() !&#x3D; SYNCHRONIZATION_NEVER);</span><br><span class="line">			DefaultTransactionStatus status &#x3D; newTransactionStatus(</span><br><span class="line">					definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">			doBegin(transaction, definition);</span><br><span class="line">			prepareSynchronization(status, definition);</span><br><span class="line">			return status;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (RuntimeException | Error ex) &#123;</span><br><span class="line">			resume(null, suspendedResources);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F; Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span><br><span class="line">		if (definition.getIsolationLevel() !&#x3D; TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">			logger.warn(&quot;Custom isolation level specified but no actual transaction initiated; &quot; +</span><br><span class="line">					&quot;isolation level will effectively be ignored: &quot; + definition);</span><br><span class="line">		&#125;</span><br><span class="line">		boolean newSynchronization &#x3D; (getTransactionSynchronization() &#x3D;&#x3D; SYNCHRONIZATION_ALWAYS);</span><br><span class="line">		return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从getTransaction代码处理上看，在不存在当前事务的情况下，事务传播行为：</p>
<ol>
<li><p>是<strong>MANDATORY</strong>类型时，则直接抛出异常，因为此时还没有事务</p>
</li>
<li><p>是<strong>REQUIRED</strong>、<strong>REQUIRES_NEW</strong>、<strong>NESTED</strong>类型时，则创建一个新的事务</p>
</li>
<li><p>其余情况，返回空事务</p>
</li>
</ol>
<p>而在存在当前事务的情况下，<strong>handleExistingTransaction</strong>方法将被执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private TransactionStatus handleExistingTransaction(</span><br><span class="line">		TransactionDefinition definition, Object transaction, boolean debugEnabled)</span><br><span class="line">		throws TransactionException &#123;</span><br><span class="line">	&#x2F;&#x2F;传播行为是NEVER，则不允许执行</span><br><span class="line">	if (definition.getPropagationBehavior() &#x3D;&#x3D; TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line">		throw new IllegalTransactionStateException(</span><br><span class="line">				&quot;Existing transaction found for transaction marked with propagation &#39;never&#39;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;传播行为是NOT_SUPPORTED，挂起当前事务</span><br><span class="line">	if (definition.getPropagationBehavior() &#x3D;&#x3D; TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line">		if (debugEnabled) &#123;</span><br><span class="line">			logger.debug(&quot;Suspending current transaction&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		Object suspendedResources &#x3D; suspend(transaction);</span><br><span class="line">		boolean newSynchronization &#x3D; (getTransactionSynchronization() &#x3D;&#x3D; SYNCHRONIZATION_ALWAYS);</span><br><span class="line">		return prepareTransactionStatus(</span><br><span class="line">				definition, null, false, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;传播行为是REQUIRED_NEW，挂起当前事务，并新建一个事务</span><br><span class="line">	if (definition.getPropagationBehavior() &#x3D;&#x3D; TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line">		if (debugEnabled) &#123;</span><br><span class="line">			logger.debug(&quot;Suspending current transaction, creating new transaction with name [&quot; +</span><br><span class="line">					definition.getName() + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		SuspendedResourcesHolder suspendedResources &#x3D; suspend(transaction);</span><br><span class="line">		try &#123;</span><br><span class="line">			boolean newSynchronization &#x3D; (getTransactionSynchronization() !&#x3D; SYNCHRONIZATION_NEVER);</span><br><span class="line">			DefaultTransactionStatus status &#x3D; newTransactionStatus(</span><br><span class="line">					definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">			doBegin(transaction, definition);</span><br><span class="line">			prepareSynchronization(status, definition);</span><br><span class="line">			return status;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (RuntimeException | Error beginEx) &#123;</span><br><span class="line">			resumeAfterBeginException(transaction, suspendedResources, beginEx);</span><br><span class="line">			throw beginEx;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;传播行为是NESTED，创建一个保存点</span><br><span class="line">	if (definition.getPropagationBehavior() &#x3D;&#x3D; TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">		if (!isNestedTransactionAllowed()) &#123;</span><br><span class="line">			throw new NestedTransactionNotSupportedException(</span><br><span class="line">					&quot;Transaction manager does not allow nested transactions by default - &quot; +</span><br><span class="line">					&quot;specify &#39;nestedTransactionAllowed&#39; property with value &#39;true&#39;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (debugEnabled) &#123;</span><br><span class="line">			logger.debug(&quot;Creating nested transaction with name [&quot; + definition.getName() + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (useSavepointForNestedTransaction()) &#123;</span><br><span class="line">			&#x2F;&#x2F; Create savepoint within existing Spring-managed transaction,</span><br><span class="line">			&#x2F;&#x2F; through the SavepointManager API implemented by TransactionStatus.</span><br><span class="line">			&#x2F;&#x2F; Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.</span><br><span class="line">			DefaultTransactionStatus status &#x3D;</span><br><span class="line">					prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);</span><br><span class="line">			status.createAndHoldSavepoint();</span><br><span class="line">			return status;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			&#x2F;&#x2F; Nested transaction through nested begin and commit&#x2F;rollback calls.</span><br><span class="line">			&#x2F;&#x2F; Usually only for JTA: Spring synchronization might get activated here</span><br><span class="line">			&#x2F;&#x2F; in case of a pre-existing JTA transaction.</span><br><span class="line">			boolean newSynchronization &#x3D; (getTransactionSynchronization() !&#x3D; SYNCHRONIZATION_NEVER);</span><br><span class="line">			DefaultTransactionStatus status &#x3D; newTransactionStatus(</span><br><span class="line">					definition, transaction, true, newSynchronization, debugEnabled, null);</span><br><span class="line">			doBegin(transaction, definition);</span><br><span class="line">			prepareSynchronization(status, definition);</span><br><span class="line">			return status;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.</span><br><span class="line">	if (debugEnabled) &#123;</span><br><span class="line">		logger.debug(&quot;Participating in existing transaction&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (isValidateExistingTransaction()) &#123;</span><br><span class="line">		if (definition.getIsolationLevel() !&#x3D; TransactionDefinition.ISOLATION_DEFAULT) &#123;</span><br><span class="line">			Integer currentIsolationLevel &#x3D; TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">			if (currentIsolationLevel &#x3D;&#x3D; null || currentIsolationLevel !&#x3D; definition.getIsolationLevel()) &#123;</span><br><span class="line">				Constants isoConstants &#x3D; DefaultTransactionDefinition.constants;</span><br><span class="line">				throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; +</span><br><span class="line">						definition + &quot;] specifies isolation level which is incompatible with existing transaction: &quot; +</span><br><span class="line">						(currentIsolationLevel !&#x3D; null ?</span><br><span class="line">								isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :</span><br><span class="line">								&quot;(unknown)&quot;));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!definition.isReadOnly()) &#123;</span><br><span class="line">			if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123;</span><br><span class="line">				throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; +</span><br><span class="line">						definition + &quot;] is not marked as read-only but existing transaction is&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	boolean newSynchronization &#x3D; (getTransactionSynchronization() !&#x3D; SYNCHRONIZATION_NEVER);</span><br><span class="line">	return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在存在当前事务的情况下，事务传播行为：</p>
<ol>
<li>是<strong>NEVER</strong>时，不允许继续执行；</li>
<li>是<strong>NOT_SUPPORTED</strong>时，挂起当前事务；</li>
<li>是<strong>REQUIRED_NEW</strong>是时，挂起当前事务，并新建一个新事务；</li>
<li>是<strong>NESTED</strong>时，创建一个保存点；</li>
</ol>
<h5 id="事务的挂起和恢复"><a href="#事务的挂起和恢复" class="headerlink" title="事务的挂起和恢复"></a>事务的挂起和恢复</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException &#123;</span><br><span class="line">	if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">		&#x2F;&#x2F;记录当前的事务同步管理器信息</span><br><span class="line">		List&lt;TransactionSynchronization&gt; suspendedSynchronizations &#x3D; doSuspendSynchronization();</span><br><span class="line">		try &#123;</span><br><span class="line">			Object suspendedResources &#x3D; null;</span><br><span class="line">			if (transaction !&#x3D; null) &#123;</span><br><span class="line">				&#x2F;&#x2F;挂起当前事务</span><br><span class="line">				suspendedResources &#x3D; doSuspend(transaction);</span><br><span class="line">			&#125;</span><br><span class="line">			String name &#x3D; TransactionSynchronizationManager.getCurrentTransactionName();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionName(null);</span><br><span class="line">			boolean readOnly &#x3D; TransactionSynchronizationManager.isCurrentTransactionReadOnly();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionReadOnly(false);</span><br><span class="line">			Integer isolationLevel &#x3D; TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null);</span><br><span class="line">			boolean wasActive &#x3D; TransactionSynchronizationManager.isActualTransactionActive();</span><br><span class="line">			TransactionSynchronizationManager.setActualTransactionActive(false);</span><br><span class="line">			return new SuspendedResourcesHolder(</span><br><span class="line">					suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (RuntimeException | Error ex) &#123;</span><br><span class="line">			&#x2F;&#x2F; doSuspend failed - original transaction is still active...</span><br><span class="line">			doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (transaction !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F; Transaction active but no synchronization active.</span><br><span class="line">		Object suspendedResources &#x3D; doSuspend(transaction);</span><br><span class="line">		return new SuspendedResourcesHolder(suspendedResources);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F; Neither transaction nor synchronization active.</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Object doSuspend(Object transaction) &#123;</span><br><span class="line">	DataSourceTransactionObject txObject &#x3D; (DataSourceTransactionObject) transaction;</span><br><span class="line">	txObject.setConnectionHolder(null);</span><br><span class="line">	return TransactionSynchronizationManager.unbindResource(obtainDataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Object unbindResource(Object key) throws IllegalStateException &#123;</span><br><span class="line">	Object actualKey &#x3D; TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);</span><br><span class="line">	Object value &#x3D; doUnbindResource(actualKey);</span><br><span class="line">	if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">		throw new IllegalStateException(</span><br><span class="line">				&quot;No value for key [&quot; + actualKey + &quot;] bound to thread [&quot; + Thread.currentThread().getName() + &quot;]&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static Object doUnbindResource(Object actualKey) &#123;</span><br><span class="line">	Map&lt;Object, Object&gt; map &#x3D; resources.get();</span><br><span class="line">	if (map &#x3D;&#x3D; null) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	Object value &#x3D; map.remove(actualKey);</span><br><span class="line">	&#x2F;&#x2F; Remove entire ThreadLocal if empty...</span><br><span class="line">	if (map.isEmpty()) &#123;</span><br><span class="line">		resources.remove();</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; Transparently suppress a ResourceHolder that was marked as void...</span><br><span class="line">	if (value instanceof ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123;</span><br><span class="line">		value &#x3D; null;</span><br><span class="line">	&#125;</span><br><span class="line">	if (value !&#x3D; null &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(&quot;Removed value [&quot; + value + &quot;] for key [&quot; + actualKey + &quot;] from thread [&quot; +</span><br><span class="line">				Thread.currentThread().getName() + &quot;]&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，事务的挂起实际是对当前事务的状态信息和数据源连接对象封装到<strong>SuspendedResourcesHolder</strong>对象中，并将线程本地变量保存的事务状态清除。</p>
<p>那什么时候进行恢复呢？通过查看代码可以发现，在事务提交或者回滚后，org.springframework.transaction.support.AbstractPlatformTransactionManager#cleanupAfterCompletion，会进行挂起事务的恢复：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void cleanupAfterCompletion(DefaultTransactionStatus status) &#123;</span><br><span class="line">	status.setCompleted();</span><br><span class="line">	if (status.isNewSynchronization()) &#123;</span><br><span class="line">		TransactionSynchronizationManager.clear();</span><br><span class="line">	&#125;</span><br><span class="line">	if (status.isNewTransaction()) &#123;</span><br><span class="line">		doCleanupAfterCompletion(status.getTransaction());</span><br><span class="line">	&#125;</span><br><span class="line">	if (status.getSuspendedResources() !&#x3D; null) &#123;</span><br><span class="line">		if (status.isDebug()) &#123;</span><br><span class="line">			logger.debug(&quot;Resuming suspended transaction after completion of inner transaction&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		Object transaction &#x3D; (status.hasTransaction() ? status.getTransaction() : null);</span><br><span class="line">		resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final void resume(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder)</span><br><span class="line">		throws TransactionException &#123;</span><br><span class="line"></span><br><span class="line">	if (resourcesHolder !&#x3D; null) &#123;</span><br><span class="line">		Object suspendedResources &#x3D; resourcesHolder.suspendedResources;</span><br><span class="line">		if (suspendedResources !&#x3D; null) &#123;</span><br><span class="line">			doResume(transaction, suspendedResources);</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;TransactionSynchronization&gt; suspendedSynchronizations &#x3D; resourcesHolder.suspendedSynchronizations;</span><br><span class="line">		if (suspendedSynchronizations !&#x3D; null) &#123;</span><br><span class="line">			TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive);</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel);</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly);</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name);</span><br><span class="line">			doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>Spring事务也是通过AOP实现，相关逻辑由<strong>BeanFactoryTransactionAttributeSourceAdvisor、</strong>TransactionAttributeSource**<strong>、</strong>TransactionInterceptor**实现；</li>
<li>事务的挂起与恢复，实际是通过线程本地变量对当前事务信息的保存、清除和恢复；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
</search>
