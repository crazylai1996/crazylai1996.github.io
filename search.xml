<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>认识高性能队列——Disruptor</title>
    <url>/2023/05/01/%E8%AE%A4%E8%AF%86%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Disruptor/</url>
    <content><![CDATA[<h2 id="Disruptor是什么"><a href="#Disruptor是什么" class="headerlink" title="Disruptor是什么"></a>Disruptor是什么</h2><p>Disruptor是一个由英国外汇交易公司LMAX研发并开源的高性能的有界内存队列，其主要用于在线程之间完成数据的传递。<a href="https://github.com/LMAX-Exchange/disruptor">github地址</a><br>那么，以高性能著称的Disruptor到底有多快呢？</p>
<span id="more"></span>

<p>我将常用的2种线程安全队列（ArrayBlockingQueue和LinkedBlockingQueue）与Disruptor作了个简单对比，场景是启动两个线程，一个线程往队列填充自增数字，另一个线程取数字进行累加，其对比结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000w</span><br><span class="line">ArrayBlockingQueue耗时：927ms</span><br><span class="line">LinkedBlockingQueue耗时：1495ms</span><br><span class="line">Disruptor耗时：598ms</span><br><span class="line">5000w</span><br><span class="line">ArrayBlockingQueue耗时：4044ms</span><br><span class="line">LinkedBlockingQueue耗时：11145ms</span><br><span class="line">Disruptor耗时：2824ms</span><br><span class="line">1e</span><br><span class="line">ArrayBlockingQueue耗时：7514ms</span><br><span class="line">LinkedBlockingQueue耗时：23144ms</span><br><span class="line">Disruptor耗时：4668ms</span><br></pre></td></tr></table></figure>
<p>可以看到，Disruptor在速度上较其他两个队列有着明显的优势。</p>
<h2 id="为什么可以这么快"><a href="#为什么可以这么快" class="headerlink" title="为什么可以这么快"></a>为什么可以这么快</h2><h3 id="内存预分配"><a href="#内存预分配" class="headerlink" title="内存预分配"></a>内存预分配</h3><p>在Disruptor里，底层存储为数组结构，而事件（Event）作为真实数据的一个载体，在初始化时会调用预设的EventFactory创建对应数量的Event填充数组，加上其环形数组的设计，数组中的Event对象可以很方便地实现复用，这在一定程度可以减少GC的次数，提升了性能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void fill(EventFactory&lt;E&gt; eventFactory)&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; bufferSize; i++)&#123;</span><br><span class="line">        entries[BUFFER_PAD + i] &#x3D; eventFactory.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消除“伪共享”，充分利用硬件缓存"><a href="#消除“伪共享”，充分利用硬件缓存" class="headerlink" title="消除“伪共享”，充分利用硬件缓存"></a>消除“伪共享”，充分利用硬件缓存</h3><h4 id="什么是“伪共享”"><a href="#什么是“伪共享”" class="headerlink" title="什么是“伪共享”"></a>什么是“伪共享”</h4><p>每个CPU核心都有自己独立的cache和寄存器，主存与CPU之间存在着多级cache，L3，L2，L1，而越靠近CPU核心，速度也越快，为也提高处理速度，处理器不直接与主存通信，主存的访问首先会进入cache，所有的修改默认会异步刷新到主存。同时在多核心处理器下，为了保证各个核心的缓存是一致的，会实现缓存一致性协议。<br>而伪共享指的是由于共享缓存行（通常为64个字节）导致缓存无效的场景：</p>
<p><img src="http://storage.laixiaoming.space/blog/cpu_cache.jpg" alt="cpu_cache"></p>
<p>就上图场景而言，线程1和线程2运行分别运行在两个核心上，线程1对putIndex读写，线程2对takeIndex读写，由于putIndex与takeIndex内存的相邻性，在加载到缓存时将被读到同一个缓存行中，而由于对其中一个变量的写操作会使缓存回写到主存，造成整个缓存行的失效，这也导致了同处于同一个缓存行的其他变量的缓存失效。</p>
<h4 id="它是如何被消除的"><a href="#它是如何被消除的" class="headerlink" title="它是如何被消除的"></a>它是如何被消除的</h4><p>一方面，底层采用数组结构，CPU在加载数据时，会根据空间局部性原理，把相邻的数据一起加载进来，由于由于数组上结构的内存分配是连续的，也就能更好地利用CPU的缓存；<br>另一方面，通过增加无意义变量，增大变量间的间隔，使得一个变量可以独占一个缓存行，以空间换取时间（注： Java 8 可以使用@Contended注解，配合JVM参数-XX:-RestrictContended，来消除“伪共享”）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LhsPadding</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;7*8个字节</span><br><span class="line">    protected long p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Value extends LhsPadding</span><br><span class="line">&#123;</span><br><span class="line">    protected volatile long value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RhsPadding extends Value</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;7*8个字节</span><br><span class="line">    protected long p9, p10, p11, p12, p13, p14, p15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无锁数据结构RingBuffer"><a href="#无锁数据结构RingBuffer" class="headerlink" title="无锁数据结构RingBuffer"></a>无锁数据结构RingBuffer</h3><p><img src="http://storage.laixiaoming.space/blog/ringbuffer.jpg" alt="ringbuffer"></p>
<p>RingBuffer作为Disruptor的底层数据结构，其内部有一个cursor变量，表示当前可读的最大下标，cursor是Sequence类的一个对象，其内部维护了一个long类型的value成员，value使用了volatile修饰，在不使用锁的前提下保证了线程之间的可见性，并通过Unsafe工具封装了对value变量的CAS系列操作。<br>关于volatile变量，有以下两个特性：<br>可见性：对一个volatile变量读，总能看到（任意线程）对这个变量的最后写入；<br>原子性：对任意单个volatile变量的读/写具有原子性；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Sequence extends RhsPadding</span><br><span class="line">&#123;</span><br><span class="line">	static final long INITIAL_VALUE &#x3D; -1L;</span><br><span class="line">    private static final Unsafe UNSAFE;</span><br><span class="line">    private static final long VALUE_OFFSET;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h4><p>RingBuffer数据的写入分为两个阶段，在第一阶段会先申请下一个可写入节点（cursor+1），多写入者模式下通过CAS操作移动cursor，来保存线程安全性；第二阶段，数据提交，提交时为保证顺序写，需要保证cursor追上当前提交的写入位置。<br>写入成功后，再调用具体的WaitStrategy实现通知其他消费线程</p>
<p><img src="http://storage.laixiaoming.space/blog/ringbuffer_write.jpg" alt="ringbuffer_write"></p>
<h4 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h4><p>在读取数据的时候，多个消费者可以同时消费，每个消费者都会维护有一个读取位置，在没有可读数据时，通过具体的WaitStrategy进行等待（阻塞等待或自旋等）。</p>
<p><img src="http://storage.laixiaoming.space/blog/ringbuffer_read.jpg" alt="ringbuffer_read"></p>
<h2 id="简单上手-生产者-消费者模型"><a href="#简单上手-生产者-消费者模型" class="headerlink" title="简单上手(生产者-消费者模型)"></a>简单上手(生产者-消费者模型)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DisruptorStart &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; RingBuffer大小，2的幂次</span><br><span class="line">        int bufferSize &#x3D; 1024;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建Disruptor</span><br><span class="line">        Disruptor&lt;LongEvent&gt; disruptor &#x3D; new Disruptor&lt;&gt;(</span><br><span class="line">                LongEvent::new,</span><br><span class="line">                bufferSize,</span><br><span class="line">                DaemonThreadFactory.INSTANCE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 事件消费</span><br><span class="line">        disruptor.handleEventsWith((event, sequence, endOfBatch) -&gt; System.out.println(&quot;Event: &quot; + event));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 启动</span><br><span class="line">        disruptor.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 拿到RingBuffer，用于向队列传输数据</span><br><span class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer &#x3D; disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">        ByteBuffer bb &#x3D; ByteBuffer.allocate(8);</span><br><span class="line">        for (long l &#x3D; 0; true; l++) &#123;</span><br><span class="line">            bb.putLong(0, l);</span><br><span class="line">            &#x2F;&#x2F;往队列填充数据</span><br><span class="line">            ringBuffer.publishEvent((event, sequence, buffer) -&gt; event.set(buffer.getLong(0)), bb);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考：<br><a href="https://ifeve.com/disruptor">并发框架Disruptor译文</a><br><a href="https://tech.meituan.com/2016/11/18/disruptor.html">高性能队列——Disruptor</a><br><a href="https://blog.csdn.net/twypx/article/details/80398886">Disruptor系列3：Disruptor样例实战</a></p>
]]></content>
      <tags>
        <tag>内存队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：自动配置原理</title>
    <url>/2023/05/02/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“约定优于配置”是Spring Boot倡导的一个思想，而其自动配置的特性则恰好体现了这一思想。而有了自动配置，不仅简化了Maven的依赖配置，更重要的是摆脱了以往使用Spring框架开发时，所必须编写的一堆繁琐的xml配置文件。</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<h2 id="从-SpringBootApplication注解说起"><a href="#从-SpringBootApplication注解说起" class="headerlink" title="从@SpringBootApplication注解说起"></a>从@SpringBootApplication注解说起</h2><p>我们都知道，一个Spring Boot主启动类上必须标注@SpringBootApplication注解，点开这个注解我们可以看到这是一个组合注解，其中关键的注解有@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan这3个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点开@SpringBootConfiguration，可以看到它被@Configuration标注，这表明了我们的启动类同时也是一个配置类，这一点需要注意，因为Spring Boot整个启动流程可以说都是围绕着我们的主启动类进行的。</p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Import注解的作用是将目标类作为Bean添加到IOC容器，通常用于将多个分散的配置类融合成一个更大的配置类。@Import支持导入<strong>普通类</strong>、<strong>配置类</strong>、<strong>ImportSelector 的实现类</strong>以及<strong>ImportBeanDefinitionRegistrar 的实现类</strong>。</p>
<h4 id="AutoConfigurationImportSelector的作用"><a href="#AutoConfigurationImportSelector的作用" class="headerlink" title="AutoConfigurationImportSelector的作用"></a>AutoConfigurationImportSelector的作用</h4><p><img src="http://storage.laixiaoming.space/blog/AutoConfigurationImportSelector.jpg" alt="AutoConfigurationImportSelector"></p>
<p>AutoConfigurationImportSelector是DeferredImportSelector的实现类，而DeferredImportSelector继承了ImportSelector，而ImportSelector#selectImports方法正是用来获取需要实际导入到IOC容器的类名数组的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,</span><br><span class="line">                                                                              annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，在selectImports方法中，获取类名数组的关键方法就在于getAutoConfigurationEntry方法</p>
<h5 id="AutoConfigurationImportSelector-getAutoConfigurationEntry"><a href="#AutoConfigurationImportSelector-getAutoConfigurationEntry" class="headerlink" title="AutoConfigurationImportSelector#getAutoConfigurationEntry"></a>AutoConfigurationImportSelector#getAutoConfigurationEntry</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">			AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//获取候选的自动配置类</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到getCandidateConfigurations方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">                                                                         getBeanClassLoader());</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面调用了SpringFactoriesLoader的loadFactoryNames方法，并传入了<strong>EnableAutoConfiguration.class</strong>这样一个参数，继续深入可以发现在里面又调用了loadSpringFactories方法：</p>
<h5 id="SpringFactoriesLoader-loadFactoryNames"><a href="#SpringFactoriesLoader-loadFactoryNames" class="headerlink" title="SpringFactoriesLoader#loadFactoryNames"></a>SpringFactoriesLoader#loadFactoryNames</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">					classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">					ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">    URL url = urls.nextElement();</span><br><span class="line">    UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">    Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">        String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">        <span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">            result.add(factoryClassName, factoryName.trim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>通过代码可以看出，loadSpringFactories方法做的事情就是：</p>
<ol>
<li>扫描所有jar包路径下<strong>META-INF/spring.factories</strong>文件；</li>
<li>以Properties的形式加载加载该文件，将将其收集到Map返回；</li>
</ol>
<p>回到loadFactoryNames方法，在前面拿到了<strong>META-INF/spring.factories</strong>的Map内容后，会取出<strong>EnableAutoConfiguration.class</strong>对应的值，随后便将其添加到容器中。</p>
<p>那么<strong>META-INF/spring.factories</strong>都有着什么内容呢</p>
<h5 id="META-INF-spring-factories文件"><a href="#META-INF-spring-factories文件" class="headerlink" title="META-INF/spring.factories文件"></a><code>META-INF/spring.factories</code>文件</h5><p>这个文件可以在<strong>spring-boot-autoconfiguration</strong>包下找到，我在其中截取了部分<strong>EnableAutoConfiguration.class</strong>内容，不难看到，这些都是我们在日常开发中常见的配置类，这其实也解释了，为什么即便我们在项目中没有显示添加任何配置，而只要我们添加了对应的starter依赖，Spring Boot便会帮助我们创建对应的Bean：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>



<h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是@Import注解，点进AutoConfigurationPackages.Registrar可以发现其手动注册了一个<strong>BasePackages.class</strong>的Bean，并把主启动类的成员设置到<strong>BasePackages</strong>对象成员里；</p>
<p>那这样做有什么用呢？其实AutoConfigurationPackages类上的注释已经告诉了我们答案，它是设计来给其他模块或组件用的，相当于提供给了其他模块或组件获取根包的一个入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class <span class="keyword">for</span> storing auto-<span class="function">configuration packages <span class="keyword">for</span> reference <span class="title">later</span> <span class="params">(e.g. by JPA entity</span></span></span><br><span class="line"><span class="function"><span class="params">scanner)</span></span></span><br></pre></td></tr></table></figure>



<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>开启组件扫描，可以指定扫描路径，在不指定的情况下，会扫描当前配置类所在包及子包的所有组件，这也解释了，为什么我们在使用Spring Boot的时候，启动类要放在最外层。</p>
<p>到这里，不知道读者是否会有疑问，启动类被@Configuration修饰，它既然也是一个配置类，那么它是什么时候被注册到IOC容器的呢？</p>
<p>通过dubug启动过程，其实不难发现是在SpringApplication#prepareContext方法进行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//获取主启动类位置</span></span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line"><span class="comment">//加载</span></span><br><span class="line">load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Spring Boot通过 AutoConfigurationImportSelector，并扫描所有jar包目录中<strong>META-INF/spring.factories</strong>配置文件，并加载<code>org.springframework.boot.autoconfigure.EnableutoConfiguration</code>配置项中对应的自动配置类，这也是自动配置生效的原理；</li>
<li>主启动类也是一个配置类，而**@ComponentScan**会默认扫描当前配置类所在包及子包的所有组件；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务 -两阶段提交及Atomikos在Spring Boot的使用</title>
    <url>/2023/05/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20-%20%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8F%8AAtomikos%E5%9C%A8Spring%20Boot%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="基于XA规范的两阶段提交方式"><a href="#基于XA规范的两阶段提交方式" class="headerlink" title="基于XA规范的两阶段提交方式"></a>基于XA规范的两阶段提交方式</h2><p>事务在业务的开发中有着至关重要的作用，事务具有的ACID的特性能保证业务处理前后数据的一致性：<br><strong>原子性（Atomicity）：</strong> 事务执行的所有操作，要么全部执行，要么全部不执行；<br><strong>一致性（Consistency）：</strong> 事务的执行前后，数据的完整性保持一致；<br><strong>隔离性（Isolation）：</strong> 两个或多个事务并行执行时是互不干扰的；<br><strong>持久性（Durability）：</strong> 事务执行完成后，其对数据库数据的更改会被永久保存下来；<br>在单机环境下，数据库系统对事务的支持是比较完善的；但当对数据进行水平或垂直拆分，一个数据库节点变为多个数据库节点时，分布式事务就出现了。</p>
<span id="more"></span>

<h3 id="XA规范"><a href="#XA规范" class="headerlink" title="XA规范"></a>XA规范</h3><p>XA是X/Open组织提出的一个分布式事务的规范，其定义了一个分布式事务的处理模型——DTP。在DTP中定义了三个组件：<br>Application Program（AP）：应用程序，即业务层，它定义了事务的边界，以及构成该事务的特定操作；<br>Resource Manager（RM）：资源管理器，可以理解为一个DBMS系统，或者消息服务器管理系统；<br>Transaction Manager（TM）：事务管理器，也称为协调者，负责协调和管理事务；</p>
<p>AP与RM之间，AP通过RM提供的API进行交互，当需要进行分布式事务时，则向TM发起一个全局事务，TM与RM之间则通过XA接口进行交互，TM管理了到RM的链接，并实现了两阶段提交。</p>
<h3 id="两阶段提交流程（2PC）"><a href="#两阶段提交流程（2PC）" class="headerlink" title="两阶段提交流程（2PC）"></a>两阶段提交流程（2PC）</h3><p>XA规范中，多个RM状态之间的协调通过TM进行，而这个资源协调的过程采用了两阶段提交协议（2PC），2PC实际上是一种在多节点之间实现事务原子提交的算法，它用来确保所有节点要么全部提交，要么全部中止。</p>
<p>在2PC中，分为准备阶段和提交阶段：<br>第一阶段：发送一个准备请求到所有参与者节点，询问他们是否可以提交；</p>
<p>第二阶段：如果所有参与者节点回答“是”，则表示他们已准备好提交，那么协调者将在阶段2发出提交请求；</p>
<p><img src="http://storage.laixiaoming.space/blog/1p.jpg" alt="1p"></p>
<p><img src="http://storage.laixiaoming.space/blog/2p.jpg" alt="2p"></p>
<p>如果在准备阶段，有一个RM返回失败时，则在第二个阶段将回滚所有资源</p>
<p><img src="http://storage.laixiaoming.space/blog/1pc-error.jpg" alt="1pc-error"></p>
<p><img src="http://storage.laixiaoming.space/blog/2pc-error.jpg" alt="2pc-error"></p>
<h3 id="2PC的局限性"><a href="#2PC的局限性" class="headerlink" title="2PC的局限性"></a>2PC的局限性</h3><p>2PC能基本满足了事务的 ACID 特性，但也存在着明显的缺点：</p>
<ul>
<li>在事务的执行过程中，所有的参与节点都是阻塞型的，在并发量高的系统中，性能受限严重；</li>
<li>如果TM在commit前发生故障，那么所有参与节点会因为无法提交事务而处于长时间锁定资源的状态；</li>
<li>在实际情况中，由于分布式环境下的复杂性，TM在发送commit请求后，可能因为局部网络原因，导致只有部分参与者收到commit请求时，系统便出现了数据不一致的现象；</li>
<li>XA协议要求所有参与者需要与TM进行直接交互，但在微服务架构下，一个服务与多个RM直接关联常常是被不允许的；</li>
</ul>
<h2 id="Atomikos在Spring-Boot的使用"><a href="#Atomikos在Spring-Boot的使用" class="headerlink" title="Atomikos在Spring Boot的使用"></a>Atomikos在Spring Boot的使用</h2><p>Atomikos在XA中作为一个事务管理器（TM）存在。在Spring Boot应用中，可以通过Atomikos在应用中方便的引入分布式事务。<br>下面以一个简单的订单创建流程的为例：</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jta-atomikos&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.11&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.22&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><p>application.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">      order-db:</span><br><span class="line">        name: order-db</span><br><span class="line">        url: jdbc:mysql:&#x2F;&#x2F;localhost:3307&#x2F;order?useSSL&#x3D;false&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: mysql</span><br><span class="line">      product-db:</span><br><span class="line">        name: order-db</span><br><span class="line">        url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;product?useSSL&#x3D;false&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: mysql</span><br><span class="line">  jta:</span><br><span class="line">    transaction-manager-id: order-product-tx-manager</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; &quot;gdou.laixiaoming.atomikos.demo.mapper.order&quot;, sqlSessionFactoryRef &#x3D; &quot;orderSqlSessionFactory&quot;)</span><br><span class="line">public class OrderDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;druidOrderDataSource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.druid.order-db&quot;)</span><br><span class="line">    public DruidXADataSource druidOrderDataSource()&#123;</span><br><span class="line">        DruidXADataSource xaDataSource &#x3D; new DruidXADataSource();</span><br><span class="line">        return xaDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;orderDataSource&quot;)</span><br><span class="line">    public DataSource orderDataSource(</span><br><span class="line">            @Qualifier(&quot;druidOrderDataSource&quot;) DruidXADataSource druidOrderDataSource) &#123;</span><br><span class="line">        AtomikosDataSourceBean ds &#x3D; new AtomikosDataSourceBean();</span><br><span class="line">        ds.setXaDataSource(druidOrderDataSource);</span><br><span class="line">        ds.setXaDataSourceClassName(&quot;com.alibaba.druid.pool.xa.DruidXADataSource&quot;);</span><br><span class="line">        ds.setUniqueResourceName(&quot;orderDataSource&quot;);</span><br><span class="line">        return ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactory orderSqlSessionFactory(</span><br><span class="line">            @Qualifier(&quot;orderDataSource&quot;) DataSource orderDataSource) throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(orderDataSource);</span><br><span class="line">        return sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; &quot;gdou.laixiaoming.atomikos.demo.mapper.product&quot;, sqlSessionFactoryRef &#x3D; &quot;productSqlSessionFactory&quot;)</span><br><span class="line">public class ProductDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;druidProductDataSource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.druid.product-db&quot;)</span><br><span class="line">    public DruidXADataSource druidProductDataSource()&#123;</span><br><span class="line">        DruidXADataSource xaDataSource &#x3D; new DruidXADataSource();</span><br><span class="line">        return xaDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;productDataSource&quot;)</span><br><span class="line">    public DataSource productDataSource(</span><br><span class="line">            @Qualifier(&quot;druidProductDataSource&quot;) DruidXADataSource druidProductDataSource) &#123;</span><br><span class="line">        AtomikosDataSourceBean ds &#x3D; new AtomikosDataSourceBean();</span><br><span class="line">        ds.setXaDataSource(druidProductDataSource);</span><br><span class="line">        ds.setXaDataSourceClassName(&quot;com.alibaba.druid.pool.xa.DruidXADataSource&quot;);</span><br><span class="line">        ds.setUniqueResourceName(&quot;productDataSource&quot;);</span><br><span class="line">        return ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactory productSqlSessionFactory(</span><br><span class="line">            @Qualifier(&quot;productDataSource&quot;) DataSource productDataSource) throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(productDataSource);</span><br><span class="line">        return sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="构建商品服务"><a href="#构建商品服务" class="headerlink" title="构建商品服务"></a>构建商品服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ProductServiceImpl implements ProductService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductMapper productMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void updateInventory(Long productId) &#123;</span><br><span class="line">    	&#x2F;&#x2F;模拟异常流程</span><br><span class="line">        if(productId &#x3D;&#x3D; 2)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;更新库存失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        productMapper.updateInventory(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建订单服务"><a href="#构建订单服务" class="headerlink" title="构建订单服务"></a>构建订单服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderMapper orderMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor &#x3D; RuntimeException.class)</span><br><span class="line">    @Override</span><br><span class="line">    public void order(Long productId) &#123;</span><br><span class="line">        orderMapper.addOrder(productId);</span><br><span class="line">        productService.updateInventory(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class ServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testCommit() &#123;</span><br><span class="line">        orderService.order(1L);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testRollback() &#123;</span><br><span class="line">        orderService.order(2L);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过运行测试用例，我们可以发现testCommit()方法在订单库以及商品库的成功完成的修改；而testRollback()方法则因为商品服务异常进行了回滚，回滚后的订单库和商品库数据都恢复到了事务开启前的状态。</p>
<p>参考：<br>《大型网站系统与Java中间件实践》<br><a href="https://www.jianshu.com/p/f9bac5822d30">SpringBoot Atomikos 多数据源分布式事务</a></p>
]]></content>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务-基于可靠消息的最终一致性实现</title>
    <url>/2023/05/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20-%20%E5%9F%BA%E4%BA%8E%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="CAP与BASE"><a href="#CAP与BASE" class="headerlink" title="CAP与BASE"></a>CAP与BASE</h2><p>我们都知道，传统数据库事务具有ACID的特性，但在分布式环境下，追求强一致性在大多数情况下无法满足高性能需求。<br>分布式系统的CAP理论告诉我们，一致性、可用性、分区容忍性无法同时满足，最多只能满足其他两项。CAP理论描述如下：</p>
<ul>
<li>一致性（Consistency）：所有节点在同一时间读到同样的数据；</li>
<li>可用性（Availability）：无论是成功还是失败，每个请求都能收到一个反馈。可用性强调的是服务可用，不保证数据的正确性；</li>
<li>分区容忍性（Partition-Tolerance）：即使系统中有部分问题或者有消息的丢失，但系统仍然能够继续运行。分区容忍性强调的是集群对分区故障的容错能力；</li>
</ul>
<span id="more"></span>

<p>对于分布式系统而言，分区故障无法避免，因而分区容忍性在一个分布式系统中是必须要考虑的，这也意味着，设计一个分布式系统，我们只能在CAP中的C、A中作出选择，而BASE就是在C和A的选择中作出的一种权衡。<br>BASE可以说是AP系统的一种延伸，其描述如下：</p>
<ul>
<li>基本可用（Basically Available）：基本可用，允许分区失败；</li>
<li>软状态（Soft state）：软状态，一种中间状态，接受一段时间的状态不同步；</li>
<li>最终一致（Eventually consistent）：最终一致，系统在短暂时间内可能是不一致的，但能够保证最终的数据是一致的；<br>BASE通过牺牲了强一致性来获取高可用性，允许数据存在短暂的不一致，到这里其实我们可以发现，ACID强调的是数据一致性，而BASE强调的则是服务可用；</li>
</ul>
<h2 id="基于可靠消息的最终一致性"><a href="#基于可靠消息的最终一致性" class="headerlink" title="基于可靠消息的最终一致性"></a>基于可靠消息的最终一致性</h2><p>基于可靠消息实现的分布式事务遵循了BASE理论，它通过引入消息中间件，在基于可靠消息的前提下，协商多个节点异步完成整个分布式事务，如果某一步骤出现失败时，则进行一定次数的重试，必要情况下需要人工介入处理。<br>以下单为例，用户下单后，会给用户增加一定的积分，在这个流程中涉及了订单服务以及积分服务，如下图所示：</p>
<p><img src="http://storage.laixiaoming.space/blog/add-order.jpg" alt="add-order"></p>
<p>但这个流程其实存在3个问题：</p>
<ol>
<li>如果在订单服务的订单创建事务（1.2）执行成功了，在发送订单创建消息（1.3）后，由于网络不可达等因素，订单服务无法收到来自消息中间件的响应时，订单服务的本地事务是应该继续提交还是回滚呢；</li>
<li>如果订单创建消息发送成功，得到了消息中间件的正确响应，但订单服务的本地事务却提交失败了，但消息却已经投递出去了，这种情况又应该怎么处理呢；</li>
<li>订单创建消息已经成功投递到下游应用（积分服务），但积分服务的本地事务却执行失败了，又应该怎么处理呢<br>以上第1和第2个问题，其实可以归结于同一个问题，即如何保证消息发送的一致性，而第3个问题，即是如何确保消息一定能够消息成功；</li>
</ol>
<h3 id="如何保证消息发送的一致性"><a href="#如何保证消息发送的一致性" class="headerlink" title="如何保证消息发送的一致性"></a>如何保证消息发送的一致性</h3><p>我们可以采用两阶段提交的方式，但并不是所有的消息中间件都支持XA，况且，出现问题的概率不大，为此引入了两阶段提交，性能方面就需要有所妥协，这样的方案实现是否有点得不偿失？<br>这个问题其实RocketMQ有了实现方案，RocketMQ支持事务消息，其通过引入了“半消息”的概念（半消息对下游系统不可见），保证了本地事务执行与消息发送的一致性。其发送的正向流程如下：</p>
<ol>
<li>业务系统发送“半消息”；</li>
<li>消息中间件将“半消息”进行持久化；</li>
<li>业务系统得到消息发送结果，成功的话则执行本地事务，失败则结束流程；</li>
<li>本地事务执行，并将业务操作结果发送给消息中间件；</li>
<li>消息中间件根据业务系统的事务执行结果，选择将消息投放或者删除；</li>
</ol>
<p>但实际上仅凭以上这个流程其实还是没有办法保证消息发送的一致性的，比如<br>(1) 在业务系统接收消息中间件对“半消息”的处理结果时，由于网络、或者业务系统和消息中间件自身故障时，业务系统无法得知消息中间件的处理结果时，就会按照消息发送失败来处理，这个时候，就有可能存在，’本地事务未执行，但“半消息”却发送成功的不一致情况’；<br>(2) 本地事务执行后，将业务操作结果返回到消息中间件时，如果出现问题，那么消息中间件将不知道如何处理已经存在的“半消息”；<br>为应对以上两种不一致情况，RocketMQ在消息中间件一方引入了“事务回查”的反向流程，其执行流程如下：</p>
<ol>
<li>对于超过一定时长未处理的“半消息”，消息中间件将会回调业务系统询问本地事务的处理结果；</li>
<li>业务系统在检查事务操作结果，将结果返回给消息中间件；</li>
<li>消息中间件根据业务系统的事务执行结果，选择将消息投放或者删除；</li>
</ol>
<p>发送消息的正向流程和反向流程结合起来，就是解决消息发送一致性的整个方案。</p>
<p>以上面的下单流程为例，在引入了RocketMQ事务消息后，基本流程可以表示为：</p>
<p><img src="http://storage.laixiaoming.space/blog/add-order-rocketmq.jpg" alt="add-order-rocketmq"></p>
<h3 id="如何保证消息一定会被消费"><a href="#如何保证消息一定会被消费" class="headerlink" title="如何保证消息一定会被消费"></a>如何保证消息一定会被消费</h3><p>确保消息一定能够被消息的流程比较简单，我们只需要保证消息的持久化，并引入消息确认机制，只有在消息被明确消费完成后，将确认消息返回到消息中间时，消息才能够被丢弃，否则则进行一定次数的重试，需要注意的是，引入重试操作后，消费方的操作需要保证幂等性。</p>
<h2 id="RocketMQ整合实例"><a href="#RocketMQ整合实例" class="headerlink" title="RocketMQ整合实例"></a>RocketMQ整合实例</h2><p>该例子基于Spring Boot构建：</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.rocketmq&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.1.0&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="applition-yml配置"><a href="#applition-yml配置" class="headerlink" title="applition.yml配置"></a>applition.yml配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rocketmq:</span><br><span class="line">  name-server: localhost:9876</span><br><span class="line">  producer:</span><br><span class="line">    group: default-group</span><br><span class="line">    sendMessageTimeout: 5000</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  rocketmq:</span><br><span class="line">    orderTopic: order-paid-topic</span><br></pre></td></tr></table></figure>

<h3 id="构建订单服务"><a href="#构建订单服务" class="headerlink" title="构建订单服务"></a>构建订单服务</h3><h4 id="发送半消息"><a href="#发送半消息" class="headerlink" title="发送半消息"></a>发送半消息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;demo.rocketmq.orderTopic&#125;&quot;)</span><br><span class="line">    private String orderTopic;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addOrder() &#123;</span><br><span class="line">        int orderId &#x3D; new Random().nextInt(3) + 1;</span><br><span class="line">        Message message &#x3D; MessageBuilder.withPayload(orderId).build();</span><br><span class="line">        log.info(&quot;发送半消息, orderId &#x3D; &#123;&#125;&quot;, orderId);</span><br><span class="line">        rocketMQTemplate.sendMessageInTransaction(orderTopic, message, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="本地事务执行回调与事务状态回查"><a href="#本地事务执行回调与事务状态回查" class="headerlink" title="本地事务执行回调与事务状态回查"></a>本地事务执行回调与事务状态回查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RocketMQTransactionListener</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderTransactionListener implements RocketMQLocalTransactionListener &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;</span><br><span class="line">        &#x2F;&#x2F;执行本地事务</span><br><span class="line">        Integer orderId &#x3D; Integer.valueOf(new String((byte[])msg.getPayload()));</span><br><span class="line">        int status &#x3D; new Random().nextInt(3);</span><br><span class="line">        if (status &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            log.info(&quot;提交事务消息, orderId &#x3D; &#123;&#125;&quot;, orderId);</span><br><span class="line">            return RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (status &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            log.info(&quot;回滚事务消息, orderId &#x3D; &#123;&#125;&quot;, orderId);</span><br><span class="line">            return RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(&quot;事务消息中间状态, MQ需要回查事务状态&quot;);</span><br><span class="line">        return RocketMQLocalTransactionState.UNKNOWN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RocketMQLocalTransactionState checkLocalTransaction(Message msg) &#123;</span><br><span class="line">        Integer orderId &#x3D; Integer.valueOf(new String((byte[])msg.getPayload()));</span><br><span class="line">        RocketMQLocalTransactionState retState;</span><br><span class="line">        int status &#x3D; new Random().nextInt(3);</span><br><span class="line">        switch (status) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                retState &#x3D; RocketMQLocalTransactionState.UNKNOWN;</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                retState &#x3D; RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">            default:</span><br><span class="line">                retState &#x3D; RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;回查事务状态, orderId &#x3D; &#123;&#125;, status &#x3D; &#123;&#125;, retState &#x3D; &#123;&#125;&quot;,</span><br><span class="line">                orderId, status, retState);</span><br><span class="line">        return retState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建积分服务"><a href="#构建积分服务" class="headerlink" title="构建积分服务"></a>构建积分服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@RocketMQMessageListener(topic &#x3D; &quot;$&#123;demo.rocketmq.orderTopic&#125;&quot;, consumerGroup &#x3D; &quot;order_paid_consumer_default_group&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderPaidConsumer implements RocketMQListener&lt;MessageExt&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(MessageExt message) &#123;</span><br><span class="line">        Integer orderId &#x3D; Integer.valueOf(new String((byte[])message.getBody()));</span><br><span class="line">        log.info(&quot;orderId &#x3D; &#123;&#125;, 增加积分&quot;, orderId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<br>《大型网站系统与Java中间件实践》</p>
]]></content>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：@Configuration类的解析</title>
    <url>/2023/05/04/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A@Configuration%E7%B1%BB%E7%9A%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用@Configuration注解可以为一个类声明为配置类，一个配置类声明了一个或多个@Bean方法，这些方法返回值将作为bean定义注册到Spring IoC容器中，并允许在配置类中通过调用同一类中的其他@Bean方法来定义bean之间的依赖关系。</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<h2 id="Configuration类解析流程"><a href="#Configuration类解析流程" class="headerlink" title="@Configuration类解析流程"></a>@Configuration类解析流程</h2><p>Spring Boot是如何解析@Configuration配置类的呢？要弄懂这个过程，首先我们需要先了解一个BeanFactoryPostProcessor的概念。</p>
<h3 id="BeanFactoryPostProcessor是什么"><a href="#BeanFactoryPostProcessor是什么" class="headerlink" title="BeanFactoryPostProcessor是什么"></a>BeanFactoryPostProcessor是什么</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Modify the application context&#x27;s internal bean factory after its standard</span></span><br><span class="line"><span class="comment">	 * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment">	 * will have been instantiated yet. This allows for overriding or adding</span></span><br><span class="line"><span class="comment">	 * properties even to eager-initializing beans.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>BeanFactoryPostProcessor是Spring 提供的一个接口，从代码注释中我们可以了解到，我们可以利用BeanFactoryPostProcessor实现对内部bean工厂进行修改，允许我们通过它完成bean定义或者属性的修改，另外需要注意的一点是，BeanFactoryPostProcessor的执行时机是在BeanFactory标准初始化后，并且是在Bean实例化之前。</p>
<p>而@Configuration配置类的解析正是由BeanFactoryPostProcessor的实现类<strong>ConfigurationClassPostProcessor</strong>处理的：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20220511233922833.png" alt="image-20220511233922833"></p>
<p>由ConfigurationClassPostProcessor的类继承关系图，我们可以发现ConfigurationClassPostProcessor并不直接实现BeanFactoryPostProcessor接口，而是实现了BeanFactoryPostProcessor的子接口BeanDefinitionRegistryPostProcessor，那么BeanDefinitionRegistryPostProcessor是什么呢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Modify the application context&#x27;s internal bean definition registry after its</span></span><br><span class="line"><span class="comment">	 * standard initialization. All regular bean definitions will have been loaded,</span></span><br><span class="line"><span class="comment">	 * but no beans will have been instantiated yet. This allows for adding further</span></span><br><span class="line"><span class="comment">	 * bean definitions before the next post-processing phase kicks in.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry the bean definition registry used by the application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor，它额外定义了一个方法，通过这个方法参数BeanDefinitionRegistry我们可以看出，它与BeanFactoryPostProcessor的区别在于，我们可以通过这个方法新增Bean定义，另外，它的执行时机是在BeanFactoryPostProcessor之前。</p>
<p>回到ConfigurationClassPostProcessor，这个BeanDefinitionRegistryPostProcessor的实现类到底做了哪些事情呢，我们一起来看下它的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConfigurationClassPostProcessor#processConfigBeanDefinitions：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充配置类的full或lite属性</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">        BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">            configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类解析器</span></span><br><span class="line">    ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">        <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//解析配置类（处理@ComponentScan，@Import，@Bean方法等注解），但这里实际上只会把@ComponentScan注解扫描的类注册为BeanDefinition</span></span><br><span class="line">        parser.parse(candidates);</span><br><span class="line">        parser.validate();</span><br><span class="line"></span><br><span class="line">        Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">        configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">                registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">                <span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里会解析上一步parse操作中获取到的ConfigurationClass，比如由@Import生成的配置类、或标注了@Bean注解的方法等注册为BeanDefinition</span></span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">        alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">        candidates.clear();</span><br><span class="line">        <span class="comment">//判断经过loadBeanDefinitions处理后，是否有新增配置类，有则继续解析</span></span><br><span class="line">        <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">            String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">            Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">            Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">                    BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">                    <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                        !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                        candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            candidateNames = newCandidateNames;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="full和lite的区别"><a href="#full和lite的区别" class="headerlink" title="full和lite的区别"></a>full和lite的区别</h3><p>ConfigurationClassUtils#checkConfigurationClassCandidate：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkConfigurationClassCandidate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    <span class="keyword">if</span> (isFullConfigurationCandidate(metadata)) &#123;</span><br><span class="line">        beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isLiteConfigurationCandidate(metadata)) &#123;</span><br><span class="line">        beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It&#x27;s a full or lite configuration candidate... Let&#x27;s determine the order value, if any.</span></span><br><span class="line">    Integer order = getOrder(metadata);</span><br><span class="line">    <span class="keyword">if</span> (order != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanDef.setAttribute(ORDER_ATTRIBUTE, order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConfigurationClassUtils#isFullConfigurationCandidate：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFullConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> metadata.isAnnotated(Configuration.class.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConfigurationClassUtils#isLiteConfigurationCandidate：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; candidateIndicators = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    candidateIndicators.add(Component.class.getName());</span><br><span class="line">    candidateIndicators.add(ComponentScan.class.getName());</span><br><span class="line">    candidateIndicators.add(Import.class.getName());</span><br><span class="line">    candidateIndicators.add(ImportResource.class.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLiteConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do not consider an interface or an annotation...</span></span><br><span class="line">    <span class="keyword">if</span> (metadata.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Any of the typical annotations found?</span></span><br><span class="line">    <span class="keyword">for</span> (String indicator : candidateIndicators) &#123;</span><br><span class="line">        <span class="keyword">if</span> (metadata.isAnnotated(indicator)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, let&#x27;s look for @Bean methods...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> metadata.hasAnnotatedMethods(Bean.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Failed to introspect @Bean methods on class [&quot;</span> + metadata.getClassName() + <span class="string">&quot;]: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以知道：</p>
<p><strong>full：</strong>@Configuration标注的类；</p>
<p><strong>lite：</strong>@Component、@ComponentScan、@Import、@ImportResource或者存在@Bean方法的类；</p>
<p>那么问题来了，区分full和lite有什么作用呢？</p>
<p>通过查找ConfigurationClassUtils#isFullConfigurationClass的调用位置，我们可以定位到ConfigurationClassPostProcessor#enhanceConfigurationClasses：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">			BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">            <span class="comment">//判断是否full配置类</span></span><br><span class="line">			<span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;</span><br><span class="line">				<span class="comment">//省略...</span></span><br><span class="line">				configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">		ConfigurationClassEnhancer enhancer = <span class="keyword">new</span> ConfigurationClassEnhancer();</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">			AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line">			<span class="comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">			beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">				Class&lt;?&gt; configClass = beanDef.resolveBeanClass(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">				<span class="keyword">if</span> (configClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//对full配置类进行增强</span></span><br><span class="line">					Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">					<span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">						<span class="comment">//省略...</span></span><br><span class="line">						beanDef.setBeanClass(enhancedClass);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="comment">//省略...</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Boot会对full配置类进行增强，那么为什么要对其进行增加呢？想必大家都看到过以下这种用法，这实际上就是为了支持@Bean方法能够在同一配置类相互调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B(a());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="parser-pase"><a href="#parser-pase" class="headerlink" title="parser.pase()"></a>parser.pase()</h3><p>通过查看其调用链路，定位到具体处理解析代码processConfigurationClass：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">ConfigurationClassParser#parse(java.util.Set&lt;org.springframework.beans.factory.config.BeanDefinitionHolder&gt;)</span><br><span class="line">-&gt;</span><br><span class="line">ConfigurationClassParse#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String)</span><br><span class="line">-&gt;</span><br><span class="line">ConfigurationClassParser#processConfigurationClass</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//省略...</span></span><br><span class="line">		<span class="comment">//递归处理配置类及其父类</span></span><br><span class="line">		SourceClass sourceClass = asSourceClass(configClass);</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>来到doProcessConfigurationClass：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">        <span class="comment">// 处理内部类，如果内部类也是一个配置类，将会递归去解析</span></span><br><span class="line">        processMemberClasses(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理@PropertySource注解</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">        org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">            processPropertySource(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//省略...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@ComponentScan注解，扫描指定包下的所有.class，这里也是一个递归解析的过程</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">        !<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">            <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                <span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">            <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                <span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bdCand = holder.getBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@Import注解</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@ImportResource注解</span></span><br><span class="line">    AnnotationAttributes importResource =</span><br><span class="line">        AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">    <span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">        Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">            String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">            configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@Bean方法</span></span><br><span class="line">    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">        configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理接口默认方法</span></span><br><span class="line">    processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取父类并返回，用以递归解析</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">        String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">            !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">            <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="this-reader-loadBeanDefinitions"><a href="#this-reader-loadBeanDefinitions" class="headerlink" title="this.reader.loadBeanDefinitions()"></a>this.reader.loadBeanDefinitions()</h3><p>定位到具体处理逻辑，ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForConfigurationClass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">        <span class="comment">//对于被导入的类，将其注册为BeanDefinition</span></span><br><span class="line">        registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">        <span class="comment">//将@Bean方法，注册为BeanDefinition</span></span><br><span class="line">        loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@ImportResource</span></span><br><span class="line">    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">    <span class="comment">//处理@Import注解中，导入的是ImportBeanDefinitionRegistrar接口实现类，调用其registerBeanDefinitions方法</span></span><br><span class="line">    loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>我们可以通过实现BeanFactoryPostProcessor对bean进行定义或修改，而Spring Boot是也是通过其实现类ConfigurationClassPostProcessor进行配置类的解析；</li>
<li>配置类分为full和lite，区别为前者会被增强处理；</li>
<li>我们常用的@ComponentScan包扫描，@Import注解，@Bean注解方法等也都是通过ConfigurationClassPostProcessor处理的；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：@Autowired的解析</title>
    <url>/2023/05/18/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A@Autowired%E7%9A%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>@Autowired是开发中常用的注解，我们可以使用@Autowired将其标记在构造函数、成员变量、setter方法上，并由Spring自动完成依赖注入的工作。但是，这个过程是怎么完成的呢？</p>
<span id="more"></span>

<p>理解这个之前，我们需要先了解一下<strong>BeanPostProcessor</strong>概念。</p>
<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<h3 id="BeanPostProcessor是什么"><a href="#BeanPostProcessor是什么" class="headerlink" title="BeanPostProcessor是什么"></a>BeanPostProcessor是什么</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory hook that allows for custom modification of new bean instances,</span></span><br><span class="line"><span class="comment"> * e.g. checking for marker interfaces or wrapping them with proxies.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;ApplicationContexts can autodetect BeanPostProcessor beans in their</span></span><br><span class="line"><span class="comment"> * bean definitions and apply them to any beans subsequently created.</span></span><br><span class="line"><span class="comment"> * Plain bean factories allow for programmatic registration of post-processors,</span></span><br><span class="line"><span class="comment"> * applying to all beans created through this factory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Typically, post-processors that populate beans via marker interfaces</span></span><br><span class="line"><span class="comment"> * or the like will implement &#123;<span class="doctag">@link</span> #postProcessBeforeInitialization&#125;,</span></span><br><span class="line"><span class="comment"> * while post-processors that wrap beans with proxies will normally</span></span><br><span class="line"><span class="comment"> * implement &#123;<span class="doctag">@link</span> #postProcessAfterInitialization&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由注释我们可以看到，我们可以通过<strong>BeanPostProcessor</strong>修改bean的实例，例如检查bean的接口或将将bean包装为代理对象。接口中提供了两个方法，通常情况下，<strong>postProcessBeforeInitialization</strong>被用于填充bean的属性，而<strong>postProcessAfterInitialization</strong>用于返回bean的代理对象，另外需要注意的是，如果该方法返回了null，则表示后续的BeanPostProcessors不会再被调用。</p>
<p>了解<strong>BeanPostProcessor</strong>，我们不禁猜测，@Autowire注解会不会也是由<strong>BeanPostProcessor</strong>解析和注入的呢，没错，它正是由<strong>BeanPostProcessor</strong>的实现类<strong>AutowiredAnnotationBeanPostProcessor</strong>处理的。</p>
<h2 id="理解AutowiredAnnotationBeanPostProcessor"><a href="#理解AutowiredAnnotationBeanPostProcessor" class="headerlink" title="理解AutowiredAnnotationBeanPostProcessor"></a>理解AutowiredAnnotationBeanPostProcessor</h2><p><img src="http://storage.laixiaoming.space/blog/AutowiredAnnotationBeanPostProcessor.jpg" alt="AutowiredAnnotationBeanPostProcessor"></p>
<p>但查看<strong>AutowiredAnnotationBeanPostProcessor</strong>的类继承关系图我们会发现，<strong>AutowiredAnnotationBeanPostProcessor</strong></p>
<p>并不是直接实现<strong>BeanPostProcessor</strong>，而是实现自<strong>BeanPostProcessor</strong>的子接口，<strong>MergedBeanDefinitionPostProcessor</strong>和<strong>SmartInstantiationAwareBeanPostProcessor</strong>。</p>
<p>回到<strong>AutowiredAnnotationBeanPostProcessor</strong>的源码，我们看到它主要有实现了几个关键的方法：determineCandidateConstructors、postProcessMergedBeanDefinition、postProcessProperties，我们逐个看。</p>
<h3 id="determineCandidateConstructors"><a href="#determineCandidateConstructors" class="headerlink" title="determineCandidateConstructors"></a>determineCandidateConstructors</h3><p>这个方法是<strong>SmartInstantiationAwareBeanPostProcessor</strong>接口中定义的，从方法注释我们可以知道，该方法用于确定给定bean的构造函数，这里我们不展开细说。</p>
<h3 id="postProcessMergedBeanDefinition"><a href="#postProcessMergedBeanDefinition" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h3><p>这个方法是<strong>MergedBeanDefinitionPostProcessor</strong>接口中定义的，查看其实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">    InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">    metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="findAutowiringMetadata"><a href="#findAutowiringMetadata" class="headerlink" title="findAutowiringMetadata"></a>findAutowiringMetadata</h4><p>该方法作用是构建Autowired的元数据，深入发现，其核心是调用了org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    List&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Class&lt;?&gt; targetClass = clazz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;InjectionMetadata.InjectedElement&gt; currElements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="comment">//解析类所有属性字段，将其封装为AutowiredFieldElement</span></span><br><span class="line">        ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">            <span class="comment">//解析该字段上的@Autowired注解，查看该方法可以发现，该处理器不仅解析了@Autowired注解，还有@Value及@Inject注解</span></span><br><span class="line">            AnnotationAttributes ann = findAutowiredAnnotation(field);</span><br><span class="line">            <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//忽略static字段</span></span><br><span class="line">                <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;Autowired annotation is not supported on static fields: &quot;</span> + field);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析类方法，将其封装为AutowiredMethodElement</span></span><br><span class="line">        ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">            Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">            <span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//解析该方法上的@Autowire注解</span></span><br><span class="line">            AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">            <span class="keyword">if</span> (ann != <span class="keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">                <span class="comment">//忽略静态方法</span></span><br><span class="line">                <span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;Autowired annotation is not supported on static methods: &quot;</span> + method);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//忽略无参方法</span></span><br><span class="line">                <span class="keyword">if</span> (method.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;Autowired annotation should only be used on methods with parameters: &quot;</span> +</span><br><span class="line">                                    method);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">                currElements.add(<span class="keyword">new</span> AutowiredMethodElement(method, required, pd));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">        targetClass = targetClass.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环解析父类</span></span><br><span class="line">    <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjectionMetadata(clazz, elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，buildAutowiringMetadata主要是收集被@Autowired修饰的字段以及方法。</p>
<h4 id="checkConfigMembers"><a href="#checkConfigMembers" class="headerlink" title="checkConfigMembers"></a>checkConfigMembers</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkConfigMembers</span><span class="params">(RootBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    Set&lt;InjectedElement&gt; checkedElements = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.injectedElements.size());</span><br><span class="line">    <span class="keyword">for</span> (InjectedElement element : <span class="keyword">this</span>.injectedElements) &#123;</span><br><span class="line">        Member member = element.getMember();</span><br><span class="line">        <span class="keyword">if</span> (!beanDefinition.isExternallyManagedConfigMember(member)) &#123;</span><br><span class="line">            beanDefinition.registerExternallyManagedConfigMember(member);</span><br><span class="line">            checkedElements.add(element);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Registered injected element on class [&quot;</span> + <span class="keyword">this</span>.targetClass.getName() + <span class="string">&quot;]: &quot;</span> + element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.checkedElements = checkedElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会缓存已经检验过的注入点，但是这个作用是什么，查看checkConfigMembers的调用位置，发现除了被 用于<strong>AutowiredAnnotationBeanPostProcessor</strong>这个处理器外，还在<strong>CommonAnnotationBeanPostProcessor</strong>中出现，而<strong>CommonAnnotationBeanPostProcessor</strong>是用于解析@Resource注解的，不难看出，这里主要是避免重复注入的问题。</p>
<h3 id="postProcessProperties"><a href="#postProcessProperties" class="headerlink" title="postProcessProperties"></a>postProcessProperties</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line"> 	<span class="comment">//省略...</span></span><br><span class="line">    <span class="comment">//注入</span></span><br><span class="line">    metadata.inject(bean, beanName, pvs);</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Collection&lt;InjectedElement&gt; checkedElements = <span class="keyword">this</span>.checkedElements;</span><br><span class="line">    Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line">        (checkedElements != <span class="keyword">null</span> ? checkedElements : <span class="keyword">this</span>.injectedElements);</span><br><span class="line">    <span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line">            element.inject(target, beanName, pvs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到了前面解析过程得到的@Autowired元数据后，进行值的注入，我们以字段的注入为例，查看其注入流程，来到AutowiredFieldElement#inject方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object bean, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Field field = (Field) <span class="keyword">this</span>.member;</span><br><span class="line">    Object value;</span><br><span class="line">    <span class="comment">//从缓存中读取值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cached) &#123;</span><br><span class="line">        value = resolvedCachedArgument(beanName, <span class="keyword">this</span>.cachedFieldValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        DependencyDescriptor desc = <span class="keyword">new</span> DependencyDescriptor(field, <span class="keyword">this</span>.required);</span><br><span class="line">        desc.setContainingClass(bean.getClass());</span><br><span class="line">        Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        Assert.state(beanFactory != <span class="keyword">null</span>, <span class="string">&quot;No BeanFactory available&quot;</span>);</span><br><span class="line">        TypeConverter typeConverter = beanFactory.getTypeConverter();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从beanFactory中解析依赖的bean</span></span><br><span class="line">            value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(<span class="keyword">null</span>, beanName, <span class="keyword">new</span> InjectionPoint(field), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.cached) &#123;</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span> || <span class="keyword">this</span>.required) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cachedFieldValue = desc;</span><br><span class="line">                    <span class="comment">//注册依赖关系</span></span><br><span class="line">                    registerDependentBeans(beanName, autowiredBeanNames);</span><br><span class="line">                    <span class="keyword">if</span> (autowiredBeanNames.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                        String autowiredBeanName = autowiredBeanNames.iterator().next();</span><br><span class="line">                        <span class="keyword">if</span> (beanFactory.containsBean(autowiredBeanName) &amp;&amp;</span><br><span class="line">                            beanFactory.isTypeMatch(autowiredBeanName, field.getType())) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.cachedFieldValue = <span class="keyword">new</span> ShortcutDependencyDescriptor(</span><br><span class="line">                                desc, autowiredBeanName, field.getType());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cachedFieldValue = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.cached = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//通过反射设置依赖值</span></span><br><span class="line">        ReflectionUtils.makeAccessible(field);</span><br><span class="line">        field.set(bean, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中关键是使用DefaultListableBeanFactory#resolveDependency解析依赖值，查看其实现，主要逻辑在DefaultListableBeanFactory#doResolveDependency：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object shortcut = descriptor.resolveShortcut(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (shortcut != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> shortcut;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理@Value注解，并获取对应值</span></span><br><span class="line">        Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">        Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String strVal = resolveEmbeddedValue((String) value);</span><br><span class="line">                BeanDefinition bd = (beanName != <span class="keyword">null</span> &amp;&amp; containsBean(beanName) ?</span><br><span class="line">                                     getMergedBeanDefinition(beanName) : <span class="keyword">null</span>);</span><br><span class="line">                value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">            &#125;</span><br><span class="line">            TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (UnsupportedOperationException ex) &#123;</span><br><span class="line">                <span class="comment">// A custom TypeConverter which does not support TypeDescriptor resolution...</span></span><br><span class="line">                <span class="keyword">return</span> (descriptor.getField() != <span class="keyword">null</span> ?</span><br><span class="line">                        converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">                        converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理集合bean的注入</span></span><br><span class="line">        Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">        <span class="keyword">if</span> (multipleBeans != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> multipleBeans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理单个bean的注入</span></span><br><span class="line">        Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">        <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String autowiredBeanName;</span><br><span class="line">        Object instanceCandidate;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果获取到的bean有多个，将根据@Primary及@Priority确定最优的一个</span></span><br><span class="line">        <span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line">                    <span class="comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line">                    <span class="comment">// (before 4.3 in particular when we didn&#x27;t even look for collection beans).</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We have exactly one match.</span></span><br><span class="line">            Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">            autowiredBeanName = entry.getKey();</span><br><span class="line">            instanceCandidate = entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (instanceCandidate <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            <span class="comment">//根据beanName，从beanFactory获取bean实例</span></span><br><span class="line">            instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = instanceCandidate;</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ClassUtils.isAssignableValue(type, result)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解了<strong>AutowiredAnnotationBeanPostProcessor</strong>的处理流程，那该处理器是在什么时候被调用的呢？</p>
<h3 id="AutowiredAnnotationBeanPostProcessor的调用时机"><a href="#AutowiredAnnotationBeanPostProcessor的调用时机" class="headerlink" title="AutowiredAnnotationBeanPostProcessor的调用时机"></a>AutowiredAnnotationBeanPostProcessor的调用时机</h3><p>查看其方法调用位置，不难看出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory#createBean</span><br><span class="line">	-&gt;AbstractAutowireCapableBeanFactory#doCreateBean</span><br><span class="line">        -&gt;AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors</span><br><span class="line">        	-&gt;MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition</span><br><span class="line">        -&gt;AbstractAutowireCapableBeanFactory#populateBean</span><br><span class="line">            -&gt;InstantiationAwareBeanPostProcessor#postProcessProperties</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>@Autowired、@Value等是由<strong>AutowiredAnnotationBeanPostProcessor</strong>处理的；</li>
<li><strong>AutowiredAnnotationBeanPostProcessor</strong>的postProcessMergedBeanDefinition方法用于解析构建@Autowired元数据，而postProcessProperties方法则用于@Autowired解析后值的注入；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：getBean方法解析</title>
    <url>/2023/05/30/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9AgetBean%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>getBean方法是BeanFactory定义的一系列方法，用于从Spring容器中获取bean实例。</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20220531064102379.png" alt="image-20220531064102379"></p>
<p>这些方法在AbstractBeanFactory均得到了具体实现，而这几个getBean方法最终都是调用了doGetBean方法，本文一起来看下</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<h2 id="doGetBean"><a href="#doGetBean" class="headerlink" title="doGetBean"></a>doGetBean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理别名，去除FactoryBean名称前缀&#x27;&amp;&#x27;</span></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果之前已经实例化好了，直接返回</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                             <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理FactoryBean的情况</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果该bean在当前线程下处于创建中状态，则认为其产生了循环依赖并抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果该bean在当前容器中不存在，则从其父容器获取</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                    nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理@DependsOn依赖，先实例化依赖的bean</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                        <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                        <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建单例bean</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                        <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//创建原型bean</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">finally</span> &#123;</span><br><span class="line">                            afterPrototypeCreation(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                                    <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                                                    <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                                                    ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查所需类型是否与bean实际类型一致，不一致则异常</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">            <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> convertedBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">                             ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取bean的时候，会尝试先从单例缓存中获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试从一级缓存获取</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">//一级缓存获取不到，并且当bean正在创建中时，尝试从二级缓存中获取</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">//二级缓存中获取不到时，尝试从三级缓存中获取，在三级缓存中存在时，将提前暴露AOP代理对象，并将其放于二级缓存</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面涉及到了三级缓存：</p>
<p><strong>singletonObjects：</strong>用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用；</p>
<p><strong>earlySingletonObjects：</strong>二级缓存，提前暴露出的代理对象，未填充属性及初始化的单例对象；</p>
<p><strong>singletonFactories：</strong>三级缓存，存放单例对象工厂，用于提前暴露bean的代理对象；</p>
<p>如果从缓存获取不到，bean的创建会根据bean的作用域进行创建，这里以单例bean的创建为例。</p>
<h3 id="getSingleton"><a href="#getSingleton" class="headerlink" title="getSingleton"></a>getSingleton</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">//尝试从缓存中获取单例bean</span></span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">                                                          <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">                                                          <span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将当前bean标记为正在创建中</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">                <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">                singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">                        ex.addRelatedCause(suppressedException);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">//将创建好的bean放入单例缓存中</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从getSingleton方法中可以看出，它与原型bean的创建的主要区别在于，单例bean的创建多了一层缓存，用于复用已经创建好的bean，而两者最终都是调用了AbstractAutowireCapableBeanFactory#createBean进行bean的创建。</p>
<h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取bean的类型</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  lookup method和replace method的校验和准备工作</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                                               beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//提交创建代理对象并返回，不走后续创建bean的流程，深入查看可以发现，</span></span><br><span class="line">        <span class="comment">//里面会寻找InstantiationAwareBeanPostProcessor处理器，并调用postProcessBeforeInstantiation方法</span></span><br><span class="line">        <span class="comment">//查找InstantiationAwareBeanPostProcessor实现类，会发现只有AbstractAutoProxyCreator这个类中有具体实现</span></span><br><span class="line">        <span class="comment">//并且在实现中，只有存在自定义targetsource的情况下，该方法才有可能返回非空</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                                        <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里开始bean的创建</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">        <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="doCreateBean"><a href="#doCreateBean" class="headerlink" title="doCreateBean"></a>doCreateBean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化bean，将bean封装为BeanWrapper</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition处理器调用</span></span><br><span class="line">    <span class="comment">// 我们前面讲到的@Autowired正是在这里，由AutowiredAnnotationBeanPostProcessor解析的</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在允许循环依赖（单例&amp;&amp;允许循环依赖&amp;&amp;当前bean正在创建中）的前提下，</span></span><br><span class="line">    <span class="comment">//将bean工厂（用于提前暴露AOP代理对象）放于三级缓存</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                         <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getEarlyBeanReference方法里会寻找SmartInstantiationAwareBeanPostProcessor处理器，</span></span><br><span class="line">        <span class="comment">//并调用其getEarlyBeanReference方法提前返回代理对象</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bean的初始化</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//bean属性的填充，InstantiationAwareBeanPostProcessor#postProcessProperties的调用</span></span><br><span class="line">        <span class="comment">//我们前面讲到的@Autowired是在这里进行真正的注入操作</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">//初始化bean对象</span></span><br><span class="line">        <span class="comment">//Aware方法</span></span><br><span class="line">        <span class="comment">//BeanPostProcessor#postProcessBeforeInitialization</span></span><br><span class="line">        <span class="comment">//InitializingBean#afterPropertiesSet，init-method方法</span></span><br><span class="line">        <span class="comment">//BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line">        <span class="comment">//将在这里被依次调用</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//尝试从二级缓存中重新获取一遍，将提前暴露的aop代理对象（如果有的话）替换原bean实例并返回</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                                                               <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                                                               StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                                               <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，doCreateBean做的事情：</p>
<ol>
<li>createBeanInstance：bean的实例化；</li>
<li>addSingletonFactory：将bean放入三级缓存；</li>
<li>populateBean：依赖注入；</li>
<li>initializeBean：bean后置处理器的调用，bean的初始化等；</li>
</ol>
<p>这里有一个细节点，那就是三级缓存的放入是在bean的实例化之后的，而三级缓存是用于解决循环依赖的，这也是为什么当构造函数注入存在循环依赖时而无法解决的原因。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后以A实例及B实例循环场景为例，bean的创建流程如下：</p>
<p><img src="http://storage.laixiaoming.space/blog/circular_dependency.jpg" alt="circular_dependency"></p>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>实现延时任务可以有几种方式</title>
    <url>/2023/06/13/%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在开发中，延时任务属于比较常见的需求，比如，订单在限定时间内未支付则自动取消并释放库存；外卖的商家端在设置特定时间后仍未接单时则自动接单等这都需要延时任务来完成。<br>实现延时任务的方式可以有许多种：<br> 1 DelayQueue(JDK提供实现)<br> 2 ScheduledExecutorService(JDK提供实现)<br> 3 Redis(使用ZSET数据结构实现)<br> 4 RabbitMQ实现<br> 5 ……</p>
<span id="more"></span>

<p>下面我们来简单看看这几种方式的实现，并分析其优缺点。</p>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>DelayQueue属于JDK并发包<strong>java.util.concurrent</strong>中提供的一个类，它是一个无界阻塞队列，元素只有在延迟时间到达时才能被获取。该队列的元素必须实现Delayed接口，队列头部是剩余延迟时间最小的元素。<br>使用过程中，添加任务时使用add()方法，获取任务时使用poll()或take()方法，poll()方法和take()方法的区别是take()方法是阻塞的，如果没有到点的任务可取，take()方法会等待直到可用，而poll()方法则会直接返回null。<br>首先自定义延时任务类型，实现Delayed接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//延迟时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> delayTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务开始时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务消息</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayTask</span><span class="params">(<span class="keyword">long</span> delayTime, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delayTime = delayTime;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.startTime = System.currentTimeMillis() + delayTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelayTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delayTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDelayTime</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delayTime = delayTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStartTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStartTime</span><span class="params">(<span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startTime = startTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(startTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> diff = <span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="keyword">return</span> diff &gt; <span class="number">0</span> ? <span class="number">1</span> : (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过DelayQueue进行存取即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DelayQueue&lt;DelayTask&gt; delayQueue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line"><span class="comment">//添加任务</span></span><br><span class="line">delayQueue.add(t1);</span><br><span class="line"><span class="comment">//获取任务</span></span><br><span class="line">delayQueue.take();</span><br></pre></td></tr></table></figure>



<p>该方式实现非常简单，但缺点也是显而易见的，其适用于单机环境下，而且延迟任务没有进行持久化存储，一旦关机断电，任务便不存在。</p>
<h2 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h2><p>与DelayQueue一样，ScheduledExecutorService同属于<code>java.util.concurrent</code>包中，使用起来也是拿来即用，非常简单的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">executorService.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1s后执行&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>其优缺点与DelayQueue一般，这里就不多说了。</p>
<h2 id="Redis-使用ZSET数据结构实现"><a href="#Redis-使用ZSET数据结构实现" class="headerlink" title="Redis(使用ZSET数据结构实现)"></a>Redis(使用ZSET数据结构实现)</h2><p>ZSET是Redis提供的一种有序集合数据结构，集合的元素value会关联一个double类型的分数(score)，集合会根据这个分数来对元素进行从小到大的排序。<br>我们可以将延时任务消息序列化成一个字符串作为 zset 的value，这个任务消息的到期处理时间作为score进行存储，另外启用一个或者多个线程对集合中的任务进行到期判断处理（以当前时间为界限，获取到集合的首个元素，进行处理并从集合中删除元素），其中，在多线程环境下，为了使获取元素和移除元素的操作的原子性，我们可以使用lua脚本：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> minVal = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> maxVal = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> todolist = redis.call(<span class="string">&quot;ZRANGEBYSCORE&quot;</span>, key, minVal, maxVal, <span class="string">&quot;limit&quot;</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">local</span> todo = todolist[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> todo == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	redis.call(<span class="string">&quot;ZREM&quot;</span>, key, todo)</span><br><span class="line">	<span class="keyword">return</span> todo</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>使用Redis的这种延时任务实现适用于分布式环境，消息也能够保证持久化存储，但获取到期任务的时间间隔较难把握，同时也不能保证任务消息消费过程中的可靠性，就上面的实现来说，如果我们获取到了任务，但还没处理完成出现了异常，操作被中断了，那么这条任务是彻底丢失了。</p>
<h2 id="RabbitMQ实现"><a href="#RabbitMQ实现" class="headerlink" title="RabbitMQ实现"></a>RabbitMQ实现</h2><p>RabbitMQ本身并不提供延时任务功能的实现，但可以通过它的Time-To-Live Extensions 与 Dead Letter Exchange 的特性模拟出延迟队列的功能。<br>RabbitMQ支持为队列或者消息设置TTL（存活时间）。TTL表明了一条消息可在队列中存活的最大时间。当某条消息被设置了TTL或者当某条消息进入了设置了TTL的队列时（如果既配置了消息的TTL，又配置了队列的TTL，那么较小的那个值会被取用），这条消息会在TTL时间后死亡成为Dead Letter。如果为这个队列设置了<strong>x-dead-letter-exchange</strong>和<strong>x-dead-letter-routing-key</strong>，那么这些Dead Letter就会被重新发送到<strong>x-dead-letter-exchange</strong>指定的exchange中，然后通过根据<strong>x-dead-letter-routing-key</strong>路由到相应队列，这时我们通过监听<strong>x-dead-letter-exchange</strong>中绑定的队列，即可实现延迟队列的功能。<br>实例（Spring Boot下）：<br>配置文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.rabbitmq.virtual-host</span>=<span class="string">/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消息发送确认</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirms</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#消息没有相应队列和交换器绑定时是否返回，好像没有用？</span></span><br><span class="line"><span class="comment">#spring.rabbitmq.publisher-returns=true</span></span><br><span class="line"><span class="comment">#与return机制结合配置此属性，true返回消息，false丢弃消息</span></span><br><span class="line"><span class="comment">#spring.rabbitmq.template.mandatory=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消息消费手动确认</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class="string">manual</span></span><br></pre></td></tr></table></figure>

<p>RabbitMQ配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>, <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Dead Letter Exchange</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXEC_EXCHANGE_NAME = <span class="string">&quot;delayed.exec.exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Dead Letter Queue</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXEC_QUEUE_NAME = <span class="string">&quot;delayed.exec.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Dead Letter Routing Key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXEC_ROUTING_KEY = <span class="string">&quot;delayed.exec.routing.key&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXCHANGE_NAME = <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_QUEUE_NAME = <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_ROUTING_KEY = <span class="string">&quot;delayed.routing.key&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(CachingConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">        RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">        rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;correlationData:&quot;</span> + correlationData + <span class="string">&quot;,cause:&quot;</span> + cause);</span><br><span class="line">        <span class="keyword">if</span>(!ack)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送失败！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有找到对应的队列!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;message:&quot;</span> + message +</span><br><span class="line">                <span class="string">&quot;,replyCode:&quot;</span> + replyCode +</span><br><span class="line">                <span class="string">&quot;,replyText:&quot;</span> + replyText +</span><br><span class="line">                <span class="string">&quot;,exchange:&quot;</span> + exchange +</span><br><span class="line">                <span class="string">&quot;,routingKey:&quot;</span> + routingKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delayedQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DELAYED_EXEC_EXCHANGE_NAME);</span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, DELAYED_EXEC_ROUTING_KEY);</span><br><span class="line"><span class="comment">//        params.put(&quot;x-message-ttl&quot;, 5 * 1000);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAYED_QUEUE_NAME, <span class="keyword">true</span>,<span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">delayedExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(DELAYED_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">delayedBind</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayedExchange()).with(DELAYED_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delayedExecQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAYED_EXEC_QUEUE_NAME,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">delayedExecExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(DELAYED_EXEC_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">delayedExecBind</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedExecQueue()).to(delayedExecExchange()).with(DELAYED_EXEC_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RabbitMQ延迟消息发送：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDelayedMsg</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.DELAYED_EXCHANGE_NAME, RabbitMQConfig.DELAYED_ROUTING_KEY, data, message -&gt; &#123;</span><br><span class="line">            message.getMessageProperties().setExpiration(<span class="number">5</span> * <span class="number">1000</span> + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延迟队列监听：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConfig.DELAYED_EXEC_QUEUE_NAME&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delayedExec</span><span class="params">(String data, Message message, Channel channel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;data:&quot;</span> + data);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">//消息确认</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用RabbitMQ的延迟任务实现适用于分布式环境，并且消息也支持持久化，消息的发送和消费也因为有了确认机制的支持而有了更高的可靠性。但需要注意的是，用这种方式实现的延时任务，如果需要实现不同消息的消息有不同的延迟时间的话，共用一个队列是不可行的。比如两条消息，一条延迟时间为20s的消息先抵达队列，另一条延迟时间为10s的消息后抵达，那么此时的消息消费顺序是，经过20s后，第一条消息将会先被消费，第二条消息在紧接其后被消费（与入队顺序保持了一致），在这种情况下，就只能通过设置多个不同延时时间的队列来实现了。</p>
]]></content>
      <tags>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：AOP代理对象的创建</title>
    <url>/2023/06/14/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9AAOP%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AOP是Spring中的核心功能之一，使用AOP，可以让关注点代码与业务代码分离，并且动态地添加和删除在切面上的逻辑而不影响原来的执行代码，从而可以在不修改源代码的情况下，实现对功能的增强。</p>
<p>AOP的应用场景很多，日志记录、性能监控、事务管理等都可以通过AOP去实现。</p>
<p>AOP的原理就是动态代理，在 Spring 中，存在两种实现机制， JDK 动态代理以及 CGLIB 动态代理。</p>
<p>在Spring Boot中，AOP可以通过**@EnableAspectJAutoProxy**注解开启，那该注解是怎么起作用的呢，代理对象又是如何被创建的呢？</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<h2 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed</span></span><br><span class="line"><span class="comment">	 * to standard Java interface-based proxies. The default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Indicate that the proxy should be exposed by the AOP framework as a &#123;<span class="doctag">@code</span> ThreadLocal&#125;</span></span><br><span class="line"><span class="comment">	 * for retrieval via the &#123;<span class="doctag">@link</span> org.springframework.aop.framework.AopContext&#125; class.</span></span><br><span class="line"><span class="comment">	 * Off by default, i.e. no guarantees that &#123;<span class="doctag">@code</span> AopContext&#125; access will work.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.3.1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该注解@Import了<strong>AspectJAutoProxyRegistrar</strong>这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers an &#123;<span class="doctag">@link</span> org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line"><span class="comment"> * AnnotationAwareAspectJAutoProxyCreator&#125; against the current &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment"> * as appropriate based on a given @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy&#125; annotation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span></span><br><span class="line"><span class="comment">	 * of the @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">		AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">				AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">		<span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">				AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line">				AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由类注释可以看出，<strong>AspectJAutoProxyRegistrar</strong>的作用是向IOC容器注册<strong>AnnotationAwareAspectJAutoProxyCreator</strong>。那么<strong>AnnotationAwareAspectJAutoProxyCreator</strong>是什么呢?</p>
<h2 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h2><p>我们先来看下<strong>AnnotationAwareAspectJAutoProxyCreator</strong>的类继承关系图：</p>
<p><img src="http://storage.laixiaoming.space/blog/AnnotationAwareAspectJAutoProxyCreator.jpg" alt="AnnotationAwareAspectJAutoProxyCreator"></p>
<p>可以发现，<strong>AnnotationAwareAspectJAutoProxyCreator</strong>：</p>
<ol>
<li>实现了<strong>BeanPostProcessor **接口，其关键方法</strong>postProcessBeforeInitialization<strong>和</strong>postProcessAfterInitialization<strong>将会在bean创建过程中的初始化流程中</strong>AbstractAutowireCapableBeanFactory#initializeBean<strong>被调用，而AOP代理代理对象也是通过</strong>postProcessAfterInitialization**得到；</li>
<li>实现了<strong>InstantiationAwareBeanPostProcessor</strong>接口，其关键方法<strong>postProcessBeforeInstantiation</strong>会在bean实例化前尝试被调用；</li>
<li>实现了<strong>SmartInstantiationAwareBeanPostProcessor</strong>接口，其关键方法<strong>getEarlyBeanReference</strong>将会作为提前暴露代理对象的入口放入bean的三级缓存中；</li>
</ol>
<p>在本文中，我们主要关注<strong>postProcessAfterInitialization **方法，该方法在</strong>AbstractAutoProxyCreator**中被实现。</p>
<h2 id="AbstractAutoProxyCreator-postProcessAfterInitialization"><a href="#AbstractAutoProxyCreator-postProcessAfterInitialization" class="headerlink" title="AbstractAutoProxyCreator#postProcessAfterInitialization"></a>AbstractAutoProxyCreator#postProcessAfterInitialization</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="earlyProxyReferences"><a href="#earlyProxyReferences" class="headerlink" title="earlyProxyReferences"></a>earlyProxyReferences</h2><p>查看其引用，可以发现只在<strong>getEarlyBeanReference</strong>中被使用，而<strong>getEarlyBeanReference</strong>是在循环引用发生的情况下被调用，结合这里的判断不难看出，这里主要是防止代理对象的重复生成。</p>
<h3 id="wrapIfNecessary"><a href="#wrapIfNecessary" class="headerlink" title="wrapIfNecessary"></a>wrapIfNecessary</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前bean是否在targetSourcedBeans中存在，存在则表示已处理过</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否无需处理</span></span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//isInfrastructureClass判断是否基础设施类型，这里过滤了Advice、PointCut、Advisor、AopInfrastructureBean类型，</span></span><br><span class="line">    <span class="comment">//以及被@Advice标注的类</span></span><br><span class="line">    <span class="comment">//shouldSkip判断是否需要跳过该bean</span></span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取能对该bean进行增强的切面</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="shouldSkip"><a href="#shouldSkip" class="headerlink" title="shouldSkip"></a>shouldSkip</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加载所有的增强器，并将其缓存</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line">        <span class="comment">//跳过增强器类</span></span><br><span class="line">        <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;</span><br><span class="line">            ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用父类实现，如果是原始类型，则跳过</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.shouldSkip(beanClass, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用父类实现，加载Advisor类型的bean</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//加载被@Aspect标注的类，</span></span><br><span class="line">        <span class="comment">//并将@Around、@Before、@After、@AfterReturning、@AfterThrowing标注的方法等构建为Advisor并返回</span></span><br><span class="line">        advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="getAdvicesAndAdvisorsForBean"><a href="#getAdvicesAndAdvisorsForBean" class="headerlink" title="getAdvicesAndAdvisorsForBean"></a>getAdvicesAndAdvisorsForBean</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">			Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line">	<span class="comment">//找到符合条件的增强器</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加载所有的增加器，该方法在shouldSkip中调用过一次，再次调用将从缓存中获取</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="comment">//过滤出匹配到的增强器，这里会根据切入点（@Pointcut）表达式去匹配该bean</span></span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="createProxy"><a href="#createProxy" class="headerlink" title="createProxy"></a>createProxy</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建代理工厂</span></span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    <span class="comment">//从当前类复制配置</span></span><br><span class="line">    proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组合所有增强器，并将其放入代理工厂</span></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过代理工厂创建代理对象</span></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="getProxy"><a href="#getProxy" class="headerlink" title="getProxy"></a>getProxy</h4><p>创建代理对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">        activate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">                                         <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终来到DefaultAopProxyFactory，然后是我们熟悉的逻辑：</p>
<ol>
<li>如果目标对象有接口，用JDK动态代理；</li>
<li>如果没有接口，用CGLIB动态代理；</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>AOP代理对象的创建通过<strong>AnnotationAwareAspectJAutoProxyCreator</strong>实现，该类是<strong>BeanPostProcessor</strong>的子类，并且在不存在循环依赖的情况下，是在<strong>postProcessAfterInitialization</strong>方法中创建的；</li>
<li><strong>postProcessAfterInitialization</strong>中，会匹配出所有和当前Bean相关的增强器，并最终根据实际情况判断是使用JDK动态代理，还是CGLIB动态代理；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：DeferredResult的处理流程</title>
    <url>/2024/04/20/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9ADeferredResult%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>业务开发时，轮询可以被用于许多场景中，但把握轮询的频次不是一件容易的事情，频次过高会对服务端产生不小的压力，频次过低时，则无法保证实时性。而随着Servlet 3.0异步请求处理的特性支持，DeferredResult的出现很好的解决了这个问题。</p>
<span id="more"></span>

<h3 id="DeferredResult是什么"><a href="#DeferredResult是什么" class="headerlink" title="DeferredResult是什么"></a>DeferredResult是什么</h3><p>DeferredResult是Spring基于Servlet 3.0的异步请求处理功能实现的，它可以迟早地释放Tomcat的请求线程，由业务线程去处理业务逻辑，处理完成再把结果返回到客户端，这可以使得服务端能够处理更多请求，以提升服务端的并发处理能力。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeferredResultTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/deferredResult&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">deferredResult</span><span class="params">(<span class="meta">@RequestParam(defaultValue = &quot;1000&quot;)</span> <span class="keyword">long</span> sleepMills)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3s超时时间</span></span><br><span class="line">        DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;&gt;(<span class="number">3000L</span>);</span><br><span class="line">        deferredResult.onCompletion(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;请求完成&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        deferredResult.onTimeout(() -&gt; &#123;</span><br><span class="line">            deferredResult.setResult(<span class="string">&quot;请求超时了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用新的业务线程去处理</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(sleepMills);</span><br><span class="line">                deferredResult.setResult(<span class="string">&quot;处理成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">return</span> deferredResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DeferredResult的处理流程"><a href="#DeferredResult的处理流程" class="headerlink" title="DeferredResult的处理流程"></a>DeferredResult的处理流程</h3><p>我们都知道，在Spring中，所有的请求都是由DispatcherServlet处理的，异步请求也不例外：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	HttpServletRequest processedRequest = request;</span><br><span class="line">	HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//根据HttpServletRequest 创建或者从缓存中获取 WebAsyncManager 对象</span></span><br><span class="line">	WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">		Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			processedRequest = checkMultipart(request);</span><br><span class="line">			multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Determine handler for the current request.</span></span><br><span class="line">			mappedHandler = getHandler(processedRequest);</span><br><span class="line">			<span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">				noHandlerFound(processedRequest, response);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">			HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">			String method = request.getMethod();</span><br><span class="line">			<span class="keyword">boolean</span> isGet = <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">			<span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">				<span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Actually invoke the handler.</span></span><br><span class="line">			mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">               <span class="comment">//异步请求开始时，直接返回</span></span><br><span class="line">			<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			applyDefaultViewName(processedRequest, mv);</span><br><span class="line">			mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//。。。</span></span><br><span class="line">		processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是，这里而会获取/或新创建一个<strong>WebAsyncManager</strong>，该对象与当前请求绑定，用于对异步操作的管理，比如处理结果的传递、上下文的保存等。</p>
<p>对于返回结果为DeferredResult的Controller方法，Spring通过<strong>DeferredResultMethodReturnValueHandler</strong>来区分和处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeferredResultMethodReturnValueHandler</span> <span class="keyword">implements</span> <span class="title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">		Class&lt;?&gt; type = returnType.getParameterType();</span><br><span class="line">		<span class="keyword">return</span> (DeferredResult.class.isAssignableFrom(type) ||</span><br><span class="line">				ListenableFuture.class.isAssignableFrom(type) ||</span><br><span class="line">				CompletionStage.class.isAssignableFrom(type));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">			ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">			mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		DeferredResult&lt;?&gt; result;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//处理返回类型为DeferredResult、ListenableFuture、CompletionStage的结果</span></span><br><span class="line">		<span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> DeferredResult) &#123;</span><br><span class="line">			result = (DeferredResult&lt;?&gt;) returnValue;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> ListenableFuture) &#123;</span><br><span class="line">			result = adaptListenableFuture((ListenableFuture&lt;?&gt;) returnValue);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> CompletionStage) &#123;</span><br><span class="line">			result = adaptCompletionStage((CompletionStage&lt;?&gt;) returnValue);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Should not happen...</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unexpected return value type: &quot;</span> + returnValue);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理DeferredResult请求</span></span><br><span class="line">		WebAsyncUtils.getAsyncManager(webRequest).startDeferredResultProcessing(result, mavContainer);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>来到<strong>WebAsyncManager#startDeferredResultProcessing</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Start concurrent request processing and initialize the given</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> DeferredResult&#125; with a &#123;<span class="doctag">@link</span> DeferredResultHandler&#125; that saves</span></span><br><span class="line"><span class="comment"> * the result and dispatches the request to resume processing of that</span></span><br><span class="line"><span class="comment"> * result. The &#123;<span class="doctag">@code</span> AsyncWebRequest&#125; is also updated with a completion</span></span><br><span class="line"><span class="comment"> * handler that expires the &#123;<span class="doctag">@code</span> DeferredResult&#125; and a timeout handler</span></span><br><span class="line"><span class="comment"> * assuming the &#123;<span class="doctag">@code</span> DeferredResult&#125; has a default timeout result.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deferredResult the DeferredResult instance to initialize</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> processingContext additional context to save that can be accessed</span></span><br><span class="line"><span class="comment"> * via &#123;<span class="doctag">@link</span> #getConcurrentResultContext()&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception if concurrent processing failed to start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getConcurrentResult()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getConcurrentResultContext()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDeferredResultProcessing</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> DeferredResult&lt;?&gt; deferredResult, Object... processingContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	Assert.notNull(deferredResult, <span class="string">&quot;DeferredResult must not be null&quot;</span>);</span><br><span class="line">	Assert.state(<span class="keyword">this</span>.asyncWebRequest != <span class="keyword">null</span>, <span class="string">&quot;AsyncWebRequest must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Long timeout = deferredResult.getTimeoutValue();</span><br><span class="line">	<span class="keyword">if</span> (timeout != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.asyncWebRequest.setTimeout(timeout);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	List&lt;DeferredResultProcessingInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	interceptors.add(deferredResult.getInterceptor());</span><br><span class="line">	interceptors.addAll(<span class="keyword">this</span>.deferredResultInterceptors.values());</span><br><span class="line">	interceptors.add(timeoutDeferredResultInterceptor);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> DeferredResultInterceptorChain interceptorChain = <span class="keyword">new</span> DeferredResultInterceptorChain(interceptors);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.asyncWebRequest.addTimeoutHandler(() -&gt; &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			interceptorChain.triggerAfterTimeout(<span class="keyword">this</span>.asyncWebRequest, deferredResult);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			setConcurrentResultAndDispatch(ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.asyncWebRequest.addErrorHandler(ex -&gt; &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!interceptorChain.triggerAfterError(<span class="keyword">this</span>.asyncWebRequest, deferredResult, ex)) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			deferredResult.setErrorResult(ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable interceptorEx) &#123;</span><br><span class="line">			setConcurrentResultAndDispatch(interceptorEx);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.asyncWebRequest.addCompletionHandler(()</span><br><span class="line">			-&gt; interceptorChain.triggerAfterCompletion(<span class="keyword">this</span>.asyncWebRequest, deferredResult));</span><br><span class="line"></span><br><span class="line">	interceptorChain.applyBeforeConcurrentHandling(<span class="keyword">this</span>.asyncWebRequest, deferredResult);</span><br><span class="line">	<span class="comment">//1. 开启异步处理</span></span><br><span class="line">       startAsyncProcessing(processingContext);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		interceptorChain.applyPreProcess(<span class="keyword">this</span>.asyncWebRequest, deferredResult);</span><br><span class="line">		<span class="comment">//2. 设置ResultHandler处理器</span></span><br><span class="line">           deferredResult.setResultHandler(result -&gt; &#123;</span><br><span class="line">			result = interceptorChain.applyPostProcess(<span class="keyword">this</span>.asyncWebRequest, deferredResult, result);</span><br><span class="line">			setConcurrentResultAndDispatch(result);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		setConcurrentResultAndDispatch(ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从方法注释中，我们也可以看出，该方法：</p>
<ol>
<li>开启异步处理，将当前请求标记为异步请求，以便Tomcat能够识别；</li>
<li>针对当前的DeferredResult，设置了一个结果处理器；</li>
</ol>
<p>而当我们调用<strong>DeferredResult#setResult</strong>时，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setResult</span><span class="params">(T result)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> setResultInternal(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setResultInternal</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isSetOrExpired()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DeferredResultHandler resultHandlerToUse;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isSetOrExpired()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.result = result;</span><br><span class="line">		<span class="comment">//取当前设置的ResultHandler</span></span><br><span class="line">		resultHandlerToUse = <span class="keyword">this</span>.resultHandler;</span><br><span class="line">		<span class="keyword">if</span> (resultHandlerToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.resultHandler = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//处理</span></span><br><span class="line">	resultHandlerToUse.handleResult(result);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，实际调用的是在<strong>WebAsyncManager#startDeferredResultProcessing</strong>设置的进去的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setConcurrentResultAndDispatch</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (WebAsyncManager.<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.concurrentResult != RESULT_NONE) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">           <span class="comment">//设置结果</span></span><br><span class="line">		<span class="keyword">this</span>.concurrentResult = result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.asyncWebRequest.isAsyncComplete()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Async result set but request already complete: &quot;</span> + formatRequestUri());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		<span class="keyword">boolean</span> isError = result <span class="keyword">instanceof</span> Throwable;</span><br><span class="line">		logger.debug(<span class="string">&quot;Async &quot;</span> + (isError ? <span class="string">&quot;error&quot;</span> : <span class="string">&quot;result set&quot;</span>) + <span class="string">&quot;, dispatch to &quot;</span> + formatRequestUri());</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">//将请求再次分发，该请求将重新进入DispatcherServlet的doDispatch方法进行处理</span></span><br><span class="line">	<span class="keyword">this</span>.asyncWebRequest.dispatch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次进入<strong>DispatcherServlet#doDispatch</strong>方法，通过debug可以发现，asyncManager这里已经拿到了处理结果：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20240420181952931.png" alt="image-20240420181952931"></p>
<p>而在后续通过<strong>RequestMappingHandlerAdapter</strong>调用具体的Controller方法时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">		asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">		asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">		asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">		asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line">		<span class="comment">//当前异步请求是否有了结果</span></span><br><span class="line">		<span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">			Object result = asyncManager.getConcurrentResult();</span><br><span class="line">			mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">			asyncManager.clearConcurrentResult();</span><br><span class="line">			LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">				String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;Resume with async result [&quot;</span> + formatted + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">			&#125;);</span><br><span class="line">               <span class="comment">//替换原始反射方法，该方法返回最终结果</span></span><br><span class="line">			invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">		<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		webRequest.requestCompleted();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，原来的Controller方法会被替换，替换后的invokeAndHandle将直接返回最终处理结果，返回类型也不再是DeferredResult，结果被返回给客户端。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li><p> 在Spring中使用异步请求可以将返回值定义为<strong>DeferredResult</strong>；</p>
</li>
<li><p>Spring通过<strong>DeferredResultMethodReturnValueHandler</strong>针对返回类型为DeferredResult的Controller方法返回值进行特殊处理：</p>
<p>​    a. 开启异步请求；</p>
<p>​    b.设置结果回调处理器DeferredResultHandler； </p>
</li>
<li><p>DeferredResult设置返回结果后，将触发DeferredResultHandler处理器的执行，该处理器将对原请求重新分发处理，并将最终结果 保存在了<strong>WebAsyncManager</strong>中，随后触发了<strong>DispatcherServlet#doDispatch</strong>的再次执行；</p>
</li>
<li><p>第二次<strong>DispatcherServlet#doDispatch</strong>执行过程中，将通过<strong>WebAsyncManager</strong>拿到处理结果，将在后续替换掉原有Controller方法的调用，将最终结果返回给客户端。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>日志：每个软件工程师都应该知道的实时数据的统一抽象</title>
    <url>/2024/04/23/%E6%97%A5%E5%BF%97%EF%BC%9A%E6%AF%8F%E4%B8%AA%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%83%BD%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E4%B8%80%E6%8A%BD%E8%B1%A1/</url>
    <content><![CDATA[<blockquote>
<p>原文：<a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying">The Log: What every software engineer should know about real-time data’s unifying abstraction</a></p>
<p>作者：<strong>Jay Kreps</strong></p>
</blockquote>
<p>我大约在六年前加入了领英，那是一个特别有趣的时间点。那时我们正面临着单体集中式数据库极限的挑战，需要开始向专门的分布式系统转变。这真是一个有趣的经历：我们构建、部署和运行了分布式图数据库、分布式搜索后端、Hadoop套件、一代及二代键值数据库，并运行至今。</p>
<p>在这个过程中，我学到的最有用的一件事情是，我们在这里构建的大多数组件，其核心都有一个简单的概念：日志，有时也被称作先写日志、提交日志或者事务日志，日志几乎与计算机的历史一样悠久，它是许多分布式数据系统和实时应用架构里面的核心。</p>
<p>如果你不了解日志，你也就不可能完全了解数据库、NoSQL存储、键值存储、副本、paxos、hadoop、版本控制、甚至几乎任何软件系统，然而大多数软件工程师都不熟悉它，我希望改变这个现状。在这篇文章中，我将告诉你一切你需要知道的关于日志的事情，包括什么是日志、如何在数据集成、实时处理和系统构建中使用日志。</p>
<span id="more"></span>

<h3 id="第一部分：什么是日志"><a href="#第一部分：什么是日志" class="headerlink" title="第一部分：什么是日志"></a>第一部分：什么是日志</h3><p>日志可能是最简单的存储抽象，它是一个只能追加、按时间排序的完全有序的序列。</p>
<p><img src="http://storage.laixiaoming.space/blog/log.png" alt="img"></p>
<p>记录被追加到到日志的末尾，读取时从左到右进行。每条记录都按序分配了一个唯一数字。</p>
<p>记录的顺序包含了时间的概念，因为左边的条目在时间上是比右边的条目更加早的。日志记录的数字可以认为是这条记录的时间戳。将这种顺序描述为时间的概念，乍一看可能会有点奇怪，但有一个好处是，它可以从任何特定的物理时钟中脱离出来，这个好处在我们谈到分布式系统时显得更加至关重要。</p>
<p>记录的内容和形式不在这次讨论的重点。当然，我们不能一直往日志中追加记录，因为磁盘的空间是有限的，这一点稍后会谈到。</p>
<p>日志并不安全不同于文件或者数据库表。一个文件是一个字节数组，数据库表是一系列的记录，日志也是一种表或者文件，但它是时间上有序的。</p>
<p>你可能会有疑问，这么简单的东西，为什么会值得讨论？只能追加的记录序列和数据系统有什么关系？答案是，日志有一个很关键的点，它记录了发生了什么事情以及是什么时候发生的，在多数情况下，这点对于分布式系统而言，是问题的关键。</p>
<p>在我们深入之前，先让我说明一件可能让人有疑惑的事情。每个工程师都很熟悉另一种日志的定义，那就是一个应用通过syslog或者log4j向本地文件写入的非结构化的错误信息或者跟踪信息，为了避免歧义，我称这个为“应用日志”。相对于我在本文描述的日志，应用日志具有另一种形式。这两种日志最大的不同之处在于，应用日志主要是用于人进行阅读，而我所描述的日志或数据日志被用于程序化访问。</p>
<p>（事实上，如果你稍微思考下，就会发现，人在单台机器上阅读日志的想法有些不合时宜。当涉及到许多服务和服务器时，这种方法很快就变得一种难于管理。日志的目的很快就变成了查询和图表的输入，以理解机器的行为，因此用英文书写在文件的日志并不如在本文中描述的结构化日志合适。）</p>
<h4 id="数据库中的日志"><a href="#数据库中的日志" class="headerlink" title="数据库中的日志"></a>数据库中的日志</h4><p>我不知道日志的概念起源于哪里，或许是因为它太过简单以至于发明者不认为它是一种发明，就像十分查找算法。它早在IBM的Sytem R时就出现了。日志在数据库的使用是在崩溃的时候，必须保持数据结构和索引的同步。为了保证原子性、持久性，数据库系统在对它维护的所有数据结构应用修改之前，会通过日志写入将要修改的记录的信息。日志是对发生的事情的记录，每个数据库表或索引都是对有用的数据结构或索引的历史数据的投影。由于日志是即时持久化的，它也作为一种可靠数据来源，用于在崩溃时恢复其他持久化结构的。</p>
<p>随着时间的推进，日志的用法也从用于ACID的实现细节，演变为在数据库之前同步数据的一种方式。发生在主数据库上的变更序列也需要被应用于远程的从库上，以保持同步。Oracle、MySQL、PostgreSQL都包含了传输协议，将部分日志传输到扮演从库角色的副本数据库。Oracle还将日志产品化为一种通用通用的数据订阅机制，非Oracle数据订阅者可以使用它们的XStreams和GoldenGate进行订阅使用。在MySQL和PostgreSQL上，相似的组件也作为许多数据库构中的关键组件存在。</p>
<p>由于这个原因，机器可读的日志的概念也被局限于数据库的内部。日志作为数据订阅机制的使用似乎是偶然出现的。但这种抽象非常适用于消息、数据流和实时数据处理的所有类型。</p>
<h4 id="分布式系统中的日志"><a href="#分布式系统中的日志" class="headerlink" title="分布式系统中的日志"></a>分布式系统中的日志</h4><p>在分布式系统中，变更的序列和数据的分发是日志解决的两个尤为重要的问题。就更新的顺序达成一致（或达成不一致、应对副作用），是分布式系统设计的核心问题。</p>
<p>以日志为中心的分布式系统方法源于一个简单的观察，我称它为“状态机复制原理”：</p>
<blockquote>
<p>如果两个相同的、确定性的进程的起始状态是相同的，并且以同样的顺序获取了相同的输入，那么这两个进程将产生同样的输出，最终也拥有相同的状态。</p>
</blockquote>
<p>这听起来有点晦涩，让我们深入了解它的含义。</p>
<p>确定性意味着这个进程是不依赖于时钟的，也不会有其他“带外数据”影响它的输出。如果一个程序的输出受线程执行的特定顺序影响、调用了<strong>gettimeofday</strong>或其他不可重复调用的方法，就可以认为是非确定性的。</p>
<p>进程的状态是最终保留在机器上内存或者磁盘的数据。</p>
<p>以相同的数据获取相同的输入听起来很熟悉，这跟日志相同。这是一个非常直观的概念：如果你给两段确定性的代码提供相同的日志输入，它们将得到相同的输出。</p>
<p>应用在分布式计算上就非常明显，你可以将使多个机器做相同的事情的问题，简化为实现分布式的一致性日志，并作为这些进程的输入的问题。在这里，日志的目的就是将所有的非确定性排除在输入流之外，以确保所有副本处理这些输入时保持同步。</p>
<p>当你理解了这个，这个也就不再复杂和深奥了：这差不多说，确定性的处理就是确定性的。然而，我仍然认为它是分布式系统设计中更通用的工具。</p>
<p>一个关于这个方法的最奇妙的一个事情就是，作为日志索引的时间戳也扮演着副本状态的时钟角色，你可以通过每个副本当前处理的最大的记录的一个简单的数字或者时间戳来描述每个副本。这个时间戳对应的日志体现了副本的状态。</p>
<p>根据日志写入的内容，在系统中应用这个原理有多种方式。例如，我们可以在日志中记录服务的请求、在对请求响应时服务的状态变化、或者执行的变更指令。理论上，我们甚至可以记录每个副本上要执行的一系列机器指令，要调用的方法名和参数。只要这两个进程以同样的方式处理这些输入，这些进程将在副本中保持一致的状态。</p>
<p>不同的用户群体似乎用不一样的方式描述日志的使用。数据库使用群体通常会区分物理日志和逻辑日志，物理日志指的是记录每一行变更的内容的日志，而逻辑日志记录的不是行的变更，而是会引起行数据变更的SQL命令（insert、update、delete语句）。</p>
<p>分布式系统文献通常将处理和复制广泛的分为两种方式。“状态机模型”通常被称为“主-主模型”，在这个模型下，我们维护了请求的日志，每个副本都处理这些请求。对“主-主模型”作了轻微的修改后，出现了“主-从模型”，在这个模型下，会选出一个副本作为主副本，来顺序处理到来的请求，并在处理过程中，在日志记录下状态的变更，其他的副本则顺序应用主副本上的状态变更，保持同步，以便在主副本异常时接替成为主副本。</p>
<p><img src="http://storage.laixiaoming.space/blog/active_and_passive_arch.png" alt="img"></p>
<p>为了理解这两种方式之前的不同，我们先来看一个不太严谨的例子，假设有多个算术服务，这些服务里维护了一个数字（初始值为0）作为服务的状态，并对这个数字应用加法和乘法。“主-主模型”下，在日志会记录下对这个值作出的变更，如“+1”、“*2”等，每个副本都会应用这些变更并得到相同的数字集。在“主-从”模型下，将存在唯一一个主副本，用于对维护的数字作出变更，并将结果记录到日志，如“1”、”3“、“6”等。从这个例子中，我们也知道了，为什么顺序是副本中保持一致性的关键因素，因为对一个加法和乘法操作调整了执行顺序将得到不一样的结果。</p>
<p>分布式日志可以被视为共识问题模型的一种数据结构，毕竟日志代表了一系列要追加的下一个值的决定。你必须要认真一点才能在Paxos算法中看到日志的身影，尽管日志是它们最常见的应用。Paxos通常被作为”multi-paxos”协议的一个扩展存在，把日志作为一系列共识问题的建模，日志中的每个槽都有一个值。但日志在ZAB、RAFT和Viewstamped Replication这些其他的协议中更加显而易见，在这些协议里面，直接作为维护分布式、一致性的日志的模型存在。</p>
<p>我有点怀疑我们的对这个的看法一定程序上受到了历史进程的影响，也许是由于过去几十年里，分布式计算理论的发展领先于其实际的应用。实际上，共识问题被过于简单化了。计算机系统几乎不会需要决定单个值，而几乎总是处理一系列请求。所以日志不能认为是一个简单的单值寄存器，而是一个更自然的抽象。</p>
<p>此外，对算法的关注使得系统需要的底层日志抽象变得模糊。我个人认为，我们最终将更加关注于作为商品化模块存在的日志，而不是它的实现，正如我们经常讨论哈希表而不需要了解它是使用的线性探测的杂音哈希还是其他，这种细节。日志将成为商品化接口的存在，同时许多算法和实现竞争以提供最好的保证或者其他可选的特性。</p>
<h4 id="变更日志：表和事件的二象性"><a href="#变更日志：表和事件的二象性" class="headerlink" title="变更日志：表和事件的二象性"></a>变更日志：表和事件的二象性</h4><p>回到数据库的讨论，在变更日志和表之间，有着有趣的二象性。日志类似于借贷和银行处理的列表，数据库表则是当前所有账号的余额，如果你有变更日志，你可以应用这些变更日志，以创建拥有当前状态的表，这个表记录了每条记录某个特定时间的最新的状态。从某种意义上说，日志是更加基础的数据结构，除了创建原始表，你还可以将其转换并创建各种类型的派生表（是的，对于非关系数据库使用群体，数据库表也是关键的数据存储）。</p>
<p>这个过程也是可逆的，如果你有一张要更新的表，你可以记录这些变更，然后发布所有对这个表状态变更的日志。变更日志就是需要用于支持近实时副本的。在这个场景中，你可以看到表和事件的二象性：表支持的静态数据，而日志记录了变更。日志的魅力在于，它不仅拥有了数据库表最终版本的内容，也允许你通过它重建其他任何可能存在的版本，它就相当于数据库表中每个旧版本的备份集合。</p>
<p>这可能让你想起版本控制系统，版本控制系统和数据库系统有着非常密切的关系，版本控制解决了分布式系统必须解决的一个非常相似的问题：管理分布式的、并发的状态变更。一个版本控制系统建模的是补丁序列，而那实际上是日志。你检出了当前代码的一个快照，那其实类似于数据库表，你会注意到，在版本控制系统中，复制是通过日志完成的，就像是在其他有状态的分布式系统一样：当你更新时、也就是拉取补丁并将补丁应用到你当前的版本。</p>
<p>有些人最近从销售日志数据库的公司Datomic那里看到了这样一些想法，这个<a href = "https://www.youtube.com/watch?v=Cym4TZwTCNU">视频</a>比较好的看到了他们是如何应用这些想法的，这些想法并不是专属于这个系统的，在过去十年里，他们很好地贡献了一部分分布式系统和数据库的文献。</p>
<p>这节内容可能有一些理论化了，别沮丧，马上就会有实操了。</p>
<h4 id="接下来的内容"><a href="#接下来的内容" class="headerlink" title="接下来的内容"></a>接下来的内容</h4><p>在文章的剩余内容，我将尝试讲述日志在分布式内部实现和抽象分布式模型之外的好处。这包括了：</p>
<ol>
<li>数据集成。使一个组织中的数据更容易地用在所有存储和处理系统中。</li>
<li>实时灵气处理。计算派生数据流。</li>
<li>分布式系统设计。如何通过集中式日志设计来简化实际的应用系统。</li>
</ol>
<p>这些用法都围绕着日志作为一个单体服务来解决实现。</p>
<p>在每个场景中，日志的好处都来源于日志能提供的简单的功能：生成持久化的、可重放的历史记录。惊讶地是，让多台机器能够以确定的方式并按各自的速度重试历史数据的能力，是这些问题的核心。</p>
<h3 id="第二部分：数据集成"><a href="#第二部分：数据集成" class="headerlink" title="第二部分：数据集成"></a>第二部分：数据集成</h3><p>首先我将说明下“数据集成”指的是什么，以及它为什么重要，然后我们可以发现它是怎么跟日志联系在一起的。</p>
<blockquote>
<p>数据集成正使得一个组织的数据在所有系统和服务中变得可用。</p>
</blockquote>
<p>“数据集成”这个词语并不常见，但我找不到一个更好的词语。大家更熟知的ETL仅仅覆盖了数据集成的一个有限子集——主要在关系型数据仓库使用。但我正在描述的事物更多的可以认为是广泛用于实时系统和处理流的ETL。</p>
<p>在人们对专注于大数据，对大数据大肆宣扬中，你可能很少听到过数据集成，尽管如此，我仍认为“让数据变得可用”这个普通的问题，是一个组织可以关注的最有价值的一个问题之一。</p>
<p>对数据的有效使用遵循了马斯洛的需求层次理论，金字塔的底层部分是获取所有相关的数据，并将其放到一个适用的处理环境中（可以是华丽的实时查询系统，或者仅仅是文件文件和python脚本）。数据需要采用统一建模的方式，使得数据更易于获取和处理。一旦用统一的方式获取数据的基本需求被满足了，接着就可以在这基础上用不同的试进行数据的处理——MapReduce、实时查询系统等。</p>
<p>值得注意的是，在缺少一个可靠和完整的数据流时，Hadoop集群只不过是一个昂贵和难以安装的加热器。一旦数据和处理变得可用，人们就可以更多关注于好的数据模型和一致的易于理解的语义这种更精细的问题上。最后关注点可以转换到更高级的处理上，更好的可视化、报表、算法处理和预测上。</p>
<p>以我的经验，大多数组织在金字塔的底部都有巨大的漏洞，它们缺乏可靠的完整的数据流，而且想要直接跳到先进数据建模技术上。这是本末倒置的。</p>
<p>所以主要的问题是，我们怎么在组织中构建一个可靠的数据流，贯穿在所有的数据系统中。</p>
<h4 id="数据集成：两个难题"><a href="#数据集成：两个难题" class="headerlink" title="数据集成：两个难题"></a>数据集成：两个难题</h4><p>两个趋势使得数据集成变得困难。</p>
<p><strong>事件数据管道</strong></p>
<p>第一个趋势是事件数据的增长。事件数据记录了发生的事情，而不是事物是什么。在网页系统中，指的是用户的活动日志，以及需要可靠操作和监控一个数据中心机器价值的机器事件和统计数据。人们倾向于称它们为日志数据，因为它通常被写到应用日志，但这混淆了形式和功能。数据是现代网站的核心，毕竟谷歌的财富是由点击和展示构建的相关性管道产生的，而这正是事件。</p>
<p>但这并不仅限于网站公司，这仅仅是因为网站公司是完全数字化的，所以它们很容易完成。金融数据一直以来都是以事件为中心的。RFID能将这种根据应用到物理对象上。我们认为，随着传统业务和活动的数据化，这种趋势将继续下去。</p>
<p>这种类型的事件数据记录了发生的事情，并且往往比传统数据库的使用要大上好几个数量级。这对处理有着巨大的挑战。</p>
<p><strong>专用数据系统的兴起</strong></p>
<p>第二个趋势来自于专用数据系统的兴起，这些系统在过去5年变得非常受欢迎并且是可以免费获取的。专用的系统用于OLAP、搜索、简单的在线存储、批处理、图分析等等。</p>
<p>更加多样化的更多数据，以及希望将这些数据用于更多系统的需求，导致了巨大的数据集成问题。</p>
<h4 id="日志结构化的数据流"><a href="#日志结构化的数据流" class="headerlink" title="日志结构化的数据流"></a>日志结构化的数据流</h4><p>日志是在系统之间处理数据流的自然的数据结构。其中的秘诀非常简单，获取所有组织的数据，并将其放到一个用于实时订阅的日志中心。每一个逻辑数据源都可以用自己的日志作为模型。一个数据源可以是输出事件（比如点击、页面浏览）的应用，或者是可以修改的数据库表。每个订阅系统都尽可能快地从日志读取，应用每一条新记录到自己的存储系统中，并推进在日志中的位置。订阅者可以是任意一种数据系统——缓存、Hadoop、另一个站点的数据库、搜索系统等等。</p>
<p><img src="http://storage.laixiaoming.space/blog/log_subscription.png" alt="img"></p>
<p>例如，日志概念为每个变更提供了逻辑时钟，每个订阅者的状态都可以被探测到。这使得彼此间推断不同的订阅者状态变得简单，因为它们每个都有着自己的读取位置。</p>
<p>为了让讨论更具体，举个简单的例子，假使有一个数据库和几个缓存服务器，日志则提供了一种方式来同步更新到所有的系统，并且推断出每个系统所处的时间点。我们往日志写入了一条新记录，然后从缓存中读取，如果我们希望保证不读取到旧数据，我们需要确保不会从任何一个在复制上没跟上最新数据的缓存中读取。</p>
<p>日志也可以作为一种缓冲，使数据的产生和消费异步。有许多原因使得这点非常重要，尤其是当有多个订阅者以不同的消费速率进行消费的时候。这意味着订阅者可能崩溃或者停机维护时，并在恢复的时候赶上来：订阅者以自己控制的速度进行消费。一个批处理系统，如Hadoop或者是一个数据仓库，每小时或每天消费一次数据，但一个实时查询系统却可能是需要即时消费的。原始数据源和日志都不知道各种目标数据系统，因此消费系统可以在不做变更的情况下在管道中被添加进来或移除出去。</p>
<p>特别重要的是，目标系统仅仅知道日志的存在而不知道源系统的任何细节。消费系统也不需要去关注数据是来源于数据库管理系统、还是新型的键值存储系统，抑或是在没有任何实时查询系统的情况下生成的。这似乎是一个很小的知识点，实际上却非常重要。</p>
<p>在这里我使用了“日志”这个词而不是“消息系统”或者“发布订阅”，这里因为这在语义上是更加准确的，是对你在实现数据复制支持时所需要的事情的更加准备的描述。我发现“发布订阅”只是表达出了消息的间接寻址。如果你比较任意两个具有发布订阅功能的消息系统，你会发现它们承诺的是完全不同的事情，在这个领域里面，大多数模型都是没有用处的。你可以认为日志是一种有着持久化保证和强有序语义的消息系统。在分布式系统中，通信模型也叫原子广播。</p>
<p>值得强调的是，日志仍然是基础设施，它并不是掌握数据流故事的结束：故事剩余部分围绕着元数据、模式、兼容性和处理数据结构和深化的所有细节来展开。但是，除非有一种可靠的、通用的处理数据流的机制，否则语义的细节仍然是次要的。</p>
<h4 id="在领英"><a href="#在领英" class="headerlink" title="在领英"></a>在领英</h4><p>随着领英从中心化的关系型数据库过渡到分布式系统，我注意到数据集成的问题也在逐渐演变。</p>
<p>目前我们的数据系统主要包括：</p>
<p>搜索、社交图谱、Voldemort(键值存储)、Espreso(文档存储)、推荐引擎、OLAP查询引擎、Hadoop、Terradata、Ingraphs(监控图表和监控服务)</p>
<p>以上这些都是特定的分布式系统，在特定的领域提供了高级的功能特性。</p>
<p>使用日志作为数据流的想法在我来到这里之前就已经出现了。我们开发的最早的一个基础设施之一是一个被称为databus的服务，它在我们早期的Oracle表上提供了一种缓存抽象，以扩展数据库更改的订阅，给我们的社交图谱和搜索索引提供输入数据。</p>
<p>我将简单介绍一些历史以提供讨论的上下文。在我们发布了自己的键值存储系统之后，大约是2008年，我开始参与这个项目。我的下一个项目是尝试部署配置一个可用的Hadoop，并将我们的推荐处理迁移到那里。由于缺乏这方面的经验，我们很自然的花了几周时间来完成数据的导入导出，剩下的时间则用来实现复杂的预测算法，就这样我们开始了长途跋涉。</p>
<p>我们最初的计划是将数据从现有的Orcale数据仓库中删除。但是我们首先发现快速将数据从Oracle中取出是一门黑暗的艺术。更糟糕的是，数据仓库的处理过程并不适用于我们为Hadoop设计的生产批处理，大部分的处理都是不可逆的，并且与要生成的具体报表相关。我们最终避免了数据仓库，转而直接使用源数据库和日志文件。最后，我们实现了另一个管道，将数据加载到键值存储，以提供结果。</p>
<p>这种简单的数据复制最终成为了原始开发的主要项目之一。糟糕的是，只要在任意时候管道内如果有问题，Hadoop系统也变得毫无用处——在错误的数据上运行了华丽算法只会产生更多的错误数据。</p>
<p>虽然我们使用了一种很通用的构建方式，但每一个新的数据源都需要自定义的安装配置。它也被证明是大量错误和失败的根源。我们用Hadoop实现的网站功能开始流行起来，而我们发现有大量对此感觉兴趣的工程师，第个人都许多想要集成的一系列系统，并且想要导入许多新的数据。</p>
<p>有些东西渐渐地清晰了起来。</p>
<p>首先，我们构建的管道，虽然有一些杂乱，但实际上是极有价值的。在一个新处理系统（Hadoop）上让数据变得可用的过程解锁了大量的可能性。在这些数据上做新的计算变得可能，这在过去是很难实现的。许多新产品和分析都来自于将以前锁定在特定系统的多种数据放在一起。</p>
<p>第二，很明显，可靠的数据加载需要数据管道的尝试支持。如果我们获取到了所需要的所有结构，我们可以让Hadoop数据加载变得完全的自动化，因此添加新的数据源或者处理模式的变更不再需要人工的介入——数据会自动的出现在HDFS中，Hive表将会自动地为新的数据源生成合适的列。</p>
<p>第三，我们的数据覆盖率仍然很低。如果你看一下，领英在Hadoop中所有可用的数据的百分比，你会发现它非常不完整。考虑到需要在新数据源上付出大量的努力，让数据变得完整这项工作并不容易。</p>
<p>我们一起在进行的，为每个数据源和目标数据构建一个个性化的数据加载很显然是不切实际的。我们有几十个数据系统和数据仓库，连接这些系统将会导致，在第两个系统之间构建一个个个性化的管道，就像这样：</p>
<p><img src="http://storage.laixiaoming.space/blog/datapipeline_complex.png" alt="img"></p>
<p>需要注意的是，数据是双向流动的，就像许多系统一样（数据库、Hadoop），都需要在来源和目的地之前传输数据。这意味着我们最终在每个系统构建两条管道：一条用于获取数据，另一条用于流出数据。</p>
<p>很显然，这需要大批的人来做这个事情，而且是不可行的。当接近全连接时，我们将得到O(N2)条管道。</p>
<p>为了避免这个，我们需要像这样通用的东西：</p>
<p><img src="http://storage.laixiaoming.space/blog/datapipeline_simple.png" alt="img"></p>
<p>我们需要尽可能地，将每个消费者从数据源中隔离开来。他们应当和一个数据仓库集成，并且可以从中获取所有的数据。</p>
<p>在这种方式下，添加一个新的数据系统——数据源或者数据目的地——可以仅仅通过连接到这单个管道上实现集成，而不需要跟每个每个数据消费者连接。</p>
<p>这种经历让我专注于构建Kafka，以将我们在消息系统中看到的内容与流行在数据库和分布式系统内部的日志概念相结合起来。我们冼想要一个可以作为中心管道给所以活动数据服务的东西，并最终用于其他许多用途，包括Hadoop之外的数据、监控数据等等。</p>
<p>在很长一段时间，Kafka是基础设施中独一无二的存在（有人说它很特别）——它不是数据库，也不是日志文件收集系统，更不是传统的消息系统。但最近Amzon提供了一种类似于Kafka的服务——Kinesis。相似之处包括分区处理的方式，数据的持有方式，还有分为高级及初级的消费者API这种奇怪的地方。对此我感到很高兴，你创建了一个好的基础设施的抽象的标识就是，Amazon将其作为了一种服务提供出去。他们对此的看法跟我描述的很相似，它是连接所有分布式系统的管道——RdynamoDB、RedShift、S3等等——同时了作为分布式流处理EC2的基础。</p>
<h4 id="ETL和数据仓库的关系"><a href="#ETL和数据仓库的关系" class="headerlink" title="ETL和数据仓库的关系"></a>ETL和数据仓库的关系</h4><p>让我们来谈下数据仓库，数据仓库是用于支持分析的干净的、集成数据结构的仓库。这是一个非常好的理念。对于不了解数据仓库概念的人来说，数据仓库方法涉及周期性的从源数据库中提取数据，将其转换为可理解的形式，并将加载存入中央数据仓库。集中拥有所有干净的数据的副本，对于数据密集型分析和处理而言是一项非常有价值的资产。在更高层面上，无论你使用传统的数据仓库Oracle，或者是Terada和Hadoop，这个使用方式不会有太大的不同，虽然你可能需要换一下加载和转换的顺序。</p>
<p>包含了清洗、数据集成的数据仓库是一项非凡的资产，但实现这个的机制有一些过时了。</p>
<p>对于一个以数据为中心的组织而言，关键问题是将干净的集成数据联合到数据仓库。数据仓库是批处理查询的基础设施，它非常适用于多种报表和临时分析，特别是当查询涉及到计算、聚合和过滤的时候。但如果批处理系统是唯一一个包含完成数据的仓库，将意味着数据不可用于实时的系统——实时处理、搜索索引 、监控系统等等。</p>
<p>在我看来，ETL包括了两件事情。首先，它是数据提取和清洗的过程，本质上是释放被锁在组织中的各类系统中的数据，并去除特定系统的约束。第二，数据被异构用于数据仓库查询（例如适配关系型数据库系统，强制使用星形或雪花型，可能打破原有的高性能的列格式）。同时做好这两件事情不容易。这些规整的数据仓库可以用于实时的或低延时的处理，也可以用于其他实时的存储系统中的索引。</p>
<p>我认为这具有使数据仓库ETL更加可扩展的额外的好处。典型的问题是，数据仓库团队要收集和处理其他团队的所有的数据。两边的收益是不对称的，数据的生产者常常并不知晓数据仓库中数据的使用，最终创建了很难获取或者转换成有用格式的数据。当然，中心团队也无法扩充以匹配于其他组织的发展速度，以致于数据的覆盖率问题质量不一的，数据的流向也是脆弱的，改进也是缓慢的。</p>
<p>一个更好的方法是，拥有一个有着为额外数据定义的良好API的中心管道，日志。集成这个管道并提供规整的、良好结构的数据由数据的生产者负责。这意味着，作为系统设计和实现的一部分，他们必须考虑获取数据和生成用于传输到中心管道的良好结构格式的数据这种问题。新的存储系统的加入对于数据仓库团队而言没有任何影响，因为它们具有集成的中心点。数据仓库团队仅仅需要处理从中心日志加载结构化数据这种简单的问题，并将特定的转换格式传输到它们的系统。</p>
<p><img src="http://storage.laixiaoming.space/blog/pipeline_ownership.png" alt="img"></p>
<p>当一个人考虑采用传统数据仓库之外的其他数据系统时，组织上的可伸缩性变得尤为重要。例如，想在组织的完整数据上提供搜索的能力，或者想为实时趋势图的数据流提供监控和告警。在这些场景下，传统数据仓库的基础设施或者Hadoop都将变得不可用。更糟糕的是，被构建用于支持数据库加载的ETL处理管道也不再作用于其他系统，构建这些基础设施的工作量跟采用一个数据仓库一样大。这似乎是不可行的，这也解释了为什么大多数组织不具备他们在数据上的一些简单可用的能力。相反的，如果一个组织构建了统一的，良好结构的数据，那么让任意一个新系统完全获取所有的数据仅仅需要在管道上做一下集成的工作。</p>
<p>关于数据规整化和转换在哪里完成，这个架构了有着不同的观点：</p>
<ol>
<li>在添加数据到公司的全局日志之前，由数据的生产者完成。</li>
<li>由日志的实时转换器完成（产生一个新的格式化的日志）。</li>
<li>由加载到目标数据系统进程的一部分完成。</li>
</ol>
<p>最好的模型是数据发布到日志之前由数据的生产者完成数据的规整化。这意味着确保了数据处理标准形式，并且不需要包含任何由生成该数据的特定代码产生的或者存储系统维护的无意义的内容。这些细节可以很好地被生成数据的团队处理，因为他们是最了解他们数据的人。这个阶段所使用的任务逻辑都应该是无损的和可逆的。</p>
<p>任何可以实时完成的具有附加价值的转换都应该在原始日志上的后处理去执行。其中包括事件数据处理成会话，或者其他派生字段的添加。原始日志仍然是可用的，但实时处理将产生包含增强数据的派生日志。</p>
<p>最后，只有针对目标系统的聚合操作才应该被加到加载流程中。这些操作可能包括将数据转换为特定的星形或者雪花模式，用于在数据仓库中分析和报告。由于这个阶段，一般最自然的映射到传统的ETL流程，现在基于一种更规整和统一的数据流集去处理，因此也会更简单的。</p>
<h4 id="日志文件和事件"><a href="#日志文件和事件" class="headerlink" title="日志文件和事件"></a>日志文件和事件</h4><p>让我们再聊聊这种架构的附加好处，它支持解耦的事件驱动系统。</p>
<p>在Web行为，获取活动数据的典型方式是将其记录到文件文件，这些文本文件可以被放到数据仓库或者Hadoop，用于聚合和查询。这存在的问题跟所有批处理ETL一样，它耦合了数据仓库数据流的能力和处理调度。</p>
<p>在领英，我们是以日志中心的方式构建的事件数据处理。我们正使用Kafka伪中心的、多订阅者的事件日志。我们定义了数百种事件类型，每种事件类型都有着特定类型操作的特定属性，这涵盖了从页面浏览、展示、搜索、到服务调用和应用异常等各种情况。</p>
<p>为了进一步理解这一种优势，想象一下有这么一种简单事件，在工作职位页面上展示职位信息。职位页面应该仅仅包含展示职位信息的逻辑。然而，在一个相当动态的网站上，这很容易变成额外的与工作无关的逻辑的点缀。例如，假设我们需要集成以下系统：</p>
<ol>
<li>将数据发送到Hadoop和数据仓库，用于离线处理。</li>
<li>计算页面浏览量，确保浏览者不是内容爬虫的一种。</li>
<li>聚合浏览信息，并在职位发布者的分析页面展示 。</li>
<li>记录浏览信息，确保对用户的职位推荐合适进行展示（我们不希望一次又一次地展示相同的职位信息）。</li>
<li>推荐系统需要记录浏览，以便正确追踪职位的流行性。</li>
<li>等等</li>
</ol>
<p>用不了多久，展示一个职位这种简单的动作就会变得十分复杂。当我们的职位要支持在其他终端上展示——手机应用等——这样的逻辑必须要延续下来，复杂度也将上升。更糟糕的是，我们需要与之交互的系统是错综复杂的，负责展示职位工作的人也需要了解其他系统和特性，并确保正确的集成。这里只是简单的描述了该问题，实际的应用将会更加复杂。</p>
<p>事件驱动风格提供了一种简化的方法。职位展示页面只负责展示职位并记录职位的相关属性信息，浏览的人或者关于职位展示的其他有用的信息。每一个其他对这个感兴趣的系统——推荐系统、安全系统、职位发布者分析系统以及数据仓库，都只需要订阅这些信息并且自己处理。展示的代码并不需要关注其他的系统，如果一个新的数据消费者被添加进来也不需要作出改变。</p>
<h4 id="构建可伸缩的日志"><a href="#构建可伸缩的日志" class="headerlink" title="构建可伸缩的日志"></a>构建可伸缩的日志</h4><p>当然，将发布者和订阅者分离开来并不是什么新鲜事。但如果你想维护一个提交日志，该日志作为消费者规模网站上所有活动的多订阅者实时日志，那么可扩展性将是一个主要的挑战。如果我们不能构建一个快速的、低成本的，足够可扩展的日志，使其在大规模上可行，那么使用日志作为统一集成机制不过是一个更美好的幻想。</p>
<p>人们普遍认为日志是缓慢的、高度抽象的（并且通常只把它与元数据类的使用方式联系在一起（Zookeeper））。但有了一个记录大数据流的深思熟虑的实现，打破了这一看法。在领英，目前我们通过Kafka每天写入超过600亿的消息（如果算上数据中心之间镜像的消息，这个数将是数千亿）。</p>
<p>我们在Kafka中使用了一些技巧，以支持这种规模：</p>
<ol>
<li>日志分区</li>
<li>通过批量读写优化了吞叶率</li>
<li>避免了无意义的数据复制</li>
</ol>
<p>为了支持水平扩展，我们将日志进行了分区：</p>
<p><img src="http://storage.laixiaoming.space/blog/partitioned_log.png" alt="img"></p>
<p>每个分区都是一个完全有序的日志，但在分区之间没有全局的顺序（除非在你的消息中可能包含了墙上时钟时间）。消息被分配到一个特定的分区是由写入者决定的，大多数使用者会选择使用某种类型的值来分区（比如用户id）。分区允许日志追加，在分片之间无需协调即可发生，并且允许系统的吞吐量随着Kafka集群大小而线性扩展。</p>
<p>每个分区都可以通过配置副本数量进行复制，每个副本都有一个副本日志完全一样的拷贝。在任意时候，其中的一个副本将作为leader，如果leader发生故障，剩余的其中一个副本将接替成为leader。</p>
<p>在分区之间缺乏全局顺序确实是一个限制，但我们并未发现这是一个主要的限制。确实，与日志进行交互的通常是成百上千的独立线程，因为在这种情况下讨论它的全局顺序是没有意义的。代替的，我们保证了每个分区的顺序，并且Kafka保证了追加到特定分区的顺序将根据发送者发送的顺序进行传送。</p>
<p>日志，就像文件系统，对于顺序读写可以方便地优化。日志可以把小的读写合并成更大的、更高吞吐量的操作。Kafka致力于这种优化。这种批量操作存在于从客户端发送数据到服务端时，写磁盘时、服务间的复制、将数据传送给消费者时，以及确认提交的数据时。</p>
<p>最后，Kafka使用了简单的二进制格式维护内存日志、磁盘日志、网络中数据传输的日志。这允许我们可以使用包括“零拷贝”在内的大量优化机制。</p>
<p>这些优化的积累起来的效应就是，你通常可以以磁盘或网络支持的速率进行读和写，即使维护的数据集大大超出了内存的大小。</p>
<p>这篇文章并不是主要讨论Kafka的，在这里我不再讨论他们的细节。你可以通过领英的这篇文章和Kafka的设计这篇文章阅读更多的细节。</p>
<h3 id="第三部分：日志和实时流处理"><a href="#第三部分：日志和实时流处理" class="headerlink" title="第三部分：日志和实时流处理"></a>第三部分：日志和实时流处理</h3><p>到目前为止，我只讲述了在系统之间拷贝数据的一种奇特的方式。但在存储系统之间传输字节并不是故事的结束。事实证明，日志是流的另一个说法，日志是流处理的核心。</p>
<p>但等会，什么是流处理？</p>
<p>如果你是上世纪90年代或21世纪初数据库文献或者成功了一半的数据基础设施产品的粉丝，那么你可以会把流处理与创建SQL引擎或者事件处理驱动处理的“盒子和箭头”界面相关联起来。</p>
<p>如果你关注开源数据系统的爆炸性增长，你可能会将流处理与这个领域下的一些系统相关联起来——如Storm、Akka、S4、Samza。但很多人会认为这是一种异步消息处理系统，与集群感知的RPC层不同（事实上，这些领域的一些东西确实如此）。</p>
<p>这些观点都有些局限。流处理与SQL并无关联，也不局限于实时处理。本质上，并没有什么理由不能使你不能用多种语言来处理昨天或一个月前的数据流来表达计算。</p>
<p>我将流处理视为更广泛的东西：不断用于数据处理基础设施。我认为计算模型可以像MapReduce或其他分布式处理框架一样通用，但他同时具有生产低延迟数据的能力。</p>
<p>处理模型的真正驱动力是数据收集的方式。数据被批量收集，也自然被批量处理。当数据不断地被收集，也自然而然地被不断地处理。</p>
<p>美国的人口普查给批量数据收集提供了一个很好的例子。人口普查会定期开始，通过挨家挨户的蛮力调查和统计美国公民。这在1790年人口普查刚开始的时候很有用。当时的数据收集是面向批处理的，它涉及到骑马走访并在纸上记录，然后将这一批记录运输到中央地方，在那里人为进行汇总。现在，当你描述人口普查过程时，会好奇我们为什么不维护出生和死亡的记录，并借此连续地或以任何所需要的粒度得到人口的数量。</p>
<p>这是一个极端的例子，但许多数据传输过程仍然依赖于定期的数据下载、批量的数据传输和集成。处理批量转储的方式自然是批处理。随着这些过程被连续的数据流所取代，人们自然会开始转向连续处理，以平衡处理所需要的资源，并减小延迟。</p>
<p>例如，在领英，几乎没有批量数据收集。大多数数据都是活动数据或者数据库的变更，这两种数据都是连续发生的。事实上，你想到任何业务，潜在的页面几乎都是一个连续的过程——实时发生的事件，正如Jack Bauer说的那样。当数据被批量收集时，几乎总是因为人为的步骤、或缺乏数字化、或非数字化过程自动化遗留下的历史问题。数据传输并对数据作出回应依赖于邮件或者人工处理时，通常是非常慢的。自动化的初步尝试问题保留了原始流程的形式，因此这种方式通常持续很长时间。</p>
<p>每天运行的生产“批量”处理作为通常是在模仿一种以一天为窗口大小的连续计算。底层数据当然问题在不断变化的。在领英，这实际上很常见（并且在Hadoop中使他们工作的机制非常复杂），我们实现了一个完整的框架来管理增量的Hadoop工作流程。</p>
<p>从这个角度看，很容易对流处理产生不同的认识：它仅仅处理包含了时间概念的底层数据，而不需要静态的数据快照，因此它可以根据用户控制的频率输出数据，而不是等待数据集到达后再产生输出。从这个角度上看，流处理是广义上的批处理，并且鉴于实时数据的流行，这种批处理变得非常重要。</p>
<p>那么，为什么传统的流处理只在小范围流行呢？我们认为最大的原因是实时数据收集的缺乏，使得连续处理更多停留在学术研究的层面 。</p>
<p>我认为，是否缺乏实时数据的收集，决定了商业流处理系统的命运。他们的客户仍然在使用基于文件的每天的批处理来完成ETL和数据集成。建设流处理系统的公司专注于提供流处理引擎来连接实时数据流，但结果是实际上那个时候很少人拥有实时数据流。事实上，在领英的早期职业生涯中，有一家公司向我们推销一个非常酷炫的流处理系统，但由于那时我们所有的数据都是小时被收集到文件上，我们能做到的最好使用场景是在每小时的最后把这些文件输入到流处理系统中，他们意识到这是一个普遍问题。这个例子实际上已经证明这个规律：在金融领域，流处理已经取得了一些成功，实时数据流已经成为了常态，而处理成为了瓶颈。</p>
<p>即使在拥有完善的批处理生态系统的前提下，我仍然认为流处理作为一种基础设施的应用也相当广泛。我认为它填补了实时请求/响应服务和离线批处理之间的基础设施缺口，对于现代互联网公司来说，我认为25%的代码可以划分到这个范畴。</p>
<p>事实证明，日志解决了流处理中的一些棘手的技术问题，正如我所描述的，但它解决的最大的问题是，使数据在实时多订阅者中变得可用。对于那些对更多细节感兴趣的人，我们开源了Samza，一个目标明确基于这些思想构建的流处理系统。我们在相关文档中，描述了大量这些应用的细节。</p>
<h4 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h4><p><img src="http://storage.laixiaoming.space/blog/dag.png" alt="img"></p>
<p>流处理最有趣的方面与流处理系统的内部无关，而是与它如何扩展我们早期对输入数据的看法的有关。我们主要讨论了主数据的输入和日志——在多个应用的执行过程中产生的事件和数据行。但流处理也允许我们包含了由其它数据计算出的数据。对消费者而言，这些派生的数据与计算得到它们的原始数据没有什么不一样。这些派生的数据可以任意的封装组合。</p>
<p>让我们深入研究一下，出于我们的目的，一个数据流任务，是指从日志中读取数据，并将输出写到日志或其他系统。用于输入和输出的日志将这些处理流程连接成一个流程图。实际上，以这种方式使用中心化的日志，你可以将所有的组织数据图、转换和流向视为一系列写入它们的日志和流程。</p>
<p>流处理器根本不需要花哨的框架：它可以是读写日志的一个或一组处理过程，是可以用于帮助管理流程代码的额外的基础设施或支持。</p>
<p>在集成中，日志的目标是双重的。</p>
<p>首先，日志让每个数据集都支持多个订阅者，并且是有序的。回顾一下前端的“状态副本”，以便记住顺序的重要性。为了让这个更准确，假使有一个数据库的更新流——如果我们在我们的处理中对同一条记录的两条更新作重排序，我们可能会产生错误的最终结果。这种顺序比TCP等提供的更加持久，因为它不仅限于单点对点的链接，而且在处理失败和重新连接后仍然存在。</p>
<p>第二，日志为进程提供了缓冲。这一点非常基础。如果是以非同步的方式处理的，很有可能会发生上游数据生成作业的速度会下游作为消费的速度更快。当这种情况发生时，处理必须阻塞、缓冲或丢弃数据。丢弃数据可能不是一个可行的选择，阻塞可能会造成整个处理陷入停顿。日志充当了非常大的缓冲区，它允许进程重启或者失败，而不会造成其它处理流程中其他部分的处理缓慢。当将这种数据扩展到更大的组织时，这种隔离非常重要，处理是由许多不同的团队创建的作业进行的。我们不能让一个失败的作业造成背压，导致整个处理流的停止。</p>
<p>Storm和Samza都是以这种风格构建，并且可以使用Kafka或者其他同类型的系统作为他们的日志。</p>
<h4 id="有状态的实时流处理"><a href="#有状态的实时流处理" class="headerlink" title="有状态的实时流处理"></a>有状态的实时流处理</h4><p>一些实时流处理只是无状态的记录转换，但许多用法更多侧重于流中窗口内的计数、聚合衙连接操作。例如，有人想要通过用用户点击的信息来丰富事件流（比如点击流）——实际上是将用户的点击流添加到用户数据库。通常，这种处理最终需要处理器维护某种状态：例如，当计数的时候，你需要维护当前的数量，如果处理器本身出问题了，这种状态要怎么维护正确呢？</p>
<p>最简单的做法是在内存中维护状态，然而如果处理器崩溃了，将会丢失中间状态。如果状态仅在窗口内维护，处理可以回退到日志中窗口开始的位置。然而，如果要在一个小时内计数，这可能是不可行的。</p>
<p>将所有状态简单地存储在远程存储系统中，并通过网络连接到该存储系统是一种可行的方法。这种方式的问题是缺少了数据的局部性，以及网络往返次数多。</p>
<p>如何支持像数据库表这样的东西，它可以跟我们的处理一样被分区？</p>
<p>当我们回顾表和日志的对偶性时，这给我们提供了可以将流转换为可以与处理共存的表的工具，同时也是一种解决表容错的机制。</p>
<p>一个流处理器可以在本地表或者索引维护它的状态——bdb、leveldb甚至是一些更加罕见的组件，比如Lucene或者fastbit索引。存储的内容来自于其输入流（可能首先应用了一些转换）。流处理器可以将其本地索引的变更日志记录下来，以便可以在崩溃和重启时恢复其状态。这种机制允许一个通用的方法来保持与输入流数据本地共分区的任意索引类型的状态。</p>
<p>当处理失败的时候，可以从变更日志中恢复。日志是每次备份时，本地状态到增量数据集的转换。</p>
<p>这种状态管理的方式的优雅之处在于，处理器的状态也作为日志来维护。我们可以将这个日志视为数据库表的更改。事实上，处理器同时维护了类似于联合分区表的东西。由于状态本身就是日志，其他处理器也可以订阅它。当处理的目的是更新最终状态，并且状态是处理的自然输出时，这实际上是非常有用的。</p>
<p>当出于数据集成的目的，将源于各数据库的日志级合起来时，日志和表的二象性的强大就变得明显了。变更日志可能是从数据库中提取而来的，并被不同的处理器异构成不同格式的索引，以跟事件流进行连接。</p>
<p>我们将在Samza中详细介绍这种状态处理的管理方式，<a href="http://samza.incubator.apache.org/learn/documentation/0.7.0/container/state-management.html">这里</a>有一些实践的示例。</p>
<h4 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h4><p><img src="http://storage.laixiaoming.space/blog/log_compaction_0.png" alt="img"></p>
<p>当然，我们不可能保存所有时间段内所有状态变更的完整的日志。除非想要使用无限的空间，否则日志是必须要清理的。我将具体谈一些关于Kafka在这方面的实现。在Kafka中，清理有两种策略，这取决于数据是否包含键或者事件数据。对于事件数据，Kafka支持保留一个时间窗口的数据。通常，这个时间窗口被配置为几天，但这个窗口也可以基于时间或空间定义。对于有键值的数据，完整日志的一个很好的方面是你可以通过重放日志的方式来重建源系统的状态（可能在另一个系统中重建）。</p>
<p>然而，保留完整的日志会随着时间的推移，占用起来越多的空间，重放也将花费起来越多的时间。然而，在Kafka中，我们支持另一种保留方式。代替简单地丢弃老的日志，我们删除淘汰的记录——比如那些主键有了更新的记录。通过这种方式，我们仍然能保证日志包含源系统的完整的备份，虽然不再能重建源系统的所有旧的状态，而是保留了最新的状态。我们称这个特性为日志压缩。</p>
<h3 id="第四部分：系统构建"><a href="#第四部分：系统构建" class="headerlink" title="第四部分：系统构建"></a>第四部分：系统构建</h3><p>我最后想讨论的是日志在在线数据系统的数据系统设计中扮演的角色。</p>
<p>这里有一个类比，日志在分布式数据库的数据流中扮演的角色和和它在一个更多的组织的数据集成中扮演的角色。在这两种情况下，它都是负责数据流、一致性和恢复。毕竟，一个组织如果不是一个复杂的分布式数据系统，那它是什么呢？</p>
<h4 id="分解？"><a href="#分解？" class="headerlink" title="分解？"></a>分解？</h4><p>如果你换个角度，你可以将整个组织的系统和数据流看成是一个整体的分布式系统。你可以将所有的独立的面向查询的系统（Redis、SOLR、Hive表等等）看作是你的数据的专门的索引。你还可以将流处理系统看作是一个成熟的触发器和视图实现机制。我注意到传统的数据库人群非常喜欢这种观点，因为他们终于能解释通，所有的这些不同的数据系统到底是用来做什么的——他们仅仅是不同的索引类型。</p>
<p>不可否认的是，数据库类型正爆发式增长，但实际上，其复杂性一直存在。即便在关系型数据库的盛行的时期，组织也拥有大量的关系型数据库。因为大型机，所有的数据实际都存放在同一个位置，所有可能并不存在真正的数据集成。将数据独立拆分到多个系统有许多原因：数据伸缩性、地理位置、安全性以及性能隔离是最常见的。但这些都可以通过一个好系统来解决：组织通过单个Hadoop集群保存所有的数据，并服务于众多的多样化的用户群体是可能。</p>
<p>在转向分布式系统的过程中，已经有了一种可能的数据处理简化：将大量的各个系统的小实例聚合到一个大的集群里。许多系统不足以做到这些：它们缺乏安全性、或不能保证性能隔离、或不具备良好的伸缩性。但每个问题都是可以解决的。</p>
<p>在我看来，不同系统大量涌现的原因是构建分布式数据系统的困难性。通过将系统裁减到一个单一的查询类型或用例上，每个系统都可以回到自己范围内可以做到的事情上来。但运行所有这些系统还是太复杂了。</p>
<p>未来可能会有3种可能的方向。</p>
<p>第一种可能性是现状的延续：系统之间的隔离在往后很长的一段时间内都将保持不变。这可能是因为分布式系统构建难度太大，或者是因为这种专业化使得每个系统的便利性和功能水平达到一个新的高度。只要这种情况持续下去，数据集成问题将是数据成功使用中最重要的问题之一。在这种情况下，用于集成数据的外部日志将非常重要。</p>
<p>第二种可能性是统一合并一个具有足够通用性的系统，开始将所有不同的功能合并到一个单独的超级系统中。这个超级系统从表面上看可能像一个关系型数据库，但在组织中的使用将大大不同，因为你只需要一个大的系统而不是无数个小的系统。在这样的世界里，除了系统内部不存在真正的数据集成问题。我认为，构建这样的一个系统在实践上的困难性使得其不太可能发生。</p>
<p>还有另外一种可能的结果，作为一个工程师，我觉得它很有吸引力。新一代的数据系统最有趣的一方面是它几乎都是开源的。开源创建了一个可能性：数据设施可能被分解成一系列的服务和面向应用的系统api。你已经在Java的技术栈上看到了，正一定程序地出现这种情况：</p>
<ul>
<li>Zookeeper处理了系统协调的很多问题（或者有来自于像Helix或者Curator一些的高级抽象）。</li>
<li>Mesos和YARM处理了虚拟化和和资源管理。</li>
<li>像Lucene和LevelDB的嵌入式类库充当了索引。</li>
<li>Netty、Jetty和像Finagle和rest.li这种高级别的封装处理远程的通信。</li>
<li>Avro、Protocol Buffers、Thrift等等其他的类库处理了序列化。</li>
<li>Kafka和Bookepper提供了备份日志。</li>
</ul>
<p>如果你把上面的这些放一起，稍微观察一下，会发现它看起来就像是分布式数据工程中的“乐高”版本。你可以将这些零件放在一起，创造大量的可能的系统。这显然不是一个与终端用户相关的故事，他们可能更多关心api而不是实现，但在一个更加多样化和模块且持续演进的世界中，这可能是一条通往实现单个系统的简单性的一条路径。如果因为可靠的、灵活的构件出现，而使得分布式系统的实现时间从年缩减到周，聚合形成单一的整体的系统的压力将会消失。</p>
<h4 id="日志在系统架构中的地位"><a href="#日志在系统架构中的地位" class="headerlink" title="日志在系统架构中的地位"></a>日志在系统架构中的地位</h4><p>假使存在外部日志的系统允许每个系统抛弃自身的复杂性，转而依赖于共享日志。以下是我们认为日志可以做的事：</p>
<ul>
<li>通过对节点并发的更新进行排序，处理数据一致性（无论是最终的还是实时的）。</li>
<li>在节点之间提供节点的副本。</li>
<li>为写入者提供“提交”的语义（比如，只有在你的写入被保证不会丢失的情况下确认）。</li>
<li>提供给外部的本系统数据的订阅。</li>
<li>对于丢失数据的失败的副本或者新的副本，提供可恢复的能力。</li>
<li>在节点之间处理数据的重平衡。</li>
</ul>
<p>这实际上是分布式系统所做工作中的一个重要部分。实际上，剩余的大部分工作都与最终面向客户端的查询api和索引策略有关。这确实各个系统之间应该有所不同的部分：例如一个全文检索可能需要查询所有的分区，但通过主键的查询可能仅仅需要查询一个为该键服务的单个的节点。</p>
<p>这是它的工作原理。系统被分为两个逻辑部分：日志和服务层。日志顺序记录了状态的变更。服务节点存储了需要为查询服务的索引（比如，一个键-值存储系统可能有像btree或者sstable的事物、一个有着倒排索引的搜索系统）。写操作可能是直接写日志，虽然他们可能被服务层代理。写日志会产生一个逻辑时间戳（日志中的索引）。如果系统被分区了，日志服务节点将有相同的分区数量，虽然他们可能有不同的机器数量。</p>
<p><img src="http://storage.laixiaoming.space/blog/system.png" alt="img"></p>
<p>服务节点订阅日志，并且尽可能快地以存储的顺序应用更新到它的本地的索引。</p>
<p>客户端可以提供写入的时间戳作为查询的一部分，从任意节点获得“读取你写入的”的语义——接收到该查询请求的服务节点，将对所需的时间戳和本地的索引进行比较，必要时会延长请求，直到索引至少抵达该时间点，以避免提供了旧的数据。</p>
<p>服务节点可能会或可能不会感知master身份或leader选举。对于许多简单的用例，服务节点可以完全不需要leader，因为日志是事实之源。</p>
<p>分布式系统中必须要做的更棘手的事情之一是处理恢复失败的节点或者将分区从一个节点转移到另一个节点。一个典型的方案是，仅保留一个固定窗口的数据，并把这个数据和分片中存储的快照结合起来。同样地，也可以保留数据完整备份的日志，并自行进行垃圾回收。这把特定系统的服务层的大量的复杂性移到了通用的日志层。</p>
<p>有了日志系统，你将得到了一个针对数据存储内容的成熟的订阅api，通过通过ETL传输到其他系统。</p>
<p><img src="http://storage.laixiaoming.space/blog/full-stack.png" alt="img"></p>
<p>注意，这样一个以日志为中心的系统是怎么立即成为在其他系统中处理和加载的数据流的提供者呢？同样的，一个流处理器可以消费多个输入流，又通过索引其输出的另一个系统服务于他们。</p>
<p>我发现这种对系统分解为日志和查询api的观点非常具有启发性，因为它可以使查询特性从系统的可用性和一致性中脱离出来。我实际上认为，这是一种通过分解系统来理解它们的一种很有用的一种方式，虽然系统并不是以这种方式构建的。</p>
<p>值得一提的是，虽然Kafka和Bookeeper都是一致性日志，但不是必须的。你可以简单将一个Dynamo之类的数据库分解为一个最终一致性的AP日志和一个键-值服务层。这样的日志用起来很灵活，因为它会重传旧消息，并依赖于订阅者来处理（很像Dynamo做的）。</p>
<p>在日志中保留一个单独的副本（特别是完整的副本），在许多人看来是浪费的。事实上，有几个因素使得这个不是一个大问题。首先，日志可以是一种非常高效的存储机制。我们在我们生产的Kafka服务上的每个数据中心都存储了超过75TB的数据。同时有许多服务系统需要更多的内存来高效的服务数据（例如，文本搜索通常问题在内存中进行）。服务也使用优化过的硬件。例如，我们大多数运行中的数据系统基于内存提供服务，或使用固态硬盘。相反，日志系统只进行线性读写，因此它非常乐意使用大型多TB的硬盘。最后，正如上图描述，数据被服务于多个系统，日志的成本也在多个索引中分摊。上面几点使得外部日志的开销相当小。</p>
<p>这正是领英用来构建许多实时查询系统的模式。这些系统从数据库中获取数据（使用Databus作为日志抽象，或者从Kafka中真正的日志中获取），并且在数据流的基础上，提供特定的分区、索引和查询能力。</p>
<p>这是我们实现了搜索、社交图谱和在线分析查询系统的方式。实际上，将单一的数据流复制到多个服务系统用于在线服务是非常通用的做法。事实证明，这是一个极大的简化的假设。这些系统不再需要提供外部写入的api，Kafka和数据库被用于记录系统和通过日志流向恰当的系统的变更流。写入操作在本地被特定分片的节点处理。这些节点机械地将日志提供的数据流记录到自己的存储系统。失败的节点可以通过重放上游的日志来恢复。</p>
<p>这些系统依赖日志的程度各不相同。一个完全可靠的系统可以利用日志作为数据分区、重平衡、一致性的方方面面，以及数据传播。在这样的架构中，服务层保不过是一种缓存，以支持直接写入到日志的特定处理。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>如果你从头一起读到了这里，那么我对日志的理解，你大部分都知道了。</p>
<p>以下是一些你可以想要查阅的有趣的相关资料。</p>
<p>人们会用不同的术语来描述相同的事物，当你从数据库系统到分布式系统、从各企业级的应用软件到开源世界，会感到疑惑。无论如何，在大方向上是有一些共同之处的。</p>
<p>学术论文、系统、讨论和博客：</p>
<ul>
<li>关于<a href = "http://www.cs.cornell.edu/fbs/publications/smsurvey.pdf">状态机</a>和<a href = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.20.5896">主从备份</a>的概述。</li>
<li><a href = "http://research.microsoft.com/apps/pubs/default.aspx?id=66814">PacificA</a>是微信用于实现基于日志的存储系统的通用框架。</li>
<li><a href = "http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/spanner-osdi2012.pdf">Spanner</a>——并不是每个人都喜欢把逻辑时间用于他们的日志。谷歌的最新的数据库学工使用物理时间，并通过把时间戳直接作为区间来直接对时间漂移的不确定性进行建模。</li>
<li><a href = "http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/spanner-osdi2012.pdf">Datanomic</a>：<a href = "https://www.youtube.com/watch?v=Cym4TZwTCNU">解构数据库</a>是Rich Hicky（Clojure的创建者）在它的首个数据库产品的重要陈述。</li>
<li><a href = "http://www.cs.utexas.edu/~lorenzo/papers/SurveyFinal.pdf">在消息传递系统中对方回滚和恢复的调查</a>，我发现这是错误容忍的非常有帮忙的介绍，也是通过日志恢复外部数据库的实际应用的不错的介绍。</li>
<li><a href = "http://www.reactivemanifesto.org/">反应式宣言</a>。我其实并不清楚反应式编程的确切涵义，但是我想它和“事件驱动”指的是同一件事。 这个链接并没有太多的信息，但 Martin Odersky （Scala大拿）讲授的这个课程很精彩。</li>
<li>Paxos!<ul>
<li>原论文在<a href = "http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf">这里</a>。关于作者 Leslie Lamport 发表的这篇论文有个有趣的<a href = "http://research.microsoft.com/en-us/um/people/lamport/pubs/pubs.html#lamport-paxos">历史</a>：他在80年代就发明了这个算法，但直到1998年才发表出论文，原因是评审组不喜欢论文中的希腊寓言，而他又不愿修改。</li>
<li>甚至于论文发布以后，人们还是不怎么理解。Lamport <a href = "http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf">再次尝试</a>，这次甚至包含了一些关于如何在新型自动化计算机上使用的“无趣的细节”。 但算法仍然没有得到广泛的理解。</li>
<li><a hef = "http://www.cs.cornell.edu/fbs/publications/SMSurvey.pdf">Fred Schneider</a>和<a href = "http://research.microsoft.com/en-us/um/people/blampson/58-consensus/Abstract.html">Butler Lampson</a>分别给出了更多细节关于在实时系统中如何应用Paxos。</li>
<li>一些谷歌的工程师总结了他们在Chubby中实现Paxos的<a href = "http://www.cs.utexas.edu/users/lorenzo/corsi/cs380d/papers/paper2-1.pdf">经验</a>。</li>
<li>我发现所有关于Paxos的论文理解起来很痛苦，但是值得我们费大力气弄懂。你不必忍受这样的痛苦了，因为日志结构的文件系统的大师<a href = "http://www.stanford.edu/~ouster/cgi-bin/papers/lfs.pdf">John Ousterhout</a>的<a href = "https://www.youtube.com/watch?v=JEpsBg0AO6o">这个视频 </a>让这一切变得相当的容易。这些一致性算法用展开的通信图表述的更好，而不是在论文中通过静态的描述来说明。颇为讽刺的是，这个视频录制的初衷是告诉人们Paxos很难理解。</li>
<li><a href = "http://arxiv.org/pdf/1103.2408.pdf">使用Paxos来构造规模一致的数据存储</a>。这是一篇很棒的介绍使用日志来构造数据存储的文章，<em>Jun</em> 是文章的共同作者之一，他也是<code>Kafka</code>最早期的工程师之一。</li>
</ul>
</li>
<li>Paxos有很多的竞争者。以下可以更进一步的映射到日志的实施，更适合于实用性的实施。<ul>
<li>由 Barbara Liskov 提出的<a href = "http://pmg.csail.mit.edu/papers/vr-revisited.pdf">视图戳复制</a>是直接进行日志复制建模的较早的算法。</li>
<li><a href = "http://www.stanford.edu/class/cs347/reading/zab.pdf">Zab</a>是Zookeeper所使用的算法。</li>
<li><a href = "http://www.stanford.edu/class/cs347/reading/zab.pdf">RAFT</a>是易于理解的一致性算法之一。由John Ousterhout讲授的这个&lt;a href = “ <a href = "https://www.youtube.com/watch?v=YbZ3zDzDnrw">“&gt;视频</a>非常的棒。</li>
</ul>
</li>
<li>你可以的看到在不同的实时分布式数据库中动作日志角色：<ul>
<li><a href = "">PNUTS</a>是探索在大规模的传统的分布式数据库系统中实施以日志为中心设计理念的系统。</li>
<li><a href = "http://hbase.apache.org/">Hbase</a>和<a href = "http://research.google.com/archive/bigtable.html">Bigtable</a>都是在目前的数据库系统中使用日志的样例。</li>
<li>LinkedIn自己的分布式数据库<a href = "http://www.slideshare.net/amywtang/espresso-20952131">Espresso</a>和PNUTs一样，使用日志来复制，但有一个小的差异是它使用自己底层的表做为日志的来源。</li>
</ul>
</li>
<li>如果你正在做一致性算法选型，<a href = "http://arxiv.org/abs/1309.5671">这篇论文</a>会对你所有帮助。</li>
<li><a href = "http://www.amazon.com/Replication-Practice-Lecture-Computer-Theoretical/dp/3642112935">复制：理论与实践</a>，这是收录了分布式系统一致性的大量论文的一本巨著。网上有该书的诸多章节（<a href = "http://disi.unitn.it/~montreso/ds/papers/replication.pdf">1</a>，<a href = "http://research.microsoft.com/en-us/people/aguilera/stumbling-chapter.pdf">4</a>，<a href = "http://www.distributed-systems.net/papers/2010.verita.pdf">5</a>，<a href = "http://www.cs.cornell.edu/ken/history.pdf">6</a>，<a href = "http://www.pmg.csail.mit.edu/papers/vr-to-bft.pdf">7</a>，<a href = "http://engineering.linkedin.com/distributed-systems/www.cs.cornell.edu/fbs/publications/TrustSurveyTR.pdf">8</a>）。</li>
<li>流处理。这总结起来太广泛了，以下是一些我喜欢的：<ul>
<li><a href = "http://infolab.usc.edu/csci599/Fall2002/paper/DML2_streams-issues.pdf">在数据流系统中建模和相关事件</a>：它可能是研究这一领域的最佳概述之一。</li>
<li><a href = "http://cs.brown.edu/research/aurora/hwang.icde05.ha.pdf">分布式处理流的高可用算法</a></li>
<li>一些比较散的论文：<ul>
<li><a href = "http://db.cs.berkeley.edu/papers/cidr03-tcq.pdf">TelegraphCQ</a></li>
<li><a href = "http://cs.brown.edu/research/aurora/vldb03_journal.pdf">Aurora</a></li>
<li><a href = "http://research.cs.wisc.edu/niagara/papers/NiagaraCQ.pdf">NiagaraCQ</a></li>
<li><a href = "http://www.cs.berkeley.edu/~matei/papers/2012/hotcloud_spark_streaming.pdf">离散流</a>：这篇论文讨论了Spark的流系统。</li>
<li><a href = "http://research.google.com/pubs/pub41378.html">MillWheel</a>是谷歌的流处理系统之一。</li>
<li><a href = "http://research.microsoft.com/apps/pubs/?id=201100">Naiad</a>：一个时间数据流系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>企业级软件有着同样的问题除了名称不一样、更小的规模、XML。哈，开个玩笑：</p>
<ul>
<li><a href = "http://martinfowler.com/eaaDev/EventSourcing.html">事件溯源</a>：据我所知，这基本是企业软件工程师说“状态机复制“的方式。很有趣的一点是，同样的想法在不同的情景中被又一次发明出来。事件溯源似乎聚集于更小的、在内存中的用例。这种应用开发的方式似乎是将出现在事件日志中的流处理和应用结合起来。当处理足够大而需要数据分区进行扩容时，这变得相当复杂，我重点关注于流处理作为一个独立的原始的基础设施这一方面。</li>
<li><a href = "http://en.wikipedia.org/wiki/Change_data_capture">变更数据捕获</a>：这是围绕从数据库获取数据的一个小产品，这也是数据提取的最友好的日志风格。</li>
<li><a href = "http://en.wikipedia.org/wiki/Enterprise_application_integration">企业应用集成</a>似乎在解决数据集成问题，当你有像CRM或者供应链管理软件的企业软件时。</li>
<li><a href = "http://en.wikipedia.org/wiki/Complex_event_processing">复杂的事件处理</a>：相当肯定的是没有人知道这是什么，它是怎么区别于流处理的。不同之处似乎是关注点在于无序流、事件过滤和发现，而不是聚合上，但在我看来，区别并不明显。我认为任何系统都有其优秀的地方。</li>
<li><a href = "http://en.wikipedia.org/wiki/Enterprise_service_bus">企业服务总线</a>：我认为企业服务总线的概念跟我在数据集成描述的非常相似。这个理念似乎在企业软件社区中取得了一定的成功，但在Web开发人员或分布式数据基础设施人群中鲜为人知。</li>
</ul>
<p>有趣的开源组件：</p>
<ul>
<li><a href = "http://kafka.apache.org/">Kafka</a>是”日志即服务“的项目，是这篇文章的基础。</li>
<li><a href = "http://kafka.apache.org/">Bookeeper</a>和<a href = "https://cwiki.apache.org/confluence/display/BOOKKEEPER/HedWig">Hedwig</a>是”日志即服务“的另外的开源组件。它们似乎致力于数据系统内部，而不是事件数据。</li>
<li><a href = "https://github.com/linkedin/databus">数据总线</a>是为数据库表提供了类似日志层的系统。</li>
<li><a href = "http://akka.io/">Akka</a>是一个Scala的Actor框架，它有一个插件，事件溯源，提供了持久化和记录的功能。</li>
<li><a href = "http://samza.incubator.apache.org/">Samza</a>是一个我们在领英工作中使用的流处理框架。它使用了这篇文章中大量的理念，也集成了Kafka作为底层日志。</li>
<li><a href = "http://samza.incubator.apache.org/">Storm</a>是一个流处理框架，可以很好的跟Kafka集成。</li>
<li><a href = "http://spark.incubator.apache.org/docs/0.7.3/streaming-programming-guide.html">Spark Streaming</a>是Spark中的流处理框架。</li>
<li><a href = "http://spark.incubator.apache.org/docs/0.7.3/streaming-programming-guide.html">Summingbird</a>是在Storm和Hadoop上提供了方便的计算抽象。</li>
</ul>
<p>我们持续关注这一领域，如果我有一些遗漏的地方，请告知。</p>
<p>最后我给你留下的信息是：<a href = "https://youtu.be/2C7mNr5WMjA">视频</a></p>
]]></content>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：事务生效原理</title>
    <url>/2024/04/13/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E4%BA%8B%E5%8A%A1%E7%94%9F%E6%95%88%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们都知道，在使用Spring进行项目开发时，开启事务只需要在类或者上标注一个**@Transactional**注解即可实现，那么这个是怎么做到的呢？</p>
<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<p>探究其实现原理之前，我们先来看一个**@EnableTransactionManagement**注解。</p>
<span id="more"></span>

<h3 id="从-EnableTransactionManagement说起"><a href="#从-EnableTransactionManagement说起" class="headerlink" title="从@EnableTransactionManagement说起"></a>从@EnableTransactionManagement说起</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(TransactionManagementConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，该注解导入了<strong>TransactionManagementConfigurationSelector</strong>类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TransactionManagementConfigurationSelector extends AdviceModeImportSelector&lt;EnableTransactionManagement&gt; &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">		switch (adviceMode) &#123;</span><br><span class="line">			case PROXY:</span><br><span class="line">				return new String[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">						ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">			case ASPECTJ:</span><br><span class="line">				return new String[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line">			default:</span><br><span class="line">				return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在默认的PROXY模式下，<strong>TransactionManagementConfigurationSelector</strong>类注册了<strong>AutoProxyRegistrar</strong>和<strong>ProxyTransactionManagementConfiguration</strong>类：</p>
<h4 id="AutoProxyRegistrar"><a href="#AutoProxyRegistrar" class="headerlink" title="AutoProxyRegistrar"></a>AutoProxyRegistrar</h4><p>通过深入<strong>AutoProxyRegistrar</strong>可以看到，该类最终又调用了<strong>AopConfigUtils#registerAutoProxyCreatorIfNecessary</strong>注册了<strong>InfrastructureAdvisorAutoProxyCreator</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AopConfigUtils &#123;</span><br><span class="line">	private static final List&lt;Class&lt;?&gt;&gt; APC_PRIORITY_LIST &#x3D; new ArrayList&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">	static &#123;</span><br><span class="line">		&#x2F;&#x2F; Set up the escalation list...</span><br><span class="line">		APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);</span><br><span class="line">		APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class);</span><br><span class="line">		APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">	@Nullable</span><br><span class="line">	public static BeanDefinition registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		return registerAutoProxyCreatorIfNecessary(registry, null);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static BeanDefinition registerAutoProxyCreatorIfNecessary(</span><br><span class="line">			BeanDefinitionRegistry registry, @Nullable Object source) &#123;</span><br><span class="line"></span><br><span class="line">		return registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Nullable</span><br><span class="line">	private static BeanDefinition registerOrEscalateApcAsRequired(</span><br><span class="line">			Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source) &#123;</span><br><span class="line"></span><br><span class="line">		Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;如果该bean已存在，将根据APC_PRIORITY_LIST中定义的优先级进行加载&#x2F;替换</span><br><span class="line">		if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">			BeanDefinition apcDefinition &#x3D; registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">			if (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">				int currentPriority &#x3D; findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">				int requiredPriority &#x3D; findPriorityForClass(cls);</span><br><span class="line">				if (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">					apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		RootBeanDefinition beanDefinition &#x3D; new RootBeanDefinition(cls);</span><br><span class="line">		beanDefinition.setSource(source);</span><br><span class="line">		beanDefinition.getPropertyValues().add(&quot;order&quot;, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">		beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">		registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">		return beanDefinition;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，<strong>InfrastructureAdvisorAutoProxyCreator</strong>有什么作用呢</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Auto-proxy creator that considers infrastructure Advisor beans only,</span><br><span class="line"> * ignoring any application-defined Advisors.</span><br><span class="line"> *</span><br><span class="line"> * @author Juergen Hoeller</span><br><span class="line"> * @since 2.0.7</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SuppressWarnings(&quot;serial&quot;)</span><br><span class="line">public class InfrastructureAdvisorAutoProxyCreator extends AbstractAdvisorAutoProxyCreator &#123;</span><br><span class="line"></span><br><span class="line">	@Nullable</span><br><span class="line">	private ConfigurableListableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected void initBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">		super.initBeanFactory(beanFactory);</span><br><span class="line">		this.beanFactory &#x3D; beanFactory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected boolean isEligibleAdvisorBean(String beanName) &#123;</span><br><span class="line">		return (this.beanFactory !&#x3D; null &amp;&amp; this.beanFactory.containsBeanDefinition(beanName) &amp;&amp;</span><br><span class="line">				this.beanFactory.getBeanDefinition(beanName).getRole() &#x3D;&#x3D; BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码注释中可以看出，这是一个代理对象创建器。</p>
<p>了解过**@EnableAspectJAutoProxy<strong>注解原理的可能会发现，这俩走的是同一个注册方法，而对于同时开启</strong>EnableAspectJAutoProxy<strong>和</strong>EnableTransactionManagement<strong>的情况下，在注册的时候会根据定义的优先级</strong>AnnotationAwareAspectJAutoProxyCreator &gt; AspectJAwareAdvisorAutoProxyCreator &gt; InfrastructureAdvisorAutoProxyCreator<strong>，保留其中一个，通过对比其实现可以知道，</strong>AnnotationAwareAspectJAutoProxyCreator**具有的功能更全面。</p>
<h4 id="ProxyTransactionManagementConfiguration"><a href="#ProxyTransactionManagementConfiguration" class="headerlink" title="ProxyTransactionManagementConfiguration"></a>ProxyTransactionManagementConfiguration</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ProxyTransactionManagementConfiguration extends AbstractTransactionManagementConfiguration &#123;</span><br><span class="line"></span><br><span class="line">	@Bean(name &#x3D; TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span><br><span class="line">	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">	public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor() &#123;</span><br><span class="line">		BeanFactoryTransactionAttributeSourceAdvisor advisor &#x3D; new BeanFactoryTransactionAttributeSourceAdvisor();</span><br><span class="line">		advisor.setTransactionAttributeSource(transactionAttributeSource());</span><br><span class="line">		advisor.setAdvice(transactionInterceptor());</span><br><span class="line">		if (this.enableTx !&#x3D; null) &#123;</span><br><span class="line">			advisor.setOrder(this.enableTx.&lt;Integer&gt;getNumber(&quot;order&quot;));</span><br><span class="line">		&#125;</span><br><span class="line">		return advisor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">	public TransactionAttributeSource transactionAttributeSource() &#123;</span><br><span class="line">		return new AnnotationTransactionAttributeSource();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">	public TransactionInterceptor transactionInterceptor() &#123;</span><br><span class="line">		TransactionInterceptor interceptor &#x3D; new TransactionInterceptor();</span><br><span class="line">		interceptor.setTransactionAttributeSource(transactionAttributeSource());</span><br><span class="line">		if (this.txManager !&#x3D; null) &#123;</span><br><span class="line">			interceptor.setTransactionManager(this.txManager);</span><br><span class="line">		&#125;</span><br><span class="line">		return interceptor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ProxyTransactionManagementConfiguration</strong>注册了3个bean。</p>
<h5 id="transactionAdvisor"><a href="#transactionAdvisor" class="headerlink" title="transactionAdvisor"></a>transactionAdvisor</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BeanFactoryTransactionAttributeSourceAdvisor extends AbstractBeanFactoryPointcutAdvisor &#123;</span><br><span class="line"></span><br><span class="line">	@Nullable</span><br><span class="line">	private TransactionAttributeSource transactionAttributeSource;</span><br><span class="line"></span><br><span class="line">	private final TransactionAttributeSourcePointcut pointcut &#x3D; new TransactionAttributeSourcePointcut() &#123;</span><br><span class="line">		@Override</span><br><span class="line">		@Nullable</span><br><span class="line">		protected TransactionAttributeSource getTransactionAttributeSource() &#123;</span><br><span class="line">			return transactionAttributeSource;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Set the transaction attribute source which is used to find transaction</span><br><span class="line">	 * attributes. This should usually be identical to the source reference</span><br><span class="line">	 * set on the transaction interceptor itself.</span><br><span class="line">	 * @see TransactionInterceptor#setTransactionAttributeSource</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void setTransactionAttributeSource(TransactionAttributeSource transactionAttributeSource) &#123;</span><br><span class="line">		this.transactionAttributeSource &#x3D; transactionAttributeSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Set the &#123;@link ClassFilter&#125; to use for this pointcut.</span><br><span class="line">	 * Default is &#123;@link ClassFilter#TRUE&#125;.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void setClassFilter(ClassFilter classFilter) &#123;</span><br><span class="line">		this.pointcut.setClassFilter(classFilter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Pointcut getPointcut() &#123;</span><br><span class="line">		return this.pointcut;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAttributeSourcePointcut</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcut</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (TransactionalProxy.class.isAssignableFrom(targetClass) ||</span><br><span class="line">				PlatformTransactionManager.class.isAssignableFrom(targetClass) ||</span><br><span class="line">				PersistenceExceptionTranslator.class.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">		<span class="keyword">return</span> (tas == <span class="keyword">null</span> || tas.getTransactionAttribute(method, targetClass) != <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<strong>BeanFactoryTransactionAttributeSourceAdvisor</strong>的类继承关系图可以看出，它是一个事务增强器，并且其切入点实现依赖于<strong>TransactionAttributeSource</strong>，在这里的具体实现是<strong>AnnotationTransactionAttributeSource</strong>，其关键的方法是<strong>TransactionAttributeSource#getTransactionAttribute</strong>。</p>
<h5 id="AnnotationTransactionAttributeSource"><a href="#AnnotationTransactionAttributeSource" class="headerlink" title="AnnotationTransactionAttributeSource"></a>AnnotationTransactionAttributeSource</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">This class reads Spring&#39;s JDK 1.5+ Transactional annotation and exposes corresponding transaction attributes to Spring&#39;s transaction infrastructure. Also supports JTA 1.2&#39;s javax.transaction.Transactional and EJB3&#39;s javax.ejb.TransactionAttribute annotation (if present). This class may also serve as base class for a custom TransactionAttributeSource, or get customized through TransactionAnnotationParser strategies.</span><br><span class="line">**&#x2F;</span><br><span class="line">public class AnnotationTransactionAttributeSource extends AbstractFallbackTransactionAttributeSource</span><br><span class="line">		implements Serializable &#123;</span><br><span class="line">		&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从该类的注释可以看出，该类主要用于解析**@Transactional<strong>注解，并将其属性提供给事务框架使用，而从其构造函数可以知道，它使用了</strong>SpringTransactionAnnotationParser**作为事务属性配置的解析器。</p>
<h5 id="transactionInterceptor"><a href="#transactionInterceptor" class="headerlink" title="transactionInterceptor"></a>transactionInterceptor</h5><p><img src="http://storage.laixiaoming.space/blog/image-20240413174621857.png" alt="image-20240413174621857"></p>
<p>从该类的继承关系图可以看出，<strong>TransactionInterceptor</strong>实现了<strong>MethodInterceptor</strong>，是一个方法拦截器，不验证猜出事务是行为是在这个类中实现的，接下来我们具体看下<strong>TransactionInterceptor</strong> 到底做了什么。</p>
<h3 id="TransactionInterceptor工作原理"><a href="#TransactionInterceptor工作原理" class="headerlink" title="TransactionInterceptor工作原理"></a>TransactionInterceptor工作原理</h3><p><strong>invoke</strong>是<strong>MethodInterceptor</strong>的核心方法，其主要逻辑在<strong>invokeWithinTransaction</strong>体现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="comment">// Work out the target class: may be &#123;@code null&#125;.</span></span><br><span class="line">	<span class="comment">// The TransactionAttributeSource should be passed the target class</span></span><br><span class="line">	<span class="comment">// as well as the method, which may be from an interface.</span></span><br><span class="line">	Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...</span></span><br><span class="line">	<span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="invokeWithinTransaction事务整体流程"><a href="#invokeWithinTransaction事务整体流程" class="headerlink" title="invokeWithinTransaction事务整体流程"></a>invokeWithinTransaction事务整体流程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,</span><br><span class="line">		final InvocationCallback invocation) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; If the transaction attribute is null, the method is non-transactional.</span><br><span class="line">	TransactionAttributeSource tas &#x3D; getTransactionAttributeSource();</span><br><span class="line">	&#x2F;&#x2F;获取@Transaction属性配置</span><br><span class="line">	final TransactionAttribute txAttr &#x3D; (tas !&#x3D; null ? tas.getTransactionAttribute(method, targetClass) : null);</span><br><span class="line">	&#x2F;&#x2F;获取事务管理器</span><br><span class="line">	final PlatformTransactionManager tm &#x3D; determineTransactionManager(txAttr);</span><br><span class="line">	final String joinpointIdentification &#x3D; methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">	if (txAttr &#x3D;&#x3D; null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">		&#x2F;&#x2F; Standard transaction demarcation with getTransaction and commit&#x2F;rollback calls.</span><br><span class="line">		&#x2F;&#x2F;创建事务</span><br><span class="line">		TransactionInfo txInfo &#x3D; createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">		Object retVal;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; This is an around advice: Invoke the next interceptor in the chain.</span><br><span class="line">			&#x2F;&#x2F; This will normally result in a target object being invoked.</span><br><span class="line">			retVal &#x3D; invocation.proceedWithInvocation();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			&#x2F;&#x2F; target invocation exception</span><br><span class="line">			&#x2F;&#x2F;回滚事务</span><br><span class="line">			completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			cleanupTransactionInfo(txInfo);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;提交事务</span><br><span class="line">		commitTransactionAfterReturning(txInfo);</span><br><span class="line">		return retVal;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F;...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出，这里使用的是环绕通知处理器，体现了事务创建-提交-回滚的整个轮廓。</p>
<h4 id="createTransactionIfNecessary创建事务"><a href="#createTransactionIfNecessary创建事务" class="headerlink" title="createTransactionIfNecessary创建事务"></a>createTransactionIfNecessary创建事务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="meta">@Nullable</span> TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If no name specified, apply method identification as transaction name.</span></span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">		txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//获取事务状态</span></span><br><span class="line">			status = tm.getTransaction(txAttr);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Skipping transactional joinpoint [&quot;</span> + joinpointIdentification +</span><br><span class="line">						<span class="string">&quot;] because no transaction manager has been configured&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="事务的传播机制"><a href="#事务的传播机制" class="headerlink" title="事务的传播机制"></a>事务的传播机制</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">	Object transaction = doGetTransaction();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cache debug flag to avoid repeated checks.</span></span><br><span class="line">	<span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (definition == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">		definition = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//是否存在当前事务</span></span><br><span class="line">	<span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">		<span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line">		<span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check definition settings for new transaction.</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">&quot;Invalid transaction timeout&quot;</span>, definition.getTimeout());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当前事务不存在，则根据事务传播行为做不同处理</span></span><br><span class="line">	<span class="comment">// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">				<span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">			definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">			definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">		<span class="comment">//挂起当前事务，当前事务为不存在，不需要挂起</span></span><br><span class="line">		SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + definition.getName() + <span class="string">&quot;]: &quot;</span> + definition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">			DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">					definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">			doBegin(transaction, definition);</span><br><span class="line">			prepareSynchronization(status, definition);</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">			resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line">		<span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">			logger.warn(<span class="string">&quot;Custom isolation level specified but no actual transaction initiated; &quot;</span> +</span><br><span class="line">					<span class="string">&quot;isolation level will effectively be ignored: &quot;</span> + definition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">		<span class="keyword">return</span> prepareTransactionStatus(definition, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从getTransaction代码处理上看，在不存在当前事务的情况下，事务传播行为：</p>
<ol>
<li>是<strong>MANDATORY</strong>类型时，则直接抛出异常，因为此时还没有事务</li>
<li>是<strong>REQUIRED</strong>、<strong>REQUIRES_NEW</strong>、<strong>NESTED</strong>类型时，则创建一个新的事务</li>
<li>其余情况，返回空事务</li>
</ol>
<p>而在存在当前事务的情况下，<strong>handleExistingTransaction</strong>方法将被执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">handleExistingTransaction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		TransactionDefinition definition, Object transaction, <span class="keyword">boolean</span> debugEnabled)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">	<span class="comment">//传播行为是NEVER，则不允许执行</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">				<span class="string">&quot;Existing transaction found for transaction marked with propagation &#x27;never&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//传播行为是NOT_SUPPORTED，挂起当前事务</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line">		<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Suspending current transaction&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Object suspendedResources = suspend(transaction);</span><br><span class="line">		<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">		<span class="keyword">return</span> prepareTransactionStatus(</span><br><span class="line">				definition, <span class="keyword">null</span>, <span class="keyword">false</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//传播行为是REQUIRED_NEW，挂起当前事务，并新建一个事务</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line">		<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Suspending current transaction, creating new transaction with name [&quot;</span> +</span><br><span class="line">					definition.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		SuspendedResourcesHolder suspendedResources = suspend(transaction);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">			DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">					definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">			doBegin(transaction, definition);</span><br><span class="line">			prepareSynchronization(status, definition);</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error beginEx) &#123;</span><br><span class="line">			resumeAfterBeginException(transaction, suspendedResources, beginEx);</span><br><span class="line">			<span class="keyword">throw</span> beginEx;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//传播行为是NESTED，创建一个保存点</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isNestedTransactionAllowed()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NestedTransactionNotSupportedException(</span><br><span class="line">					<span class="string">&quot;Transaction manager does not allow nested transactions by default - &quot;</span> +</span><br><span class="line">					<span class="string">&quot;specify &#x27;nestedTransactionAllowed&#x27; property with value &#x27;true&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Creating nested transaction with name [&quot;</span> + definition.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (useSavepointForNestedTransaction()) &#123;</span><br><span class="line">			<span class="comment">// Create savepoint within existing Spring-managed transaction,</span></span><br><span class="line">			<span class="comment">// through the SavepointManager API implemented by TransactionStatus.</span></span><br><span class="line">			<span class="comment">// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.</span></span><br><span class="line">			DefaultTransactionStatus status =</span><br><span class="line">					prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, <span class="keyword">false</span>, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">			status.createAndHoldSavepoint();</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Nested transaction through nested begin and commit/rollback calls.</span></span><br><span class="line">			<span class="comment">// Usually only for JTA: Spring synchronization might get activated here</span></span><br><span class="line">			<span class="comment">// in case of a pre-existing JTA transaction.</span></span><br><span class="line">			<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">			DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">					definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">			doBegin(transaction, definition);</span><br><span class="line">			prepareSynchronization(status, definition);</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.</span></span><br><span class="line">	<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Participating in existing transaction&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (isValidateExistingTransaction()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123;</span><br><span class="line">			Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">			<span class="keyword">if</span> (currentIsolationLevel == <span class="keyword">null</span> || currentIsolationLevel != definition.getIsolationLevel()) &#123;</span><br><span class="line">				Constants isoConstants = DefaultTransactionDefinition.constants;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(<span class="string">&quot;Participating transaction with definition [&quot;</span> +</span><br><span class="line">						definition + <span class="string">&quot;] specifies isolation level which is incompatible with existing transaction: &quot;</span> +</span><br><span class="line">						(currentIsolationLevel != <span class="keyword">null</span> ?</span><br><span class="line">								isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :</span><br><span class="line">								<span class="string">&quot;(unknown)&quot;</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!definition.isReadOnly()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(<span class="string">&quot;Participating transaction with definition [&quot;</span> +</span><br><span class="line">						definition + <span class="string">&quot;] is not marked as read-only but existing transaction is&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">	<span class="keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="事务的挂起和恢复"><a href="#事务的挂起和恢复" class="headerlink" title="事务的挂起和恢复"></a>事务的挂起和恢复</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SuspendedResourcesHolder <span class="title">suspend</span><span class="params">(<span class="meta">@Nullable</span> Object transaction)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">		<span class="comment">//记录当前的事务同步管理器信息</span></span><br><span class="line">		List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Object suspendedResources = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">//挂起当前事务</span></span><br><span class="line">				suspendedResources = doSuspend(transaction);</span><br><span class="line">			&#125;</span><br><span class="line">			String name = TransactionSynchronizationManager.getCurrentTransactionName();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionName(<span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">boolean</span> readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionReadOnly(<span class="keyword">false</span>);</span><br><span class="line">			Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(<span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">boolean</span> wasActive = TransactionSynchronizationManager.isActualTransactionActive();</span><br><span class="line">			TransactionSynchronizationManager.setActualTransactionActive(<span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> SuspendedResourcesHolder(</span><br><span class="line">					suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">			<span class="comment">// doSuspend failed - original transaction is still active...</span></span><br><span class="line">			doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Transaction active but no synchronization active.</span></span><br><span class="line">		Object suspendedResources = doSuspend(transaction);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SuspendedResourcesHolder(suspendedResources);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Neither transaction nor synchronization active.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doSuspend</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">	DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">	txObject.setConnectionHolder(<span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">return</span> TransactionSynchronizationManager.unbindResource(obtainDataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">unbindResource</span><span class="params">(Object key)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">	Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);</span><br><span class="line">	Object value = doUnbindResource(actualKey);</span><br><span class="line">	<span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">&quot;No value for key [&quot;</span> + actualKey + <span class="string">&quot;] bound to thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">doUnbindResource</span><span class="params">(Object actualKey)</span> </span>&#123;</span><br><span class="line">	Map&lt;Object, Object&gt; map = resources.get();</span><br><span class="line">	<span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Object value = map.remove(actualKey);</span><br><span class="line">	<span class="comment">// Remove entire ThreadLocal if empty...</span></span><br><span class="line">	<span class="keyword">if</span> (map.isEmpty()) &#123;</span><br><span class="line">		resources.remove();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Transparently suppress a ResourceHolder that was marked as void...</span></span><br><span class="line">	<span class="keyword">if</span> (value <span class="keyword">instanceof</span> ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123;</span><br><span class="line">		value = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Removed value [&quot;</span> + value + <span class="string">&quot;] for key [&quot;</span> + actualKey + <span class="string">&quot;] from thread [&quot;</span> +</span><br><span class="line">				Thread.currentThread().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，事务的挂起实际是对当前事务的状态信息和数据源连接对象封装到<strong>SuspendedResourcesHolder</strong>对象中，并将线程本地变量保存的事务状态清除。</p>
<p>那什么时候进行恢复呢？通过查看代码可以发现，在事务提交或者回滚后，org.springframework.transaction.support.AbstractPlatformTransactionManager#cleanupAfterCompletion，会进行挂起事务的恢复：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanupAfterCompletion</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">	status.setCompleted();</span><br><span class="line">	<span class="keyword">if</span> (status.isNewSynchronization()) &#123;</span><br><span class="line">		TransactionSynchronizationManager.clear();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">		doCleanupAfterCompletion(status.getTransaction());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (status.getSuspendedResources() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Resuming suspended transaction after completion of inner transaction&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Object transaction = (status.hasTransaction() ? status.getTransaction() : <span class="keyword">null</span>);</span><br><span class="line">		resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">(<span class="meta">@Nullable</span> Object transaction, <span class="meta">@Nullable</span> SuspendedResourcesHolder resourcesHolder)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (resourcesHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Object suspendedResources = resourcesHolder.suspendedResources;</span><br><span class="line">		<span class="keyword">if</span> (suspendedResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">			doResume(transaction, suspendedResources);</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;TransactionSynchronization&gt; suspendedSynchronizations = resourcesHolder.suspendedSynchronizations;</span><br><span class="line">		<span class="keyword">if</span> (suspendedSynchronizations != <span class="keyword">null</span>) &#123;</span><br><span class="line">			TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive);</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel);</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly);</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name);</span><br><span class="line">			doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>Spring事务也是通过AOP实现，相关逻辑由<strong>BeanFactoryTransactionAttributeSourceAdvisor</strong>、<strong>TransactionAttributeSource</strong>、<strong>TransactionInterceptor</strong>实现；</li>
<li>事务的挂起与恢复，实际是通过线程本地变量对当前事务信息的保存、清除和恢复；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo源码学习：SPI机制</title>
    <url>/2024/06/23/Dubbo%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9ASPI%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>SPI全称是Service Provider Interface，是一种服务自发现机制，本质是将接口实现类的全限定名配置在文件中，在使用中，通过运行时加载，并动态地替换为具体的接口实现类。</p>
<span id="more"></span>

<h3 id="JDK-SPI"><a href="#JDK-SPI" class="headerlink" title="JDK SPI"></a>JDK SPI</h3><p>在开发中，SPI的应用中最让我们熟知的便是JDBC的使用，JDBC中定义了<strong>java.sql.Driver</strong>接口，当我们调用<strong>DriverManager#getConnection方法时</strong>，将触发<strong>DriverManager</strong>类的初始化，并利用SPI机制自动加载驱动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">       loadInitialDrivers();</span><br><span class="line">       println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//省略...</span></span><br><span class="line">     AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//加载驱动类</span></span><br><span class="line">             ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">             <span class="comment">//获取驱动器迭代器，类型为LazyIterator</span></span><br><span class="line">             Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">             </span><br><span class="line">             <span class="keyword">try</span>&#123;</span><br><span class="line">                 <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                     driversIterator.next();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">             <span class="comment">// Do nothing</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//省略...</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在调用<strong>ServiceLoader#load</strong>时，将首先获取当前线程绑定的类加载器（ServiceLoader由启动类加载器加载，启动类加载器无法加载应用类代码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后将对迭代器<strong>driversIterator</strong>进行遍历，加载<strong>META-INF/services/java.sql.Driver</strong>路径下所有的文件，并按行读取 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//META-INF/services/java.sql.Driver</span></span><br><span class="line">            String fullName = PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到**driversIterator.next()**的调用中，会触发具体驱动类的加载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private S nextService() &#123;</span><br><span class="line">    if (!hasNextService())</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    String cn &#x3D; nextName;</span><br><span class="line">    nextName &#x3D; null;</span><br><span class="line">    Class&lt;?&gt; c &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">    	&#x2F;&#x2F;加载驱动类</span><br><span class="line">        c &#x3D; Class.forName(cn, false, loader);</span><br><span class="line">    &#125; catch (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             &quot;Provider &quot; + cn + &quot; not found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">        if (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">            fail(service,</span><br><span class="line">                 &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            S p &#x3D; service.cast(c.newInstance())</span><br><span class="line">            &#x2F;&#x2F;缓存驱动类实例</span><br><span class="line">            providers.put(cn, p);</span><br><span class="line">            return p;</span><br><span class="line">        &#125; catch (Throwable x) &#123;</span><br><span class="line">            fail(service,</span><br><span class="line">                 &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,</span><br><span class="line">                 x);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new Error();          &#x2F;&#x2F; This cannot happen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以MySQL为例，加载的类为<strong>com.mysql.cj.jdbc</strong>，可以看到该段初始化代码中会通过<strong>DriverManager#registerDriver</strong>注册当前驱动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在整个流程中，我们可以看出，JDK的SPI会一次性的加载并实例化，通过配置文件发现的所有的服务实现类，如果存在多个服务实现类，而我们只需要其中一个的话，则在一定程度上损耗了资源。</p>
<h3 id="Dubbo-SPI实现"><a href="#Dubbo-SPI实现" class="headerlink" title="Dubbo SPI实现"></a>Dubbo SPI实现</h3><p>在Dubbo中，所有的组件组件都是由SPI进行加载，但Dubbo并示直接使用JDK提供的SPI机制，而是借鉴其核心思想，并对其进行了增强，实现了自身的一套SPI机制，其用法与JDK的类似，核心类是<strong>ExtensionLoader</strong>，配置文件也定义在**META-INF/**路径下，但Dubbo对配置文件具体分为了三类：</p>
<ul>
<li>META-INF/services/ 目录：该目录下的 SPI 配置文件用来兼容 JDK SPI 。</li>
<li>META-INF/dubbo/ 目录：该目录用于存放用户自定义 SPI 配置文件。</li>
<li>META-INF/dubbo/internal/ 目录：该目录用于存放 Dubbo 内部使用的 SPI 配置文件。</li>
</ul>
<p>且配置文件的内容也不再是类名，而是K-V形式，key被称为扩展名，value则是扩展实现类，并通指定扩展名实现按需加载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dubbo&#x3D;org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>定义扩展接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义扩展实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a cat&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a dog&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件，位置：META-INF/dubbo/org.apache.dubbo.mytest.Animal：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cat=org.apache.dubbo.mytest.Cat</span><br><span class="line">dog=org.apache.dubbo.mytest.Dog</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExtensionLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;Animal&gt; extensionLoader =</span><br><span class="line">                ExtensionLoader.getExtensionLoader(Animal.class);</span><br><span class="line">        Animal cat = extensionLoader.getExtension(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        System.out.println(cat.name());</span><br><span class="line">        Animal dog = extensionLoader.getExtension(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        System.out.println(dog.name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="获取ExtensionLoader实例"><a href="#获取ExtensionLoader实例" class="headerlink" title="获取ExtensionLoader实例"></a>获取ExtensionLoader实例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) &#123;</span><br><span class="line">&#x2F;&#x2F;省略...</span><br><span class="line">      ExtensionLoader&lt;T&gt; loader &#x3D; (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">      if (loader &#x3D;&#x3D; null) &#123;</span><br><span class="line">          EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">          loader &#x3D; (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">      &#125;</span><br><span class="line">      return loader;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，通过EXTENSION_LOADERS缓存字段，保证一个扩展接口有且只有一个ExtensionLoader实例。</p>
<h5 id="获取扩展实例"><a href="#获取扩展实例" class="headerlink" title="获取扩展实例"></a>获取扩展实例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name, <span class="keyword">boolean</span> wrap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Extension name == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩展对象持有器</span></span><br><span class="line">    <span class="keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name);</span><br><span class="line">    Object instance = holder.get();</span><br><span class="line">    <span class="comment">//双检锁使用，创建扩展实例</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = createExtension(name, wrap);</span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先检查缓存 ，没有则通过<strong>createExtension</strong>创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name, <span class="keyword">boolean</span> wrap)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//加载所有扩展类，并通过扩展名称获取对应扩展类</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span> || unacceptableExceptions.contains(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">//获取/创建扩展实例</span></span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.getDeclaredConstructor().newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//扩展实例依赖注入</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//包装扩展实例（如果有的话）并返回</span></span><br><span class="line">        <span class="keyword">if</span> (wrap) &#123;</span><br><span class="line"></span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; wrapperClassesList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (cachedWrapperClasses != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wrapperClassesList.addAll(cachedWrapperClasses);</span><br><span class="line">                wrapperClassesList.sort(WrapperComparator.COMPARATOR);</span><br><span class="line">                Collections.reverse(wrapperClassesList);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClassesList)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClassesList) &#123;</span><br><span class="line">                    Wrapper wrapper = wrapperClass.getAnnotation(Wrapper.class);</span><br><span class="line">                    <span class="keyword">if</span> (wrapper == <span class="keyword">null</span></span><br><span class="line">                            || (ArrayUtils.contains(wrapper.matches(), name) &amp;&amp; !ArrayUtils.contains(wrapper.mismatches(), name))) &#123;</span><br><span class="line">                        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//初始化实例</span></span><br><span class="line">        initExtension(instance);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Extension instance (name: &quot;</span> + name + <span class="string">&quot;, class: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;) couldn&#x27;t be instantiated: &quot;</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>createExtension</strong>主要包含了4个步骤：</p>
<ol>
<li>通过getExtensionClasses获取所有扩展实现类；</li>
<li>获取/通过反射创建扩展实例；</li>
<li>向扩展实例注入依赖；</li>
<li>包装扩展实例；</li>
</ol>
<h6 id="获取所有的扩展类"><a href="#获取所有的扩展类" class="headerlink" title="获取所有的扩展类"></a>获取所有的扩展类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">//从缓存中获取扩展类</span></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="comment">//双检锁使用，加载所有的扩展类</span></span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<strong>loadExtensionClasses</strong>加载扩展类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    	<span class="comment">//缓存默认扩展名</span></span><br><span class="line">      cacheDefaultExtensionName();</span><br><span class="line"></span><br><span class="line">      Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//从不同目录加载扩展类</span></span><br><span class="line">      <span class="keyword">for</span> (LoadingStrategy strategy : strategies) &#123;</span><br><span class="line">          loadDirectory(extensionClasses, strategy.directory(), type.getName(), strategy.preferExtensionClassLoader(),</span><br><span class="line">                  strategy.overridden(), strategy.excludedPackages());</span><br><span class="line">          loadDirectory(extensionClasses, strategy.directory(), type.getName().replace(<span class="string">&quot;org.apache&quot;</span>, <span class="string">&quot;com.alibaba&quot;</span>),</span><br><span class="line">                  strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> extensionClasses;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里首先解析了@SPI注解，获取到默认的扩展名并缓存下来，然后通过不同的策略加载扩展类，那这里的策略都有哪些呢，通过定位可以看到是通过<strong>loadLoadingStrategies</strong>获取的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LoadingStrategy[] loadLoadingStrategies() &#123;</span><br><span class="line">    <span class="keyword">return</span> stream(load(LoadingStrategy.class).spliterator(), <span class="keyword">false</span>)</span><br><span class="line">            .sorted()</span><br><span class="line">            .toArray(LoadingStrategy[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续深入可以发现，该策略是最终是通过JDK的SPI机制加载的，而通过配置文件可以看到主要包含了有一种策略类<strong>org.apache.dubbo.common.extension.DubboInternalLoadingStrategy</strong>、<strong>org.apache.dubbo.common.extension.DubboLoadingStrategy</strong>、<strong>org.apache.dubbo.common.extension.ServicesLoadingStrategy</strong>，而这3种策略类则分别对应了前端提到的3个配置文件的目录。</p>
<p>回到<strong>loadDirectory</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir, String type,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> extensionLoaderClassLoaderFirst, <span class="keyword">boolean</span> overridden, String... excludedPackages)</span> </span>&#123;</span><br><span class="line">    String fileName = dir + type;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;java.net.URL&gt; urls = <span class="keyword">null</span>;</span><br><span class="line">        ClassLoader classLoader = findClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try to load from ExtensionLoader&#x27;s ClassLoader first</span></span><br><span class="line">        <span class="keyword">if</span> (extensionLoaderClassLoaderFirst) &#123;</span><br><span class="line">            ClassLoader extensionLoaderClassLoader = ExtensionLoader.class.getClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (ClassLoader.getSystemClassLoader() != extensionLoaderClassLoader) &#123;</span><br><span class="line">                urls = extensionLoaderClassLoader.getResources(fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (urls == <span class="keyword">null</span> || !urls.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                urls = classLoader.getResources(fileName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                java.net.URL resourceURL = urls.nextElement();</span><br><span class="line">                loadResource(extensionClasses, classLoader, resourceURL, overridden, excludedPackages);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, description file: &quot;</span> + fileName + <span class="string">&quot;).&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到了对应所有的文件资源，并通过<strong>loadResource</strong>加载：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                          java.net.URL resourceURL, <span class="keyword">boolean</span> overridden, String... excludedPackages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(resourceURL.openStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            String clazz = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//只取#前端内容</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> ci = line.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                &#125;</span><br><span class="line">                line = line.trim();</span><br><span class="line">                <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//分隔以获取扩展名及扩展类名</span></span><br><span class="line">                        String name = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> i = line.indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                            clazz = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            clazz = line;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isNotEmpty(clazz) &amp;&amp; !isExcluded(clazz, excludedPackages)) &#123;</span><br><span class="line">                            <span class="comment">//加载扩展类</span></span><br><span class="line">                            loadClass(extensionClasses, resourceURL, Class.forName(clazz, <span class="keyword">true</span>, classLoader), name, overridden);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                                <span class="string">&quot;Failed to load extension class (interface: &quot;</span> + type + <span class="string">&quot;, class line: &quot;</span> + line + <span class="string">&quot;) in &quot;</span> + resourceURL +</span><br><span class="line">                                        <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">                        exceptions.put(line, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, class file: &quot;</span> + resourceURL + <span class="string">&quot;) in &quot;</span> + resourceURL, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载扩展类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">boolean</span> overridden)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Error occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, class line: &quot;</span> + clazz.getName() + <span class="string">&quot;), class &quot;</span></span><br><span class="line">                + clazz.getName() + <span class="string">&quot; is not subtype of interface.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">        <span class="comment">//缓存自适应扩展类</span></span><br><span class="line">        cacheAdaptiveClass(clazz, overridden);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">        <span class="comment">//缓存包装类</span></span><br><span class="line">        cacheWrapperClass(clazz);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//普通扩展类</span></span><br><span class="line">        clazz.getConstructor();</span><br><span class="line">        <span class="comment">//如果名称为空，则通过@Extension注解获取</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">            name = findAnnotationName(clazz);</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">&quot;No such extension name for the class &quot;</span> + clazz.getName() + <span class="string">&quot; in the config &quot;</span> + resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//切分为多个扩展名</span></span><br><span class="line">        String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">        <span class="keyword">if</span> (ArrayUtils.isNotEmpty(names)) &#123;</span><br><span class="line">            cacheActivateClass(clazz, names[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                <span class="comment">//添加到扩展类集合</span></span><br><span class="line">                cacheName(clazz, n);</span><br><span class="line">                saveInExtensionClass(extensionClasses, clazz, n, overridden);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码分支上看，加载扩展类这里分为3种情况，分别为自适应扩展类、包装类及普通扩展类。</p>
<h6 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h6><p>创建扩展实例后，下一步则是向扩展实例注入依赖，具体逻辑是<strong>injectExtension</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (objectFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历扩展类的所有方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">            <span class="comment">//是否setter方法</span></span><br><span class="line">            <span class="keyword">if</span> (!isSetter(method)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Check &#123;@link DisableInject&#125; to see if we need autowire injection for this property</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//获取方法参数类型</span></span><br><span class="line">            Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Check &#123;@link Inject&#125; to see if we need auto-injection for this property</span></span><br><span class="line"><span class="comment">             * &#123;@link Inject#enable&#125; == false will skip inject property phase</span></span><br><span class="line"><span class="comment">             * &#123;@link Inject#InjectType#ByName&#125; default inject by name</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//获取setter属性名</span></span><br><span class="line">            String property = getSetterProperty(method);</span><br><span class="line">            Inject inject = method.getAnnotation(Inject.class);</span><br><span class="line">            <span class="keyword">if</span> (inject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//注入依赖值</span></span><br><span class="line">                injectValue(instance, method, pt, property);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!inject.enable()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (inject.type() == Inject.InjectType.ByType) &#123;</span><br><span class="line">                    <span class="comment">//按类型注入</span></span><br><span class="line">                    injectValue(instance, method, pt, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//按名称注入</span></span><br><span class="line">                    injectValue(instance, method, pt, property);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">injectValue</span><span class="params">(T instance, Method method, Class&lt;?&gt; pt, String property)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">            method.invoke(instance, object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Failed to inject via method &quot;</span> + method.getName()</span><br><span class="line">                + <span class="string">&quot; of interface &quot;</span> + type.getName() + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里的依赖注入是通过解析set方法进行注入，可以通过类型或名称进行注入，具体的注入逻辑由<strong>objectFactory</strong>决定，通过深入查看发现此处<strong>objectFactory</strong>通过<strong>ExtensionLoader#getAdaptiveExtension</strong>方法获取得到，其类型为<strong>AdaptiveExtensionFactory</strong>，该类被称为自适应扩展类，而它也是通过SPI机制加载得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Adaptive</span><br><span class="line">public class AdaptiveExtensionFactory implements ExtensionFactory &#123;</span><br><span class="line"></span><br><span class="line">    private final List&lt;ExtensionFactory&gt; factories;</span><br><span class="line"></span><br><span class="line">    public AdaptiveExtensionFactory() &#123;</span><br><span class="line">        ExtensionLoader&lt;ExtensionFactory&gt; loader &#x3D; ExtensionLoader.getExtensionLoader(ExtensionFactory.class);</span><br><span class="line">        List&lt;ExtensionFactory&gt; list &#x3D; new ArrayList&lt;ExtensionFactory&gt;();</span><br><span class="line">        for (String name : loader.getSupportedExtensions()) &#123;</span><br><span class="line">            list.add(loader.getExtension(name));</span><br><span class="line">        &#125;</span><br><span class="line">        factories &#x3D; Collections.unmodifiableList(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name) &#123;</span><br><span class="line">    	&#x2F;&#x2F;遍历所有ExtensionFactory，获取到依赖后便直接返回</span><br><span class="line">        for (ExtensionFactory factory : factories) &#123;</span><br><span class="line">            T extension &#x3D; factory.getExtension(type, name);</span><br><span class="line">            if (extension !&#x3D; null) &#123;</span><br><span class="line">                return extension;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<strong>AdaptiveExtensionFactory</strong>中维护了factories集合，在Spring环境下，该集合包括<strong>SpiExtensionFactory</strong>和<strong>SpringExtensionFactory</strong>。</p>
<h5 id="获取自适应扩展类"><a href="#获取自适应扩展类" class="headerlink" title="获取自适应扩展类"></a>获取自适应扩展类</h5><p>什么是自适应扩展类呢？在前文了解到，Dubbo的依赖注入有用到自适应扩展类，通过观察其实现，可以发现它实际上是一种代理类。在Dubbo中，可以通过**@Adaptive<strong>注解标注扩展接口或接口方法，而Dubbo将自动为其生成具有代理功能的代码，并通过编译得到Class类，当调用自适应扩展类时，将通过方法中的URL参数决定具体调用的扩展实例。其关键代码在于</strong>getAdaptiveExtension**：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从缓存中获取自适应扩展类</span></span><br><span class="line">    Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to create adaptive instance: &quot;</span> +</span><br><span class="line">                    createAdaptiveInstanceError.toString(),</span><br><span class="line">                    createAdaptiveInstanceError);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//创建自适应扩展实例</span></span><br><span class="line">        <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">            instance = cachedAdaptiveInstance.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    instance = createAdaptiveExtension();</span><br><span class="line">                    cachedAdaptiveInstance.set(instance);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    createAdaptiveInstanceError = t;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to create adaptive instance: &quot;</span> + t.toString(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Can&#x27;t create adaptive extension &quot;</span> + type + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与创建普通的扩展实例相似，创建自适应扩展实例也分为3个步骤：</p>
<ol>
<li>获取自适应扩展类；</li>
<li>创建自应用扩展实例；</li>
<li>依赖注入；</li>
</ol>
<p>我们具体看下<strong>getAdaptiveExtensionClass</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    if (cachedAdaptiveClass !&#x3D; null) &#123;</span><br><span class="line">        return cachedAdaptiveClass;</span><br><span class="line">    &#125;</span><br><span class="line">    return cachedAdaptiveClass &#x3D; createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getAdaptiveExtensionClass</strong>同样包含了3个步骤：</p>
<ol>
<li>获取扩展类（与获取普通的扩展类的调用是同一个方法，这里会缓存**@Adaptive**注解标注的类为cachedAdaptiveClass）；</li>
<li>缓存的自适应扩展类cachedAdaptiveClass不为空时，直接返回；</li>
<li>创建自适应扩展类；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">//生成自适应扩展类的代码</span></span><br><span class="line">    String code = <span class="keyword">new</span> AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();</span><br><span class="line">    <span class="comment">//获取编译器实现类</span></span><br><span class="line">    ClassLoader classLoader = findClassLoader();</span><br><span class="line">    org.apache.dubbo.common.compiler.Compiler compiler =</span><br><span class="line">            ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">    <span class="comment">//编译代码，并生成Class</span></span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createAdaptiveExtensionClass用于生成自适应扩展类代码，并通过<strong>org.apache.dubbo.common.compiler.Compiler</strong>实例编码代码，得到Class类。通过查看其配置文件可知，目前存在<strong>JdkCompiler</strong>和<strong>JavassistCompiler</strong>两种编译器，而Dubbo默认使用<strong>JavassistCompiler</strong>。</p>
<h5 id="自动包装类"><a href="#自动包装类" class="headerlink" title="自动包装类"></a>自动包装类</h5><p>回到<strong>ExtensionLoader#loadClass</strong>方法中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> private void loadClass(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name,</span><br><span class="line">                        boolean overridden) throws NoSuchMethodException &#123;</span><br><span class="line">     &#x2F;&#x2F;省略...</span><br><span class="line">     if (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">         cacheAdaptiveClass(clazz, overridden);</span><br><span class="line">         &#x2F;&#x2F;是否包含拷贝构造函数</span><br><span class="line">     &#125; else if (isWrapperClass(clazz)) &#123;</span><br><span class="line">     	&#x2F;&#x2F;缓存包装类</span><br><span class="line">         cacheWrapperClass(clazz);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;省略...</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>那包装类是什么呢，通过查看cachedWrapperClasses的使用位置，可以看到，在<strong>ExtensionLoader#createExtension</strong>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (wrap) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; wrapperClassesList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if (cachedWrapperClasses !&#x3D; null) &#123;</span><br><span class="line">        wrapperClassesList.addAll(cachedWrapperClasses);</span><br><span class="line">        wrapperClassesList.sort(WrapperComparator.COMPARATOR);</span><br><span class="line">        Collections.reverse(wrapperClassesList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (CollectionUtils.isNotEmpty(wrapperClassesList)) &#123;</span><br><span class="line">        for (Class&lt;?&gt; wrapperClass : wrapperClassesList) &#123;</span><br><span class="line">            Wrapper wrapper &#x3D; wrapperClass.getAnnotation(Wrapper.class);</span><br><span class="line">            if (wrapper &#x3D;&#x3D; null</span><br><span class="line">                    || (ArrayUtils.contains(wrapper.matches(), name) &amp;&amp; !ArrayUtils.contains(wrapper.mismatches(), name))) &#123;</span><br><span class="line">                instance &#x3D; injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包装类是一种装饰类，其作用更多用于将扩展类的公共逻辑处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文简单介绍了 Java SPI 与 Dubbo SPI 用法，并通过源码分析了 Dubbo SPI 加载拓展类的过程，总的来说，</p>
<ol>
<li>Dubbo实现了自己的一套SPI机制，可以按需进行加载；</li>
<li>在Dubbo中可以通过**@Adaptive**注解创建自适应扩展类，根据传入的URL参数加载具体的扩展实现；</li>
<li>Dubbo可以对创建的扩展实例进行依赖注入，但只针对setter方法进行注入，目前存在两种注入实现，分别为<strong>SpiExtensionFactory</strong>和<strong>SpringExtensionFactory</strong>;</li>
<li>Dubbo可以通过包装类实现对扩展类的装饰；</li>
</ol>
]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo源码学习：服务导出</title>
    <url>/2024/07/06/Dubbo%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<p>我们都知道，在Dubbo微服务项目开发中，只需要通过**@EnableDubbo<strong>和</strong>@DubboService**注解就可以把服务注册到注册中心，那整个过程是怎么发生的呢？</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Dubbo 2.7.12版本</p>
</blockquote>
<h3 id="从-EnableDubbo说起"><a href="#从-EnableDubbo说起" class="headerlink" title="从@EnableDubbo说起"></a>从@EnableDubbo说起</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//省略...</span></span><br><span class="line"><span class="meta">@EnableDubboConfig</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDubbo &#123;</span><br><span class="line">	<span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@EnableDubbo</strong>主要包含了**@EnableDubboConfig<strong>和</strong>@DubboComponentScan<strong>，我们重点看下</strong>@DubboComponentScan**：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//省略...</span></span><br><span class="line"><span class="meta">@Import(DubboComponentScanRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DubboComponentScan &#123;</span><br><span class="line">	<span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个熟悉的**@Import<strong>注解，它导入了一个</strong>DubboComponentScanRegistrar**类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//获取元数据扫描路径</span></span><br><span class="line">        Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata);</span><br><span class="line">		<span class="comment">//注册ServiceClassPostProcessor</span></span><br><span class="line">        registerServiceClassPostProcessor(packagesToScan, registry);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//注册通用bean</span></span><br><span class="line">        <span class="comment">// @since 2.7.6 Register the common beans</span></span><br><span class="line">        registerCommonBeans(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceClassPostProcessor</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BeanDefinitionBuilder builder = rootBeanDefinition(ServiceClassPostProcessor.class);</span><br><span class="line">        builder.addConstructorArgValue(packagesToScan);</span><br><span class="line">        builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line">        BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>DubboComponentScanRegistrar</strong>最终又将<strong>ServiceClassPostProcessor</strong>注册到了IOC容器：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20240630164051353.png" alt="image-20240630164051353"></p>
<p><strong>ServiceClassPostProcessor</strong>实现了<strong>BeanDefinitionRegistryPostProcessor</strong>接口，可以通过实现<strong>postProcessBeanDefinitionRegistry</strong>新增bean定义，并将其注册到IOC容器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册一个监听器</span></span><br><span class="line">    registerInfrastructureBean(registry, DubboBootstrapApplicationListener.BEAN_NAME, DubboBootstrapApplicationListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取扫描路径</span></span><br><span class="line">    Set&lt;String&gt; resolvedPackagesToScan = resolvePackagesToScan(packagesToScan);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(resolvedPackagesToScan)) &#123;</span><br><span class="line">        <span class="comment">//注册ServiceBean</span></span><br><span class="line">        registerServiceBeans(resolvedPackagesToScan, registry);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到<strong>registerServiceBeans</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBeans</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DubboClassPathBeanDefinitionScanner scanner =</span><br><span class="line">            <span class="keyword">new</span> DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader);</span><br><span class="line"></span><br><span class="line">    BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry);</span><br><span class="line"></span><br><span class="line">    scanner.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描@DubboService、@Service、@com.alibaba.dubbo.config.annotation.Service注解</span></span><br><span class="line">    serviceAnnotationTypes.forEach(annotationType -&gt; &#123;</span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(annotationType));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String packageToScan : packagesToScan) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Registers @Service Bean first</span></span><br><span class="line">        scanner.scan(packageToScan);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描并获取所有满足条件的BeanDefinition</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders =</span><br><span class="line">                findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(beanDefinitionHolders)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) &#123;</span><br><span class="line">                <span class="comment">//注册ServiceBean</span></span><br><span class="line">                registerServiceBean(beanDefinitionHolder, registry, scanner);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//省略...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们知道了，Dubbo启动后会通过扫描**@DubboService<strong>等注解，并注册</strong>ServiceBean**到IOC容器，除此之外，未发现Dubbo服务启动和注册相关的逻辑。</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20240630212039912.png" alt="ServiceBean类继承关系图"></p>
<p>回到<strong>postProcessBeanDefinitionRegistry</strong>，我们还发现它注册了一个<strong>DubboBootstrapApplicationListener</strong>监听器，查看其实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationContextEvent</span><span class="params">(ApplicationContextEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DubboBootstrapStartStopListenerSpringAdapter.applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        DubboBootstrapStartStopListenerSpringAdapter.applicationContext = event.getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">        onContextRefreshedEvent((ContextRefreshedEvent) event);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">        onContextClosedEvent((ContextClosedEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onContextRefreshedEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">    dubboBootstrap.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出，Dubbo服务的启动是在 Spring 容器发布刷新事件后，由<strong>DubboBootstrapApplicationListener</strong>监听器触发的。</p>
<h3 id="服务导出"><a href="#服务导出" class="headerlink" title="服务导出"></a>服务导出</h3><p>来到<strong>DubboBootstrap#start</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DubboBootstrap <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//乐观锁，避免重复启动</span></span><br><span class="line">    <span class="keyword">if</span> (started.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        destroyed.set(<span class="keyword">false</span>);</span><br><span class="line">        ready.set(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        initialize();</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(NAME + <span class="string">&quot; is starting...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 服务导出</span></span><br><span class="line">        exportServices();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Not only provider register</span></span><br><span class="line">        <span class="keyword">if</span> (!isOnlyRegisterProvider() || hasExportedServices()) &#123;</span><br><span class="line">            <span class="comment">//导出元数据服务</span></span><br><span class="line">            exportMetadataService();</span><br><span class="line">            <span class="comment">//注册本地服务实例</span></span><br><span class="line">            registerServiceInstance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        referServices();</span><br><span class="line">		<span class="comment">//省略...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重点看下服务的导出，<strong>DubboBootstrap#exportServices</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历需要导出的服务</span></span><br><span class="line">    configManager.getServices().forEach(sc -&gt; &#123;</span><br><span class="line">        <span class="comment">// TODO, compatible with ServiceConfig.export()</span></span><br><span class="line">        ServiceConfig serviceConfig = (ServiceConfig) sc;yn</span><br><span class="line">        serviceConfig.setBootstrap(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步导出</span></span><br><span class="line">        <span class="keyword">if</span> (exportAsync) &#123;</span><br><span class="line">            ExecutorService executor = executorRepository.getServiceExporterExecutor();</span><br><span class="line">            Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    exportService(serviceConfig);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;export async catch error : &quot;</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            asyncExportingFutures.add(future);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exportService(serviceConfig);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到<strong>ServiceConfig#export</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查bootstrap是否初始化</span></span><br><span class="line">    <span class="keyword">if</span> (bootstrap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        bootstrap = DubboBootstrap.getInstance();</span><br><span class="line">        <span class="comment">// compatible with api call.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.getRegistry()) &#123;</span><br><span class="line">            bootstrap.registries(<span class="keyword">this</span>.getRegistries());</span><br><span class="line">        &#125;</span><br><span class="line">        bootstrap.initialize();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//检查相关配置</span></span><br><span class="line">    checkAndUpdateSubConfigs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化元数据</span></span><br><span class="line">    initServiceMetadata(provider);</span><br><span class="line">    serviceMetadata.setServiceType(getInterfaceClass());</span><br><span class="line">    serviceMetadata.setTarget(getRef());</span><br><span class="line">    serviceMetadata.generateServiceKey();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否导出</span></span><br><span class="line">    <span class="keyword">if</span> (!shouldExport()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否延迟导出</span></span><br><span class="line">    <span class="keyword">if</span> (shouldDelay()) &#123;</span><br><span class="line">        DELAY_EXPORT_EXECUTOR.schedule(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Delay export server should print stack trace if there are exception occur.</span></span><br><span class="line">                <span class="keyword">this</span>.doExport();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;delay export server occur exception, please check it.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getDelay(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doExport();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exported();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ServiceConfig#doExportUrls</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取服务仓库，缓存provider</span></span><br><span class="line">    ServiceRepository repository = ApplicationModel.getServiceRepository();</span><br><span class="line">    ServiceDescriptor serviceDescriptor = repository.registerService(getInterfaceClass());</span><br><span class="line">    repository.registerProvider(</span><br><span class="line">            getUniqueServiceName(),</span><br><span class="line">            ref,</span><br><span class="line">            serviceDescriptor,</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            serviceMetadata</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取服务注册中心</span></span><br><span class="line">    List&lt;URL&gt; registryURLs = ConfigValidationUtils.loadRegistries(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在每个协议下注册服务</span></span><br><span class="line">    <span class="keyword">int</span> protocolConfigNum = protocols.size();</span><br><span class="line">    <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">        String pathKey = URL.buildKey(getContextPath(protocolConfig)</span><br><span class="line">                .map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path)</span><br><span class="line">                .orElse(path), group, version);</span><br><span class="line">        <span class="comment">// In case user specified path, register service one more time to map it to path.</span></span><br><span class="line">        repository.registerService(pathKey, interfaceClass);</span><br><span class="line">        doExportUrlsFor1Protocol(protocolConfig, registryURLs, protocolConfigNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，Dubbo允许我们使用不同的协议导出服务，同时向多个注册中心注册服务。</p>
<p>进入到<strong>ServiceConfig#doExportUrlsFor1Protocol</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs, <span class="keyword">int</span> protocolConfigNum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//转义名默认为dubbo</span></span><br><span class="line">    String name = protocolConfig.getName();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        name = DUBBO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收集URL参数</span></span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(SIDE_KEY, PROVIDER_SIDE);</span><br><span class="line"></span><br><span class="line">    ServiceConfig.appendRuntimeParameters(map);</span><br><span class="line">    AbstractConfig.appendParameters(map, getMetrics());</span><br><span class="line">    AbstractConfig.appendParameters(map, getApplication());</span><br><span class="line">    AbstractConfig.appendParameters(map, getModule());</span><br><span class="line">    <span class="comment">// remove &#x27;default.&#x27; prefix for configs from ProviderConfig</span></span><br><span class="line">    <span class="comment">// appendParameters(map, provider, Constants.DEFAULT_KEY);</span></span><br><span class="line">    AbstractConfig.appendParameters(map, provider);</span><br><span class="line">    AbstractConfig.appendParameters(map, protocolConfig);</span><br><span class="line">    AbstractConfig.appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">    MetadataReportConfig metadataReportConfig = getMetadataReportConfig();</span><br><span class="line">    <span class="keyword">if</span> (metadataReportConfig != <span class="keyword">null</span> &amp;&amp; metadataReportConfig.isValid()) &#123;</span><br><span class="line">        map.putIfAbsent(METADATA_KEY, REMOTE_METADATA_STORAGE_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析收集org.apache.dubbo.config.annotation.Method注解参数</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(getMethods())) &#123;</span><br><span class="line">        <span class="keyword">for</span> (MethodConfig method : getMethods()) &#123;</span><br><span class="line">			<span class="comment">//省略...</span></span><br><span class="line">        &#125; <span class="comment">// end of methods for</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否泛化调用</span></span><br><span class="line">    <span class="keyword">if</span> (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">        map.put(GENERIC_KEY, generic);</span><br><span class="line">        map.put(METHODS_KEY, ANY_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">        <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(REVISION_KEY, revision);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       	<span class="comment">//获取接口方法并添加到URL参数</span></span><br><span class="line">        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">        <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;No method found in service interface &quot;</span> + interfaceClass.getName());</span><br><span class="line">            map.put(METHODS_KEY, ANY_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(METHODS_KEY, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">&quot;,&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加token到参数map</span></span><br><span class="line">    <span class="keyword">if</span> (ConfigUtils.isEmpty(token) &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        token = provider.getToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">            map.put(TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(TOKEN_KEY, token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//init serviceMetadata attachments</span></span><br><span class="line">    serviceMetadata.getAttachments().putAll(map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取主机和端口，得到最终的URL，如dubbo://192.168.1.1:20880/x.y.z.HelloService?a=b</span></span><br><span class="line">    String host = findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">    Integer port = findConfigedPorts(protocolConfig, name, map, protocolConfigNum);</span><br><span class="line">    URL url = <span class="keyword">new</span> URL(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path).orElse(path), map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加额外参数</span></span><br><span class="line">    <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">            .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String scope = url.getParameter(SCOPE_KEY);</span><br><span class="line">    <span class="comment">// don&#x27;t export when none is configured</span></span><br><span class="line">    <span class="keyword">if</span> (!SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">		<span class="comment">//是否本地导出</span></span><br><span class="line">        <span class="comment">// export to local if the config is not remote (export to remote only when config is remote)</span></span><br><span class="line">        <span class="keyword">if</span> (!SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            exportLocal(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是否远程导出</span></span><br><span class="line">        <span class="comment">// export to remote if the config is not local (export to local only when config is local)</span></span><br><span class="line">        <span class="keyword">if</span> (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(registryURLs)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (SERVICE_REGISTRY_PROTOCOL.equals(registryURL.getProtocol())) &#123;</span><br><span class="line">                        url = url.addParameterIfAbsent(REGISTRY_TYPE_KEY, SERVICE_REGISTRY_TYPE);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//if protocol is only injvm ,not register</span></span><br><span class="line">                    <span class="keyword">if</span> (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));</span><br><span class="line">                    <span class="comment">//加载监视器链接并追加</span></span><br><span class="line">                    URL monitorUrl = ConfigValidationUtils.loadMonitor(<span class="keyword">this</span>, registryURL);</span><br><span class="line">                    <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            logger.info(<span class="string">&quot;Register dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; url &quot;</span> + url + <span class="string">&quot; to registry &quot;</span> +</span><br><span class="line">                                    registryURL);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to url &quot;</span> + url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//是否使用自定义动态代理</span></span><br><span class="line">                    <span class="comment">// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class="line">                    String proxy = url.getParameter(PROXY_KEY);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                        registryURL = registryURL.addParameter(PROXY_KEY, proxy);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//生成代理类invoker</span></span><br><span class="line">                    Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass,</span><br><span class="line">                            registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));</span><br><span class="line">                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line">					</span><br><span class="line">                    <span class="comment">//导出服务，并生成exporter</span></span><br><span class="line">                    Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);</span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不存在注册中心，仅导出exporter</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to url &quot;</span> + url);</span><br><span class="line">                &#125;</span><br><span class="line">                Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);</span><br><span class="line">                exporters.add(exporter);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            MetadataUtils.publishServiceDefinition(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.urls.add(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里主要做了几件事：</p>
<ol>
<li>构建参数map，组装URL对象，这里需要注意的是，这里的 URL 不是<strong>java.net.URL</strong>，而是<strong>com.alibaba.dubbo.common.URL</strong>；</li>
<li>根据scope参数导出服务，同时生成代理Invoker：<ul>
<li>scope = none，不导出服务</li>
<li>scope != remote，导出到本地</li>
<li>scope != local，导出到远程</li>
</ul>
</li>
</ol>
<p>这里我们重点看下，导出到远程的服务导出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol PROTOCOL = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>

<p>根据<strong>registryURL</strong>可判断这里调用的是<strong>RegistryProtocol</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//获取注册地址</span></span><br><span class="line">    URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">    <span class="comment">//获取服务地址，即传递进来的export参数，如dubbo://...</span></span><br><span class="line">    <span class="comment">// url to export locally</span></span><br><span class="line">    URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向注册中心进行订阅 override 数据</span></span><br><span class="line">    <span class="comment">// Subscribe the override data</span></span><br><span class="line">    <span class="comment">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call</span></span><br><span class="line">    <span class="comment">//  the same service. Because the subscribed is cached key with the name of the service, it causes the</span></span><br><span class="line">    <span class="comment">//  subscription information to cover.</span></span><br><span class="line">    <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);</span><br><span class="line">    <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">    providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class="line">    <span class="comment">//导出到provider</span></span><br><span class="line">    <span class="comment">// export invoker</span></span><br><span class="line">    <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// url to registry</span></span><br><span class="line">    <span class="comment">//获取注册中心实例</span></span><br><span class="line">    <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">    <span class="keyword">final</span> URL registeredProviderUrl = getUrlToRegistry(providerUrl, registryUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// decide if we need to delay publish</span></span><br><span class="line">    <span class="keyword">boolean</span> register = providerUrl.getParameter(REGISTER_KEY, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (register) &#123;</span><br><span class="line">        <span class="comment">//注册</span></span><br><span class="line">        registry.register(registeredProviderUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register stated url on provider model</span></span><br><span class="line">    registerStatedUrl(registryUrl, registeredProviderUrl, register);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">    exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deprecated! Subscribe to override rules in 2.6.x or before.</span></span><br><span class="line">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">    notifyExport(exporter);</span><br><span class="line">    <span class="comment">//Ensure that a new exporter instance is returned every time export</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;&gt;(exporter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到<strong>RegistryProtocol#doLocalExport</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private &lt;T&gt; ExporterChangeableWrapper&lt;T&gt; doLocalExport(final Invoker&lt;T&gt; originInvoker, URL providerUrl) &#123;</span><br><span class="line">    String key &#x3D; getCacheKey(originInvoker);</span><br><span class="line"></span><br><span class="line">    return (ExporterChangeableWrapper&lt;T&gt;) bounds.computeIfAbsent(key, s -&gt; &#123;</span><br><span class="line">        Invoker&lt;?&gt; invokerDelegate &#x3D; new InvokerDelegate&lt;&gt;(originInvoker, providerUrl);</span><br><span class="line">        return new ExporterChangeableWrapper&lt;&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegate), originInvoker);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的运行时协议是dubbo，url以”dubbo://“开头的话，则protocol实例则是<strong>DubboProtocol</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取服务标识</span></span><br><span class="line">    <span class="comment">// export service.</span></span><br><span class="line">    String key = serviceKey(url);</span><br><span class="line">    <span class="comment">//创建DubboExporter并放入缓存</span></span><br><span class="line">    DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">    exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//export an stub service for dispatching event</span></span><br><span class="line">    Boolean isStubSupportEvent = url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);</span><br><span class="line">    Boolean isCallbackservice = url.getParameter(IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">        String stubServiceMethods = url.getParameter(STUB_EVENT_METHODS_KEY);</span><br><span class="line">        <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;consumer [&quot;</span> + url.getParameter(INTERFACE_KEY) +</span><br><span class="line">                        <span class="string">&quot;], has set stubproxy support event ,but no stub methods founded.&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动本地服务器</span></span><br><span class="line">    openServer(url);</span><br><span class="line">    optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动服务器之后，就是注册服务了，这里不再细说。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文简单分析了，Dubbo的启动过程，包括：</p>
<ol>
<li><strong>@EnableDubbo</strong>注解的原理及Dubbo的启动入口；</li>
<li>Dubbo服务导出的过程：包括URL组装、服务的导出及本地服务的启动等；</li>
</ol>
]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo源码学习：服务引用</title>
    <url>/2024/07/13/Dubbo%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>在上一篇中我们学习了Dubbo服务导出的过程，在开发中，如果我们需要引用一个服务的话，只需要在成员或方法上标注**@DubboReference**注解即可，那它内部是如何实现的呢，我们一起来看下。</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Dubbo 2.7.12版本</p>
</blockquote>
<h3 id="DubboReference注解的解析"><a href="#DubboReference注解的解析" class="headerlink" title="@DubboReference注解的解析"></a>@DubboReference注解的解析</h3><p>在通过**@EnableDubbo<strong>注解导入的</strong>DubboComponentScanRegistrar**：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata);</span><br><span class="line"></span><br><span class="line">        registerServiceClassPostProcessor(packagesToScan, registry);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// @since 2.7.6 Register the common beans</span></span><br><span class="line">        registerCommonBeans(registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>DubboBeanUtils#registerCommonBeans</strong>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerCommonBeans</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since 2.5.7 Register @Reference Annotation Bean Processor as an infrastructure Bean</span></span><br><span class="line">    registerInfrastructureBean(registry, ReferenceAnnotationBeanPostProcessor.BEAN_NAME,</span><br><span class="line">            ReferenceAnnotationBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转到<strong>ReferenceAnnotationBeanPostProcessor</strong>，查看类继承关系图：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20240713190631268.png" alt="image-20240713190631268"></p>
<p>可发现这是一个<strong>BeanPostProcessor</strong>的实现类，并实现了<strong>InstantiationAwareBeanPostProcessor</strong>和<strong>MergedBeanDefinitionPostProcessor</strong>，了解过@Autowired的注入原理的看到这里应该都会有一种熟悉感，回到其代码实现可以看到其父类<strong>AbstractAnnotationBeanPostProcessor</strong>实现了<strong>postProcessPropertyValues</strong>，不难看出，该方法也是**@DubboReference**解析的入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">//解析注解元数据</span></span><br><span class="line">    InjectionMetadata metadata = findInjectionMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//注入</span></span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Injection of @&quot;</span> + getAnnotationType().getSimpleName()</span><br><span class="line">                + <span class="string">&quot; dependencies is failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractAnnotationBeanPostProcessor#findInjectionMetadata</strong>主要是解析并获取成员或方法上的**@DubboReference<strong>注解，封装并得到</strong>AbstractAnnotationBeanPostProcessor.AnnotatedInjectionMetadata**类型对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AbstractAnnotationBeanPostProcessor.<span class="function">AnnotatedInjectionMetadata <span class="title">buildAnnotatedMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//解析要成员上的@DubboReference注解</span></span><br><span class="line">    Collection&lt;AbstractAnnotationBeanPostProcessor.AnnotatedFieldElement&gt; fieldElements = findFieldAnnotationMetadata(beanClass);</span><br><span class="line">    <span class="comment">//解析要方法上的@DubboReference注解</span></span><br><span class="line">    Collection&lt;AbstractAnnotationBeanPostProcessor.AnnotatedMethodElement&gt; methodElements = findAnnotatedMethodMetadata(beanClass);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AbstractAnnotationBeanPostProcessor.AnnotatedInjectionMetadata(beanClass, fieldElements, methodElements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后统一调用<strong>InjectionMetadata#inject</strong>方法进行注入，继续追踪则来到了<strong>ReferenceAnnotationBeanPostProcessor#doGetInjectedBean</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doGetInjectedBean</span><span class="params">(AnnotationAttributes attributes, Object bean, String beanName, Class&lt;?&gt; injectedType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   InjectionMetadata.InjectedElement injectedElement)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//生成ServiceBean名称</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The name of bean that annotated Dubbo&#x27;s &#123;<span class="doctag">@link</span> Service <span class="doctag">@Service</span>&#125; in local Spring &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String referencedBeanName = buildReferencedBeanName(attributes, injectedType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成ReferenceBean名称</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The name of bean that is declared by &#123;<span class="doctag">@link</span> Reference <span class="doctag">@Reference</span>&#125; annotation injection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String referenceBeanName = getReferenceBeanName(attributes, injectedType);</span><br><span class="line"></span><br><span class="line">    referencedBeanNameIdx.computeIfAbsent(referencedBeanName, k -&gt; <span class="keyword">new</span> TreeSet&lt;String&gt;()).add(referenceBeanName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成ReferenceBean</span></span><br><span class="line">    ReferenceBean referenceBean = buildReferenceBeanIfAbsent(referenceBeanName, attributes, injectedType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否本地Service</span></span><br><span class="line">    <span class="keyword">boolean</span> localServiceBean = isLocalServiceBean(referencedBeanName, referenceBean, attributes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保待注入服务已经导出</span></span><br><span class="line">    prepareReferenceBean(referencedBeanName, referenceBean, localServiceBean);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册ReferenceBean到Spring容器</span></span><br><span class="line">    registerReferenceBean(referencedBeanName, referenceBean, localServiceBean, referenceBeanName);</span><br><span class="line"></span><br><span class="line">    cacheInjectedReferenceBean(referenceBean, injectedElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对ReferenceBean应用其他bean后置处理器</span></span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().applyBeanPostProcessorsAfterInitialization(referenceBean.get(), referenceBeanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，<strong>buildReferencedBeanName</strong>生成的是ServiceBean（服务提供者）的名称，生成的规则遵循<strong>ServiceBean:interfaceClassName:version:group</strong>，用于后续判断待注入的服务是否可以由本地提供，而<strong>getReferenceBeanName</strong>生成的是待注入的bean的名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder beanNameBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ServiceBean&quot;</span>);</span><br><span class="line">    <span class="comment">// Required</span></span><br><span class="line">    append(beanNameBuilder, interfaceClassName);</span><br><span class="line">    <span class="comment">// Optional</span></span><br><span class="line">    append(beanNameBuilder, version);</span><br><span class="line">    append(beanNameBuilder, group);</span><br><span class="line">    <span class="comment">// Build and remove last &quot;:&quot;</span></span><br><span class="line">    String rawBeanName = beanNameBuilder.toString();</span><br><span class="line">    <span class="comment">// Resolve placeholders</span></span><br><span class="line">    <span class="keyword">return</span> environment.resolvePlaceholders(rawBeanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是待注入的服务是本地暴露的服务，直接从spring容器里获取，并以referenceBeanName为名注册一个别名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerReferenceBean</span><span class="params">(String referencedBeanName, ReferenceBean referenceBean,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">boolean</span> localServiceBean, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	/是否本地ServiceBean</span><br><span class="line">    <span class="keyword">if</span> (localServiceBean) &#123;  <span class="comment">// If @Service bean is local one</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Get  the <span class="doctag">@Service</span>&#x27;s BeanDefinition from &#123;<span class="doctag">@link</span> BeanFactory&#125;</span></span><br><span class="line"><span class="comment">         * Refer to &#123;<span class="doctag">@link</span> ServiceClassPostProcessor#buildServiceBeanDefinition&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        AbstractBeanDefinition beanDefinition = (AbstractBeanDefinition) beanFactory.getBeanDefinition(referencedBeanName);</span><br><span class="line">        RuntimeBeanReference runtimeBeanReference = (RuntimeBeanReference) beanDefinition.getPropertyValues().get(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        <span class="comment">// The name of bean annotated @Service</span></span><br><span class="line">        String serviceBeanName = runtimeBeanReference.getBeanName();</span><br><span class="line">        <span class="comment">// register Alias rather than a new bean name, in order to reduce duplicated beans</span></span><br><span class="line">        beanFactory.registerAlias(serviceBeanName, beanName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Remote @Service Bean</span></span><br><span class="line">        <span class="keyword">if</span> (!beanFactory.containsBean(beanName)) &#123;</span><br><span class="line">            beanFactory.registerSingleton(beanName, referenceBean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果由远程提供服务的话，则注册ReferenceBean，后续通过<strong>ReferenceConfig#get</strong>方法获取实际的对象并调用其他的bean后置处理器。</p>
<h3 id="ReferenceBean的生成"><a href="#ReferenceBean的生成" class="headerlink" title="ReferenceBean的生成"></a>ReferenceBean的生成</h3><p>我们注意到，<strong>ReferenceBean</strong>实现了<strong>FactoryBean</strong>接口，实际注册的bean由<strong>getObject</strong>方法提供，查看其实现可以知道<strong>getObject</strong>中也调用了<strong>ReferenceConfig#get</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The invoker of ReferenceConfig(&quot;</span> + url + <span class="string">&quot;) has already destroyed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里判断接口代理对象是否存在，不存在则进行初始化。</p>
<p>来到<strong>init</strong>方法，我们重点关注下其中的<strong>createProxy</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否本地服务引用</span></span><br><span class="line">    <span class="keyword">if</span> (shouldJvmRefer(map)) &#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(LOCAL_PROTOCOL, LOCALHOST_VALUE, <span class="number">0</span>, interfaceClass.getName()).addParameters(map);</span><br><span class="line">        invoker = REF_PROTOCOL.refer(interfaceClass, url);</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Using injvm service &quot;</span> + interfaceClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        urls.clear();</span><br><span class="line">        <span class="comment">//配置了url属性，可能是点对点调用，也可能是写的注册中心的url</span></span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; <span class="comment">// user specified URL, could be peer-to-peer address, or register center&#x27;s address.</span></span><br><span class="line">            String[] us = SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">            <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">                    URL url = URL.valueOf(u);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isEmpty(url.getPath())) &#123;</span><br><span class="line">                        url = url.setPath(interfaceName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果是registry协议，说明连接的是注册中心，就设置refer参数到url</span></span><br><span class="line">                    <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">                        urls.add(url.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//参数合并</span></span><br><span class="line">                        urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// assemble URL from register center&#x27;s configuration</span></span><br><span class="line">            <span class="comment">// if protocols not injvm checkRegistry</span></span><br><span class="line">            <span class="keyword">if</span> (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) &#123;</span><br><span class="line">                <span class="comment">//加载注册中心url</span></span><br><span class="line">                checkRegistry();</span><br><span class="line">                List&lt;URL&gt; us = ConfigValidationUtils.loadRegistries(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(us)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                        URL monitorUrl = ConfigValidationUtils.loadMonitor(<span class="keyword">this</span>, u);</span><br><span class="line">                        <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//添加refer参数到url中</span></span><br><span class="line">                        urls.add(u.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (urls.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                            <span class="string">&quot;No such any registry to reference &quot;</span> + interfaceName + <span class="string">&quot; on the consumer &quot;</span> + NetUtils.getLocalHost() +</span><br><span class="line">                                    <span class="string">&quot; use dubbo version &quot;</span> + Version.getVersion() +</span><br><span class="line">                                    <span class="string">&quot;, please config &lt;dubbo:registry address=\&quot;...\&quot; /&gt; to your spring config.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//单个注册中心或服务提供者</span></span><br><span class="line">        <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">            URL registryURL = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//获取所有的 Invoker</span></span><br><span class="line">            <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                Invoker&lt;?&gt; referInvoker = REF_PROTOCOL.refer(interfaceClass, url);</span><br><span class="line">                <span class="keyword">if</span> (shouldCheck()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (referInvoker.isAvailable()) &#123;</span><br><span class="line">                        invokers.add(referInvoker);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        referInvoker.destroy();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    invokers.add(referInvoker);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">                    registryURL = url; <span class="comment">// use last registry url</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shouldCheck() &amp;&amp; invokers.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to check the status of the service &quot;</span></span><br><span class="line">                        + interfaceName</span><br><span class="line">                        + <span class="string">&quot;. No provider available for the service &quot;</span></span><br><span class="line">                        + (group == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : group + <span class="string">&quot;/&quot;</span>)</span><br><span class="line">                        + interfaceName +</span><br><span class="line">                        (version == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;:&quot;</span> + version)</span><br><span class="line">                        + <span class="string">&quot; from the multi registry cluster&quot;</span></span><br><span class="line">                        + <span class="string">&quot; use dubbo version &quot;</span> + Version.getVersion());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">// registry url is available</span></span><br><span class="line">                <span class="comment">//对有注册中心的Cluster 只用ZoneAwareCluster</span></span><br><span class="line">                <span class="comment">// for multi-subscription scenario, use &#x27;zone-aware&#x27; policy by default</span></span><br><span class="line">                String cluster = registryURL.getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME);</span><br><span class="line">                <span class="comment">// The invoker wrap sequence would be: ZoneAwareClusterInvoker(StaticDirectory) -&gt; FailoverClusterInvoker(RegistryDirectory, routing happens here) -&gt; Invoker</span></span><br><span class="line">                invoker = Cluster.getCluster(cluster, <span class="keyword">false</span>).join(<span class="keyword">new</span> StaticDirectory(registryURL, invokers));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// not a registry url, must be direct invoke.</span></span><br><span class="line">                String cluster = CollectionUtils.isNotEmpty(invokers)</span><br><span class="line">                        ?</span><br><span class="line">                        (invokers.get(<span class="number">0</span>).getUrl() != <span class="keyword">null</span> ? invokers.get(<span class="number">0</span>).getUrl().getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME) :</span><br><span class="line">                                Cluster.DEFAULT)</span><br><span class="line">                        : Cluster.DEFAULT;</span><br><span class="line">                invoker = Cluster.getCluster(cluster).join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Refer dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; from url &quot;</span> + invoker.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    URL consumerURL = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, map.remove(REGISTER_IP_KEY), <span class="number">0</span>, map.get(INTERFACE_KEY), map);</span><br><span class="line">    MetadataUtils.publishServiceDefinition(consumerURL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建服务代理</span></span><br><span class="line">    <span class="comment">// create service proxy</span></span><br><span class="line">    <span class="keyword">return</span> (T) PROXY_FACTORY.getProxy(invoker, ProtocolUtils.isGeneric(generic));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   整个过程，首先判断是否本地调用，若是，则调用<strong>InjvmProtocol</strong>的refer方法生成Invoker实例，否则读取直连配置项或注册中心url，并将读取到的url存储到urls中，若urls元素数量为1，则直接通过Protocol自适应拓展类构建 Invoker实例接口。若urls元素数量大于1，即存在多个注册中心或服务直连url，此时先根据url构建Invoker，然后再通过Cluster合并多个Invoker，最后生成服务代理类。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>@DubboReference</strong>的注解由<strong>ReferenceAnnotationBeanPostProcessor</strong>解析并注入，注入的对象是通过<strong>ReferenceBean#get</strong>根据实际情况生成的Invoker实例。</p>
]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
</search>
