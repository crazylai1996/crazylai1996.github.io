<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring Boot源码学习：DeferredResult的处理流程</title>
    <url>/2024/04/20/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9ADeferredResult%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>业务开发时，轮询可以被用于许多场景中，但把握轮询的频次不是一件容易的事情，频次过高会对服务端产生不小的压力，频次过低时，则无法保证实时性。而随着Servlet 3.0异步请求处理的特性支持，DeferredResult的出现很好的解决了这个问题。</p>
<span id="more"></span>

<h3 id="DeferredResult是什么"><a href="#DeferredResult是什么" class="headerlink" title="DeferredResult是什么"></a>DeferredResult是什么</h3><p>DeferredResult是Spring基于Servlet 3.0的异步请求处理功能实现的，它可以迟早地释放Tomcat的请求线程，由业务线程去处理业务逻辑，处理完成再把结果返回到客户端，这可以使得服务端能够处理更多请求，以提升服务端的并发处理能力。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeferredResultTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/deferredResult&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">deferredResult</span><span class="params">(<span class="meta">@RequestParam(defaultValue = &quot;1000&quot;)</span> <span class="keyword">long</span> sleepMills)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3s超时时间</span></span><br><span class="line">        DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;&gt;(<span class="number">3000L</span>);</span><br><span class="line">        deferredResult.onCompletion(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;请求完成&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        deferredResult.onTimeout(() -&gt; &#123;</span><br><span class="line">            deferredResult.setResult(<span class="string">&quot;请求超时了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用新的业务线程去处理</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(sleepMills);</span><br><span class="line">                deferredResult.setResult(<span class="string">&quot;处理成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">return</span> deferredResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DeferredResult的处理流程"><a href="#DeferredResult的处理流程" class="headerlink" title="DeferredResult的处理流程"></a>DeferredResult的处理流程</h3><p>我们都知道，在Spring中，所有的请求都是由DispatcherServlet处理的，异步请求也不例外：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	HttpServletRequest processedRequest = request;</span><br><span class="line">	HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//根据HttpServletRequest 创建或者从缓存中获取 WebAsyncManager 对象</span></span><br><span class="line">	WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">		Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			processedRequest = checkMultipart(request);</span><br><span class="line">			multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Determine handler for the current request.</span></span><br><span class="line">			mappedHandler = getHandler(processedRequest);</span><br><span class="line">			<span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">				noHandlerFound(processedRequest, response);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">			HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">			String method = request.getMethod();</span><br><span class="line">			<span class="keyword">boolean</span> isGet = <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">			<span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">				<span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Actually invoke the handler.</span></span><br><span class="line">			mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">               <span class="comment">//异步请求开始时，直接返回</span></span><br><span class="line">			<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			applyDefaultViewName(processedRequest, mv);</span><br><span class="line">			mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//。。。</span></span><br><span class="line">		processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是，这里而会获取/或新创建一个<strong>WebAsyncManager</strong>，该对象与当前请求绑定，用于对异步操作的管理，比如处理结果的传递、上下文的保存等。</p>
<p>对于返回结果为DeferredResult的Controller方法，Spring通过<strong>DeferredResultMethodReturnValueHandler</strong>来区分和处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeferredResultMethodReturnValueHandler</span> <span class="keyword">implements</span> <span class="title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">		Class&lt;?&gt; type = returnType.getParameterType();</span><br><span class="line">		<span class="keyword">return</span> (DeferredResult.class.isAssignableFrom(type) ||</span><br><span class="line">				ListenableFuture.class.isAssignableFrom(type) ||</span><br><span class="line">				CompletionStage.class.isAssignableFrom(type));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">			ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">			mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		DeferredResult&lt;?&gt; result;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//处理返回类型为DeferredResult、ListenableFuture、CompletionStage的结果</span></span><br><span class="line">		<span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> DeferredResult) &#123;</span><br><span class="line">			result = (DeferredResult&lt;?&gt;) returnValue;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> ListenableFuture) &#123;</span><br><span class="line">			result = adaptListenableFuture((ListenableFuture&lt;?&gt;) returnValue);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> CompletionStage) &#123;</span><br><span class="line">			result = adaptCompletionStage((CompletionStage&lt;?&gt;) returnValue);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Should not happen...</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unexpected return value type: &quot;</span> + returnValue);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理DeferredResult请求</span></span><br><span class="line">		WebAsyncUtils.getAsyncManager(webRequest).startDeferredResultProcessing(result, mavContainer);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>来到<strong>WebAsyncManager#startDeferredResultProcessing</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Start concurrent request processing and initialize the given</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> DeferredResult&#125; with a &#123;<span class="doctag">@link</span> DeferredResultHandler&#125; that saves</span></span><br><span class="line"><span class="comment"> * the result and dispatches the request to resume processing of that</span></span><br><span class="line"><span class="comment"> * result. The &#123;<span class="doctag">@code</span> AsyncWebRequest&#125; is also updated with a completion</span></span><br><span class="line"><span class="comment"> * handler that expires the &#123;<span class="doctag">@code</span> DeferredResult&#125; and a timeout handler</span></span><br><span class="line"><span class="comment"> * assuming the &#123;<span class="doctag">@code</span> DeferredResult&#125; has a default timeout result.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deferredResult the DeferredResult instance to initialize</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> processingContext additional context to save that can be accessed</span></span><br><span class="line"><span class="comment"> * via &#123;<span class="doctag">@link</span> #getConcurrentResultContext()&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception if concurrent processing failed to start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getConcurrentResult()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getConcurrentResultContext()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDeferredResultProcessing</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> DeferredResult&lt;?&gt; deferredResult, Object... processingContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	Assert.notNull(deferredResult, <span class="string">&quot;DeferredResult must not be null&quot;</span>);</span><br><span class="line">	Assert.state(<span class="keyword">this</span>.asyncWebRequest != <span class="keyword">null</span>, <span class="string">&quot;AsyncWebRequest must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Long timeout = deferredResult.getTimeoutValue();</span><br><span class="line">	<span class="keyword">if</span> (timeout != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.asyncWebRequest.setTimeout(timeout);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	List&lt;DeferredResultProcessingInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	interceptors.add(deferredResult.getInterceptor());</span><br><span class="line">	interceptors.addAll(<span class="keyword">this</span>.deferredResultInterceptors.values());</span><br><span class="line">	interceptors.add(timeoutDeferredResultInterceptor);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> DeferredResultInterceptorChain interceptorChain = <span class="keyword">new</span> DeferredResultInterceptorChain(interceptors);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.asyncWebRequest.addTimeoutHandler(() -&gt; &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			interceptorChain.triggerAfterTimeout(<span class="keyword">this</span>.asyncWebRequest, deferredResult);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			setConcurrentResultAndDispatch(ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.asyncWebRequest.addErrorHandler(ex -&gt; &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!interceptorChain.triggerAfterError(<span class="keyword">this</span>.asyncWebRequest, deferredResult, ex)) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			deferredResult.setErrorResult(ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable interceptorEx) &#123;</span><br><span class="line">			setConcurrentResultAndDispatch(interceptorEx);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.asyncWebRequest.addCompletionHandler(()</span><br><span class="line">			-&gt; interceptorChain.triggerAfterCompletion(<span class="keyword">this</span>.asyncWebRequest, deferredResult));</span><br><span class="line"></span><br><span class="line">	interceptorChain.applyBeforeConcurrentHandling(<span class="keyword">this</span>.asyncWebRequest, deferredResult);</span><br><span class="line">	<span class="comment">//1. 开启异步处理</span></span><br><span class="line">       startAsyncProcessing(processingContext);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		interceptorChain.applyPreProcess(<span class="keyword">this</span>.asyncWebRequest, deferredResult);</span><br><span class="line">		<span class="comment">//2. 设置ResultHandler处理器</span></span><br><span class="line">           deferredResult.setResultHandler(result -&gt; &#123;</span><br><span class="line">			result = interceptorChain.applyPostProcess(<span class="keyword">this</span>.asyncWebRequest, deferredResult, result);</span><br><span class="line">			setConcurrentResultAndDispatch(result);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		setConcurrentResultAndDispatch(ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从方法注释中，我们也可以看出，该方法：</p>
<ol>
<li>开启异步处理，将当前请求标记为异步请求，以便Tomcat能够识别；</li>
<li>针对当前的DeferredResult，设置了一个结果处理器；</li>
</ol>
<p>而当我们调用<strong>DeferredResult#setResult</strong>时，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setResult</span><span class="params">(T result)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> setResultInternal(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setResultInternal</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isSetOrExpired()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DeferredResultHandler resultHandlerToUse;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isSetOrExpired()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.result = result;</span><br><span class="line">		<span class="comment">//取当前设置的ResultHandler</span></span><br><span class="line">		resultHandlerToUse = <span class="keyword">this</span>.resultHandler;</span><br><span class="line">		<span class="keyword">if</span> (resultHandlerToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.resultHandler = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//处理</span></span><br><span class="line">	resultHandlerToUse.handleResult(result);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，实际调用的是在<strong>WebAsyncManager#startDeferredResultProcessing</strong>设置的进去的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setConcurrentResultAndDispatch</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (WebAsyncManager.<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.concurrentResult != RESULT_NONE) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">           <span class="comment">//设置结果</span></span><br><span class="line">		<span class="keyword">this</span>.concurrentResult = result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.asyncWebRequest.isAsyncComplete()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Async result set but request already complete: &quot;</span> + formatRequestUri());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		<span class="keyword">boolean</span> isError = result <span class="keyword">instanceof</span> Throwable;</span><br><span class="line">		logger.debug(<span class="string">&quot;Async &quot;</span> + (isError ? <span class="string">&quot;error&quot;</span> : <span class="string">&quot;result set&quot;</span>) + <span class="string">&quot;, dispatch to &quot;</span> + formatRequestUri());</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">//将请求再次分发，该请求将重新进入DispatcherServlet的doDispatch方法进行处理</span></span><br><span class="line">	<span class="keyword">this</span>.asyncWebRequest.dispatch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次进入<strong>DispatcherServlet#doDispatch</strong>方法，通过debug可以发现，asyncManager这里已经拿到了处理结果：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20240420181952931.png" alt="image-20240420181952931"></p>
<p>而在后续通过<strong>RequestMappingHandlerAdapter</strong>调用具体的Controller方法时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">		asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">		asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">		asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">		asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line">		<span class="comment">//当前异步请求是否有了结果</span></span><br><span class="line">		<span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">			Object result = asyncManager.getConcurrentResult();</span><br><span class="line">			mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">			asyncManager.clearConcurrentResult();</span><br><span class="line">			LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">				String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;Resume with async result [&quot;</span> + formatted + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">			&#125;);</span><br><span class="line">               <span class="comment">//替换原始反射方法，该方法返回最终结果</span></span><br><span class="line">			invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">		<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		webRequest.requestCompleted();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，原来的Controller方法会被替换，替换后的invokeAndHandle将直接返回最终处理结果，返回类型也不再是DeferredResult，结果被返回给客户端。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li><p> 在Spring中使用异步请求可以将返回值定义为<strong>DeferredResult</strong>；</p>
</li>
<li><p>Spring通过<strong>DeferredResultMethodReturnValueHandler</strong>针对返回类型为DeferredResult的Controller方法返回值进行特殊处理：</p>
<p>​    a. 开启异步请求；</p>
<p>​    b.设置结果回调处理器DeferredResultHandler； </p>
</li>
<li><p>DeferredResult设置返回结果后，将触发DeferredResultHandler处理器的执行，该处理器将对原请求重新分发处理，并将最终结果 保存在了<strong>WebAsyncManager</strong>中，随后触发了<strong>DispatcherServlet#doDispatch</strong>的再次执行；</p>
</li>
<li><p>第二次<strong>DispatcherServlet#doDispatch</strong>执行过程中，将通过<strong>WebAsyncManager</strong>拿到处理结果，将在后续替换掉原有Controller方法的调用，将最终结果返回给客户端。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：AOP代理对象的创建</title>
    <url>/2023/06/14/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9AAOP%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AOP是Spring中的核心功能之一，使用AOP，可以让关注点代码与业务代码分离，并且动态地添加和删除在切面上的逻辑而不影响原来的执行代码，从而可以在不修改源代码的情况下，实现对功能的增强。</p>
<p>AOP的应用场景很多，日志记录、性能监控、事务管理等都可以通过AOP去实现。</p>
<p>AOP的原理就是动态代理，在 Spring 中，存在两种实现机制， JDK 动态代理以及 CGLIB 动态代理。</p>
<p>在Spring Boot中，AOP可以通过**@EnableAspectJAutoProxy**注解开启，那该注解是怎么起作用的呢，代理对象又是如何被创建的呢？</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<h2 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed</span></span><br><span class="line"><span class="comment">	 * to standard Java interface-based proxies. The default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Indicate that the proxy should be exposed by the AOP framework as a &#123;<span class="doctag">@code</span> ThreadLocal&#125;</span></span><br><span class="line"><span class="comment">	 * for retrieval via the &#123;<span class="doctag">@link</span> org.springframework.aop.framework.AopContext&#125; class.</span></span><br><span class="line"><span class="comment">	 * Off by default, i.e. no guarantees that &#123;<span class="doctag">@code</span> AopContext&#125; access will work.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.3.1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该注解@Import了<strong>AspectJAutoProxyRegistrar</strong>这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers an &#123;<span class="doctag">@link</span> org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line"><span class="comment"> * AnnotationAwareAspectJAutoProxyCreator&#125; against the current &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment"> * as appropriate based on a given @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy&#125; annotation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span></span><br><span class="line"><span class="comment">	 * of the @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">		AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">				AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">		<span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">				AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line">				AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由类注释可以看出，<strong>AspectJAutoProxyRegistrar</strong>的作用是向IOC容器注册<strong>AnnotationAwareAspectJAutoProxyCreator</strong>。那么<strong>AnnotationAwareAspectJAutoProxyCreator</strong>是什么呢?</p>
<h2 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h2><p>我们先来看下<strong>AnnotationAwareAspectJAutoProxyCreator</strong>的类继承关系图：</p>
<p><img src="http://storage.laixiaoming.space/blog/AnnotationAwareAspectJAutoProxyCreator.jpg" alt="AnnotationAwareAspectJAutoProxyCreator"></p>
<p>可以发现，<strong>AnnotationAwareAspectJAutoProxyCreator</strong>：</p>
<ol>
<li>实现了<strong>BeanPostProcessor **接口，其关键方法</strong>postProcessBeforeInitialization<strong>和</strong>postProcessAfterInitialization<strong>将会在bean创建过程中的初始化流程中</strong>AbstractAutowireCapableBeanFactory#initializeBean<strong>被调用，而AOP代理代理对象也是通过</strong>postProcessAfterInitialization**得到；</li>
<li>实现了<strong>InstantiationAwareBeanPostProcessor</strong>接口，其关键方法<strong>postProcessBeforeInstantiation</strong>会在bean实例化前尝试被调用；</li>
<li>实现了<strong>SmartInstantiationAwareBeanPostProcessor</strong>接口，其关键方法<strong>getEarlyBeanReference</strong>将会作为提前暴露代理对象的入口放入bean的三级缓存中；</li>
</ol>
<p>在本文中，我们主要关注<strong>postProcessAfterInitialization **方法，该方法在</strong>AbstractAutoProxyCreator**中被实现。</p>
<h2 id="AbstractAutoProxyCreator-postProcessAfterInitialization"><a href="#AbstractAutoProxyCreator-postProcessAfterInitialization" class="headerlink" title="AbstractAutoProxyCreator#postProcessAfterInitialization"></a>AbstractAutoProxyCreator#postProcessAfterInitialization</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="earlyProxyReferences"><a href="#earlyProxyReferences" class="headerlink" title="earlyProxyReferences"></a>earlyProxyReferences</h2><p>查看其引用，可以发现只在<strong>getEarlyBeanReference</strong>中被使用，而<strong>getEarlyBeanReference</strong>是在循环引用发生的情况下被调用，结合这里的判断不难看出，这里主要是防止代理对象的重复生成。</p>
<h3 id="wrapIfNecessary"><a href="#wrapIfNecessary" class="headerlink" title="wrapIfNecessary"></a>wrapIfNecessary</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前bean是否在targetSourcedBeans中存在，存在则表示已处理过</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否无需处理</span></span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//isInfrastructureClass判断是否基础设施类型，这里过滤了Advice、PointCut、Advisor、AopInfrastructureBean类型，</span></span><br><span class="line">    <span class="comment">//以及被@Advice标注的类</span></span><br><span class="line">    <span class="comment">//shouldSkip判断是否需要跳过该bean</span></span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取能对该bean进行增强的切面</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="shouldSkip"><a href="#shouldSkip" class="headerlink" title="shouldSkip"></a>shouldSkip</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加载所有的增强器，并将其缓存</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line">        <span class="comment">//跳过增强器类</span></span><br><span class="line">        <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;</span><br><span class="line">            ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用父类实现，如果是原始类型，则跳过</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.shouldSkip(beanClass, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用父类实现，加载Advisor类型的bean</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//加载被@Aspect标注的类，</span></span><br><span class="line">        <span class="comment">//并将@Around、@Before、@After、@AfterReturning、@AfterThrowing标注的方法等构建为Advisor并返回</span></span><br><span class="line">        advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="getAdvicesAndAdvisorsForBean"><a href="#getAdvicesAndAdvisorsForBean" class="headerlink" title="getAdvicesAndAdvisorsForBean"></a>getAdvicesAndAdvisorsForBean</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">			Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line">	<span class="comment">//找到符合条件的增强器</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加载所有的增加器，该方法在shouldSkip中调用过一次，再次调用将从缓存中获取</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="comment">//过滤出匹配到的增强器，这里会根据切入点（@Pointcut）表达式去匹配该bean</span></span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="createProxy"><a href="#createProxy" class="headerlink" title="createProxy"></a>createProxy</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建代理工厂</span></span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    <span class="comment">//从当前类复制配置</span></span><br><span class="line">    proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组合所有增强器，并将其放入代理工厂</span></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过代理工厂创建代理对象</span></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="getProxy"><a href="#getProxy" class="headerlink" title="getProxy"></a>getProxy</h4><p>创建代理对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">        activate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">                                         <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终来到DefaultAopProxyFactory，然后是我们熟悉的逻辑：</p>
<ol>
<li>如果目标对象有接口，用JDK动态代理；</li>
<li>如果没有接口，用CGLIB动态代理；</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>AOP代理对象的创建通过<strong>AnnotationAwareAspectJAutoProxyCreator</strong>实现，该类是<strong>BeanPostProcessor</strong>的子类，并且在不存在循环依赖的情况下，是在<strong>postProcessAfterInitialization</strong>方法中创建的；</li>
<li><strong>postProcessAfterInitialization</strong>中，会匹配出所有和当前Bean相关的增强器，并最终根据实际情况判断是使用JDK动态代理，还是CGLIB动态代理；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：自动配置原理</title>
    <url>/2023/05/02/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“约定优于配置”是Spring Boot倡导的一个思想，而其自动配置的特性则恰好体现了这一思想。而有了自动配置，不仅简化了Maven的依赖配置，更重要的是摆脱了以往使用Spring框架开发时，所必须编写的一堆繁琐的xml配置文件。</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<h2 id="从-SpringBootApplication注解说起"><a href="#从-SpringBootApplication注解说起" class="headerlink" title="从@SpringBootApplication注解说起"></a>从@SpringBootApplication注解说起</h2><p>我们都知道，一个Spring Boot主启动类上必须标注@SpringBootApplication注解，点开这个注解我们可以看到这是一个组合注解，其中关键的注解有@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan这3个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点开@SpringBootConfiguration，可以看到它被@Configuration标注，这表明了我们的启动类同时也是一个配置类，这一点需要注意，因为Spring Boot整个启动流程可以说都是围绕着我们的主启动类进行的。</p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Import注解的作用是将目标类作为Bean添加到IOC容器，通常用于将多个分散的配置类融合成一个更大的配置类。@Import支持导入<strong>普通类</strong>、<strong>配置类</strong>、<strong>ImportSelector 的实现类</strong>以及<strong>ImportBeanDefinitionRegistrar 的实现类</strong>。</p>
<h4 id="AutoConfigurationImportSelector的作用"><a href="#AutoConfigurationImportSelector的作用" class="headerlink" title="AutoConfigurationImportSelector的作用"></a>AutoConfigurationImportSelector的作用</h4><p><img src="http://storage.laixiaoming.space/blog/AutoConfigurationImportSelector.jpg" alt="AutoConfigurationImportSelector"></p>
<p>AutoConfigurationImportSelector是DeferredImportSelector的实现类，而DeferredImportSelector继承了ImportSelector，而ImportSelector#selectImports方法正是用来获取需要实际导入到IOC容器的类名数组的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,</span><br><span class="line">                                                                              annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，在selectImports方法中，获取类名数组的关键方法就在于getAutoConfigurationEntry方法</p>
<h5 id="AutoConfigurationImportSelector-getAutoConfigurationEntry"><a href="#AutoConfigurationImportSelector-getAutoConfigurationEntry" class="headerlink" title="AutoConfigurationImportSelector#getAutoConfigurationEntry"></a>AutoConfigurationImportSelector#getAutoConfigurationEntry</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">			AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//获取候选的自动配置类</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到getCandidateConfigurations方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">                                                                         getBeanClassLoader());</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面调用了SpringFactoriesLoader的loadFactoryNames方法，并传入了<strong>EnableAutoConfiguration.class</strong>这样一个参数，继续深入可以发现在里面又调用了loadSpringFactories方法：</p>
<h5 id="SpringFactoriesLoader-loadFactoryNames"><a href="#SpringFactoriesLoader-loadFactoryNames" class="headerlink" title="SpringFactoriesLoader#loadFactoryNames"></a>SpringFactoriesLoader#loadFactoryNames</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">					classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">					ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">    URL url = urls.nextElement();</span><br><span class="line">    UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">    Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">        String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">        <span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">            result.add(factoryClassName, factoryName.trim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>通过代码可以看出，loadSpringFactories方法做的事情就是：</p>
<ol>
<li>扫描所有jar包路径下<strong>META-INF/spring.factories</strong>文件；</li>
<li>以Properties的形式加载加载该文件，将将其收集到Map返回；</li>
</ol>
<p>回到loadFactoryNames方法，在前面拿到了<strong>META-INF/spring.factories</strong>的Map内容后，会取出<strong>EnableAutoConfiguration.class</strong>对应的值，随后便将其添加到容器中。</p>
<p>那么<strong>META-INF/spring.factories</strong>都有着什么内容呢</p>
<h5 id="META-INF-spring-factories文件"><a href="#META-INF-spring-factories文件" class="headerlink" title="META-INF/spring.factories文件"></a><code>META-INF/spring.factories</code>文件</h5><p>这个文件可以在<strong>spring-boot-autoconfiguration</strong>包下找到，我在其中截取了部分<strong>EnableAutoConfiguration.class</strong>内容，不难看到，这些都是我们在日常开发中常见的配置类，这其实也解释了，为什么即便我们在项目中没有显示添加任何配置，而只要我们添加了对应的starter依赖，Spring Boot便会帮助我们创建对应的Bean：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>



<h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是@Import注解，点进AutoConfigurationPackages.Registrar可以发现其手动注册了一个<strong>BasePackages.class</strong>的Bean，并把主启动类的成员设置到<strong>BasePackages</strong>对象成员里；</p>
<p>那这样做有什么用呢？其实AutoConfigurationPackages类上的注释已经告诉了我们答案，它是设计来给其他模块或组件用的，相当于提供给了其他模块或组件获取根包的一个入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class <span class="keyword">for</span> storing auto-<span class="function">configuration packages <span class="keyword">for</span> reference <span class="title">later</span> <span class="params">(e.g. by JPA entity</span></span></span><br><span class="line"><span class="function"><span class="params">scanner)</span></span></span><br></pre></td></tr></table></figure>



<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>开启组件扫描，可以指定扫描路径，在不指定的情况下，会扫描当前配置类所在包及子包的所有组件，这也解释了，为什么我们在使用Spring Boot的时候，启动类要放在最外层。</p>
<p>到这里，不知道读者是否会有疑问，启动类被@Configuration修饰，它既然也是一个配置类，那么它是什么时候被注册到IOC容器的呢？</p>
<p>通过dubug启动过程，其实不难发现是在SpringApplication#prepareContext方法进行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//获取主启动类位置</span></span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line"><span class="comment">//加载</span></span><br><span class="line">load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Spring Boot通过 AutoConfigurationImportSelector，并扫描所有jar包目录中<strong>META-INF/spring.factories</strong>配置文件，并加载<code>org.springframework.boot.autoconfigure.EnableutoConfiguration</code>配置项中对应的自动配置类，这也是自动配置生效的原理；</li>
<li>主启动类也是一个配置类，而**@ComponentScan**会默认扫描当前配置类所在包及子包的所有组件；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务 -两阶段提交及Atomikos在Spring Boot的使用</title>
    <url>/2023/05/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20-%20%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8F%8AAtomikos%E5%9C%A8Spring%20Boot%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="基于XA规范的两阶段提交方式"><a href="#基于XA规范的两阶段提交方式" class="headerlink" title="基于XA规范的两阶段提交方式"></a>基于XA规范的两阶段提交方式</h2><p>事务在业务的开发中有着至关重要的作用，事务具有的ACID的特性能保证业务处理前后数据的一致性：<br><strong>原子性（Atomicity）：</strong> 事务执行的所有操作，要么全部执行，要么全部不执行；<br><strong>一致性（Consistency）：</strong> 事务的执行前后，数据的完整性保持一致；<br><strong>隔离性（Isolation）：</strong> 两个或多个事务并行执行时是互不干扰的；<br><strong>持久性（Durability）：</strong> 事务执行完成后，其对数据库数据的更改会被永久保存下来；<br>在单机环境下，数据库系统对事务的支持是比较完善的；但当对数据进行水平或垂直拆分，一个数据库节点变为多个数据库节点时，分布式事务就出现了。</p>
<span id="more"></span>

<h3 id="XA规范"><a href="#XA规范" class="headerlink" title="XA规范"></a>XA规范</h3><p>XA是X/Open组织提出的一个分布式事务的规范，其定义了一个分布式事务的处理模型——DTP。在DTP中定义了三个组件：<br>Application Program（AP）：应用程序，即业务层，它定义了事务的边界，以及构成该事务的特定操作；<br>Resource Manager（RM）：资源管理器，可以理解为一个DBMS系统，或者消息服务器管理系统；<br>Transaction Manager（TM）：事务管理器，也称为协调者，负责协调和管理事务；</p>
<p>AP与RM之间，AP通过RM提供的API进行交互，当需要进行分布式事务时，则向TM发起一个全局事务，TM与RM之间则通过XA接口进行交互，TM管理了到RM的链接，并实现了两阶段提交。</p>
<h3 id="两阶段提交流程（2PC）"><a href="#两阶段提交流程（2PC）" class="headerlink" title="两阶段提交流程（2PC）"></a>两阶段提交流程（2PC）</h3><p>XA规范中，多个RM状态之间的协调通过TM进行，而这个资源协调的过程采用了两阶段提交协议（2PC），2PC实际上是一种在多节点之间实现事务原子提交的算法，它用来确保所有节点要么全部提交，要么全部中止。</p>
<p>在2PC中，分为准备阶段和提交阶段：<br>第一阶段：发送一个准备请求到所有参与者节点，询问他们是否可以提交；</p>
<p>第二阶段：如果所有参与者节点回答“是”，则表示他们已准备好提交，那么协调者将在阶段2发出提交请求；</p>
<p><img src="http://storage.laixiaoming.space/blog/1p.jpg" alt="1p"></p>
<p><img src="http://storage.laixiaoming.space/blog/2p.jpg" alt="2p"></p>
<p>如果在准备阶段，有一个RM返回失败时，则在第二个阶段将回滚所有资源</p>
<p><img src="http://storage.laixiaoming.space/blog/1pc-error.jpg" alt="1pc-error"></p>
<p><img src="http://storage.laixiaoming.space/blog/2pc-error.jpg" alt="2pc-error"></p>
<h3 id="2PC的局限性"><a href="#2PC的局限性" class="headerlink" title="2PC的局限性"></a>2PC的局限性</h3><p>2PC能基本满足了事务的 ACID 特性，但也存在着明显的缺点：</p>
<ul>
<li>在事务的执行过程中，所有的参与节点都是阻塞型的，在并发量高的系统中，性能受限严重；</li>
<li>如果TM在commit前发生故障，那么所有参与节点会因为无法提交事务而处于长时间锁定资源的状态；</li>
<li>在实际情况中，由于分布式环境下的复杂性，TM在发送commit请求后，可能因为局部网络原因，导致只有部分参与者收到commit请求时，系统便出现了数据不一致的现象；</li>
<li>XA协议要求所有参与者需要与TM进行直接交互，但在微服务架构下，一个服务与多个RM直接关联常常是被不允许的；</li>
</ul>
<h2 id="Atomikos在Spring-Boot的使用"><a href="#Atomikos在Spring-Boot的使用" class="headerlink" title="Atomikos在Spring Boot的使用"></a>Atomikos在Spring Boot的使用</h2><p>Atomikos在XA中作为一个事务管理器（TM）存在。在Spring Boot应用中，可以通过Atomikos在应用中方便的引入分布式事务。<br>下面以一个简单的订单创建流程的为例：</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jta-atomikos&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.11&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.22&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><p>application.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">      order-db:</span><br><span class="line">        name: order-db</span><br><span class="line">        url: jdbc:mysql:&#x2F;&#x2F;localhost:3307&#x2F;order?useSSL&#x3D;false&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: mysql</span><br><span class="line">      product-db:</span><br><span class="line">        name: order-db</span><br><span class="line">        url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;product?useSSL&#x3D;false&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: mysql</span><br><span class="line">  jta:</span><br><span class="line">    transaction-manager-id: order-product-tx-manager</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; &quot;gdou.laixiaoming.atomikos.demo.mapper.order&quot;, sqlSessionFactoryRef &#x3D; &quot;orderSqlSessionFactory&quot;)</span><br><span class="line">public class OrderDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;druidOrderDataSource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.druid.order-db&quot;)</span><br><span class="line">    public DruidXADataSource druidOrderDataSource()&#123;</span><br><span class="line">        DruidXADataSource xaDataSource &#x3D; new DruidXADataSource();</span><br><span class="line">        return xaDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;orderDataSource&quot;)</span><br><span class="line">    public DataSource orderDataSource(</span><br><span class="line">            @Qualifier(&quot;druidOrderDataSource&quot;) DruidXADataSource druidOrderDataSource) &#123;</span><br><span class="line">        AtomikosDataSourceBean ds &#x3D; new AtomikosDataSourceBean();</span><br><span class="line">        ds.setXaDataSource(druidOrderDataSource);</span><br><span class="line">        ds.setXaDataSourceClassName(&quot;com.alibaba.druid.pool.xa.DruidXADataSource&quot;);</span><br><span class="line">        ds.setUniqueResourceName(&quot;orderDataSource&quot;);</span><br><span class="line">        return ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactory orderSqlSessionFactory(</span><br><span class="line">            @Qualifier(&quot;orderDataSource&quot;) DataSource orderDataSource) throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(orderDataSource);</span><br><span class="line">        return sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; &quot;gdou.laixiaoming.atomikos.demo.mapper.product&quot;, sqlSessionFactoryRef &#x3D; &quot;productSqlSessionFactory&quot;)</span><br><span class="line">public class ProductDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;druidProductDataSource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.druid.product-db&quot;)</span><br><span class="line">    public DruidXADataSource druidProductDataSource()&#123;</span><br><span class="line">        DruidXADataSource xaDataSource &#x3D; new DruidXADataSource();</span><br><span class="line">        return xaDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;productDataSource&quot;)</span><br><span class="line">    public DataSource productDataSource(</span><br><span class="line">            @Qualifier(&quot;druidProductDataSource&quot;) DruidXADataSource druidProductDataSource) &#123;</span><br><span class="line">        AtomikosDataSourceBean ds &#x3D; new AtomikosDataSourceBean();</span><br><span class="line">        ds.setXaDataSource(druidProductDataSource);</span><br><span class="line">        ds.setXaDataSourceClassName(&quot;com.alibaba.druid.pool.xa.DruidXADataSource&quot;);</span><br><span class="line">        ds.setUniqueResourceName(&quot;productDataSource&quot;);</span><br><span class="line">        return ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactory productSqlSessionFactory(</span><br><span class="line">            @Qualifier(&quot;productDataSource&quot;) DataSource productDataSource) throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(productDataSource);</span><br><span class="line">        return sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="构建商品服务"><a href="#构建商品服务" class="headerlink" title="构建商品服务"></a>构建商品服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ProductServiceImpl implements ProductService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductMapper productMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void updateInventory(Long productId) &#123;</span><br><span class="line">    	&#x2F;&#x2F;模拟异常流程</span><br><span class="line">        if(productId &#x3D;&#x3D; 2)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;更新库存失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        productMapper.updateInventory(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建订单服务"><a href="#构建订单服务" class="headerlink" title="构建订单服务"></a>构建订单服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderMapper orderMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor &#x3D; RuntimeException.class)</span><br><span class="line">    @Override</span><br><span class="line">    public void order(Long productId) &#123;</span><br><span class="line">        orderMapper.addOrder(productId);</span><br><span class="line">        productService.updateInventory(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class ServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testCommit() &#123;</span><br><span class="line">        orderService.order(1L);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testRollback() &#123;</span><br><span class="line">        orderService.order(2L);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过运行测试用例，我们可以发现testCommit()方法在订单库以及商品库的成功完成的修改；而testRollback()方法则因为商品服务异常进行了回滚，回滚后的订单库和商品库数据都恢复到了事务开启前的状态。</p>
<p>参考：<br>《大型网站系统与Java中间件实践》<br><a href="https://www.jianshu.com/p/f9bac5822d30">SpringBoot Atomikos 多数据源分布式事务</a></p>
]]></content>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务-基于可靠消息的最终一致性实现</title>
    <url>/2023/05/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20-%20%E5%9F%BA%E4%BA%8E%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="CAP与BASE"><a href="#CAP与BASE" class="headerlink" title="CAP与BASE"></a>CAP与BASE</h2><p>我们都知道，传统数据库事务具有ACID的特性，但在分布式环境下，追求强一致性在大多数情况下无法满足高性能需求。<br>分布式系统的CAP理论告诉我们，一致性、可用性、分区容忍性无法同时满足，最多只能满足其他两项。CAP理论描述如下：</p>
<ul>
<li>一致性（Consistency）：所有节点在同一时间读到同样的数据；</li>
<li>可用性（Availability）：无论是成功还是失败，每个请求都能收到一个反馈。可用性强调的是服务可用，不保证数据的正确性；</li>
<li>分区容忍性（Partition-Tolerance）：即使系统中有部分问题或者有消息的丢失，但系统仍然能够继续运行。分区容忍性强调的是集群对分区故障的容错能力；</li>
</ul>
<span id="more"></span>

<p>对于分布式系统而言，分区故障无法避免，因而分区容忍性在一个分布式系统中是必须要考虑的，这也意味着，设计一个分布式系统，我们只能在CAP中的C、A中作出选择，而BASE就是在C和A的选择中作出的一种权衡。<br>BASE可以说是AP系统的一种延伸，其描述如下：</p>
<ul>
<li>基本可用（Basically Available）：基本可用，允许分区失败；</li>
<li>软状态（Soft state）：软状态，一种中间状态，接受一段时间的状态不同步；</li>
<li>最终一致（Eventually consistent）：最终一致，系统在短暂时间内可能是不一致的，但能够保证最终的数据是一致的；<br>BASE通过牺牲了强一致性来获取高可用性，允许数据存在短暂的不一致，到这里其实我们可以发现，ACID强调的是数据一致性，而BASE强调的则是服务可用；</li>
</ul>
<h2 id="基于可靠消息的最终一致性"><a href="#基于可靠消息的最终一致性" class="headerlink" title="基于可靠消息的最终一致性"></a>基于可靠消息的最终一致性</h2><p>基于可靠消息实现的分布式事务遵循了BASE理论，它通过引入消息中间件，在基于可靠消息的前提下，协商多个节点异步完成整个分布式事务，如果某一步骤出现失败时，则进行一定次数的重试，必要情况下需要人工介入处理。<br>以下单为例，用户下单后，会给用户增加一定的积分，在这个流程中涉及了订单服务以及积分服务，如下图所示：</p>
<p><img src="http://storage.laixiaoming.space/blog/add-order.jpg" alt="add-order"></p>
<p>但这个流程其实存在3个问题：</p>
<ol>
<li>如果在订单服务的订单创建事务（1.2）执行成功了，在发送订单创建消息（1.3）后，由于网络不可达等因素，订单服务无法收到来自消息中间件的响应时，订单服务的本地事务是应该继续提交还是回滚呢；</li>
<li>如果订单创建消息发送成功，得到了消息中间件的正确响应，但订单服务的本地事务却提交失败了，但消息却已经投递出去了，这种情况又应该怎么处理呢；</li>
<li>订单创建消息已经成功投递到下游应用（积分服务），但积分服务的本地事务却执行失败了，又应该怎么处理呢<br>以上第1和第2个问题，其实可以归结于同一个问题，即如何保证消息发送的一致性，而第3个问题，即是如何确保消息一定能够消息成功；</li>
</ol>
<h3 id="如何保证消息发送的一致性"><a href="#如何保证消息发送的一致性" class="headerlink" title="如何保证消息发送的一致性"></a>如何保证消息发送的一致性</h3><p>我们可以采用两阶段提交的方式，但并不是所有的消息中间件都支持XA，况且，出现问题的概率不大，为此引入了两阶段提交，性能方面就需要有所妥协，这样的方案实现是否有点得不偿失？<br>这个问题其实RocketMQ有了实现方案，RocketMQ支持事务消息，其通过引入了“半消息”的概念（半消息对下游系统不可见），保证了本地事务执行与消息发送的一致性。其发送的正向流程如下：</p>
<ol>
<li>业务系统发送“半消息”；</li>
<li>消息中间件将“半消息”进行持久化；</li>
<li>业务系统得到消息发送结果，成功的话则执行本地事务，失败则结束流程；</li>
<li>本地事务执行，并将业务操作结果发送给消息中间件；</li>
<li>消息中间件根据业务系统的事务执行结果，选择将消息投放或者删除；</li>
</ol>
<p>但实际上仅凭以上这个流程其实还是没有办法保证消息发送的一致性的，比如<br>(1) 在业务系统接收消息中间件对“半消息”的处理结果时，由于网络、或者业务系统和消息中间件自身故障时，业务系统无法得知消息中间件的处理结果时，就会按照消息发送失败来处理，这个时候，就有可能存在，’本地事务未执行，但“半消息”却发送成功的不一致情况’；<br>(2) 本地事务执行后，将业务操作结果返回到消息中间件时，如果出现问题，那么消息中间件将不知道如何处理已经存在的“半消息”；<br>为应对以上两种不一致情况，RocketMQ在消息中间件一方引入了“事务回查”的反向流程，其执行流程如下：</p>
<ol>
<li>对于超过一定时长未处理的“半消息”，消息中间件将会回调业务系统询问本地事务的处理结果；</li>
<li>业务系统在检查事务操作结果，将结果返回给消息中间件；</li>
<li>消息中间件根据业务系统的事务执行结果，选择将消息投放或者删除；</li>
</ol>
<p>发送消息的正向流程和反向流程结合起来，就是解决消息发送一致性的整个方案。</p>
<p>以上面的下单流程为例，在引入了RocketMQ事务消息后，基本流程可以表示为：</p>
<p><img src="http://storage.laixiaoming.space/blog/add-order-rocketmq.jpg" alt="add-order-rocketmq"></p>
<h3 id="如何保证消息一定会被消费"><a href="#如何保证消息一定会被消费" class="headerlink" title="如何保证消息一定会被消费"></a>如何保证消息一定会被消费</h3><p>确保消息一定能够被消息的流程比较简单，我们只需要保证消息的持久化，并引入消息确认机制，只有在消息被明确消费完成后，将确认消息返回到消息中间时，消息才能够被丢弃，否则则进行一定次数的重试，需要注意的是，引入重试操作后，消费方的操作需要保证幂等性。</p>
<h2 id="RocketMQ整合实例"><a href="#RocketMQ整合实例" class="headerlink" title="RocketMQ整合实例"></a>RocketMQ整合实例</h2><p>该例子基于Spring Boot构建：</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.rocketmq&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.1.0&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="applition-yml配置"><a href="#applition-yml配置" class="headerlink" title="applition.yml配置"></a>applition.yml配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rocketmq:</span><br><span class="line">  name-server: localhost:9876</span><br><span class="line">  producer:</span><br><span class="line">    group: default-group</span><br><span class="line">    sendMessageTimeout: 5000</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  rocketmq:</span><br><span class="line">    orderTopic: order-paid-topic</span><br></pre></td></tr></table></figure>

<h3 id="构建订单服务"><a href="#构建订单服务" class="headerlink" title="构建订单服务"></a>构建订单服务</h3><h4 id="发送半消息"><a href="#发送半消息" class="headerlink" title="发送半消息"></a>发送半消息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;demo.rocketmq.orderTopic&#125;&quot;)</span><br><span class="line">    private String orderTopic;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addOrder() &#123;</span><br><span class="line">        int orderId &#x3D; new Random().nextInt(3) + 1;</span><br><span class="line">        Message message &#x3D; MessageBuilder.withPayload(orderId).build();</span><br><span class="line">        log.info(&quot;发送半消息, orderId &#x3D; &#123;&#125;&quot;, orderId);</span><br><span class="line">        rocketMQTemplate.sendMessageInTransaction(orderTopic, message, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="本地事务执行回调与事务状态回查"><a href="#本地事务执行回调与事务状态回查" class="headerlink" title="本地事务执行回调与事务状态回查"></a>本地事务执行回调与事务状态回查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RocketMQTransactionListener</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderTransactionListener implements RocketMQLocalTransactionListener &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;</span><br><span class="line">        &#x2F;&#x2F;执行本地事务</span><br><span class="line">        Integer orderId &#x3D; Integer.valueOf(new String((byte[])msg.getPayload()));</span><br><span class="line">        int status &#x3D; new Random().nextInt(3);</span><br><span class="line">        if (status &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            log.info(&quot;提交事务消息, orderId &#x3D; &#123;&#125;&quot;, orderId);</span><br><span class="line">            return RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (status &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            log.info(&quot;回滚事务消息, orderId &#x3D; &#123;&#125;&quot;, orderId);</span><br><span class="line">            return RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(&quot;事务消息中间状态, MQ需要回查事务状态&quot;);</span><br><span class="line">        return RocketMQLocalTransactionState.UNKNOWN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RocketMQLocalTransactionState checkLocalTransaction(Message msg) &#123;</span><br><span class="line">        Integer orderId &#x3D; Integer.valueOf(new String((byte[])msg.getPayload()));</span><br><span class="line">        RocketMQLocalTransactionState retState;</span><br><span class="line">        int status &#x3D; new Random().nextInt(3);</span><br><span class="line">        switch (status) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                retState &#x3D; RocketMQLocalTransactionState.UNKNOWN;</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                retState &#x3D; RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">            default:</span><br><span class="line">                retState &#x3D; RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;回查事务状态, orderId &#x3D; &#123;&#125;, status &#x3D; &#123;&#125;, retState &#x3D; &#123;&#125;&quot;,</span><br><span class="line">                orderId, status, retState);</span><br><span class="line">        return retState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建积分服务"><a href="#构建积分服务" class="headerlink" title="构建积分服务"></a>构建积分服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@RocketMQMessageListener(topic &#x3D; &quot;$&#123;demo.rocketmq.orderTopic&#125;&quot;, consumerGroup &#x3D; &quot;order_paid_consumer_default_group&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderPaidConsumer implements RocketMQListener&lt;MessageExt&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(MessageExt message) &#123;</span><br><span class="line">        Integer orderId &#x3D; Integer.valueOf(new String((byte[])message.getBody()));</span><br><span class="line">        log.info(&quot;orderId &#x3D; &#123;&#125;, 增加积分&quot;, orderId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<br>《大型网站系统与Java中间件实践》</p>
]]></content>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>实现延时任务可以有几种方式</title>
    <url>/2023/06/13/%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在开发中，延时任务属于比较常见的需求，比如，订单在限定时间内未支付则自动取消并释放库存；外卖的商家端在设置特定时间后仍未接单时则自动接单等这都需要延时任务来完成。<br>实现延时任务的方式可以有许多种：<br> 1 DelayQueue(JDK提供实现)<br> 2 ScheduledExecutorService(JDK提供实现)<br> 3 Redis(使用ZSET数据结构实现)<br> 4 RabbitMQ实现<br> 5 ……</p>
<span id="more"></span>

<p>下面我们来简单看看这几种方式的实现，并分析其优缺点。</p>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>DelayQueue属于JDK并发包<strong>java.util.concurrent</strong>中提供的一个类，它是一个无界阻塞队列，元素只有在延迟时间到达时才能被获取。该队列的元素必须实现Delayed接口，队列头部是剩余延迟时间最小的元素。<br>使用过程中，添加任务时使用add()方法，获取任务时使用poll()或take()方法，poll()方法和take()方法的区别是take()方法是阻塞的，如果没有到点的任务可取，take()方法会等待直到可用，而poll()方法则会直接返回null。<br>首先自定义延时任务类型，实现Delayed接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//延迟时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> delayTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务开始时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务消息</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayTask</span><span class="params">(<span class="keyword">long</span> delayTime, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delayTime = delayTime;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.startTime = System.currentTimeMillis() + delayTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelayTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delayTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDelayTime</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delayTime = delayTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStartTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStartTime</span><span class="params">(<span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startTime = startTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(startTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> diff = <span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="keyword">return</span> diff &gt; <span class="number">0</span> ? <span class="number">1</span> : (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过DelayQueue进行存取即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DelayQueue&lt;DelayTask&gt; delayQueue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line"><span class="comment">//添加任务</span></span><br><span class="line">delayQueue.add(t1);</span><br><span class="line"><span class="comment">//获取任务</span></span><br><span class="line">delayQueue.take();</span><br></pre></td></tr></table></figure>



<p>该方式实现非常简单，但缺点也是显而易见的，其适用于单机环境下，而且延迟任务没有进行持久化存储，一旦关机断电，任务便不存在。</p>
<h2 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h2><p>与DelayQueue一样，ScheduledExecutorService同属于<code>java.util.concurrent</code>包中，使用起来也是拿来即用，非常简单的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">executorService.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1s后执行&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>其优缺点与DelayQueue一般，这里就不多说了。</p>
<h2 id="Redis-使用ZSET数据结构实现"><a href="#Redis-使用ZSET数据结构实现" class="headerlink" title="Redis(使用ZSET数据结构实现)"></a>Redis(使用ZSET数据结构实现)</h2><p>ZSET是Redis提供的一种有序集合数据结构，集合的元素value会关联一个double类型的分数(score)，集合会根据这个分数来对元素进行从小到大的排序。<br>我们可以将延时任务消息序列化成一个字符串作为 zset 的value，这个任务消息的到期处理时间作为score进行存储，另外启用一个或者多个线程对集合中的任务进行到期判断处理（以当前时间为界限，获取到集合的首个元素，进行处理并从集合中删除元素），其中，在多线程环境下，为了使获取元素和移除元素的操作的原子性，我们可以使用lua脚本：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> minVal = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> maxVal = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> todolist = redis.call(<span class="string">&quot;ZRANGEBYSCORE&quot;</span>, key, minVal, maxVal, <span class="string">&quot;limit&quot;</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">local</span> todo = todolist[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> todo == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	redis.call(<span class="string">&quot;ZREM&quot;</span>, key, todo)</span><br><span class="line">	<span class="keyword">return</span> todo</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>使用Redis的这种延时任务实现适用于分布式环境，消息也能够保证持久化存储，但获取到期任务的时间间隔较难把握，同时也不能保证任务消息消费过程中的可靠性，就上面的实现来说，如果我们获取到了任务，但还没处理完成出现了异常，操作被中断了，那么这条任务是彻底丢失了。</p>
<h2 id="RabbitMQ实现"><a href="#RabbitMQ实现" class="headerlink" title="RabbitMQ实现"></a>RabbitMQ实现</h2><p>RabbitMQ本身并不提供延时任务功能的实现，但可以通过它的Time-To-Live Extensions 与 Dead Letter Exchange 的特性模拟出延迟队列的功能。<br>RabbitMQ支持为队列或者消息设置TTL（存活时间）。TTL表明了一条消息可在队列中存活的最大时间。当某条消息被设置了TTL或者当某条消息进入了设置了TTL的队列时（如果既配置了消息的TTL，又配置了队列的TTL，那么较小的那个值会被取用），这条消息会在TTL时间后死亡成为Dead Letter。如果为这个队列设置了<strong>x-dead-letter-exchange</strong>和<strong>x-dead-letter-routing-key</strong>，那么这些Dead Letter就会被重新发送到<strong>x-dead-letter-exchange</strong>指定的exchange中，然后通过根据<strong>x-dead-letter-routing-key</strong>路由到相应队列，这时我们通过监听<strong>x-dead-letter-exchange</strong>中绑定的队列，即可实现延迟队列的功能。<br>实例（Spring Boot下）：<br>配置文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.rabbitmq.virtual-host</span>=<span class="string">/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消息发送确认</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirms</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#消息没有相应队列和交换器绑定时是否返回，好像没有用？</span></span><br><span class="line"><span class="comment">#spring.rabbitmq.publisher-returns=true</span></span><br><span class="line"><span class="comment">#与return机制结合配置此属性，true返回消息，false丢弃消息</span></span><br><span class="line"><span class="comment">#spring.rabbitmq.template.mandatory=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消息消费手动确认</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class="string">manual</span></span><br></pre></td></tr></table></figure>

<p>RabbitMQ配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>, <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Dead Letter Exchange</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXEC_EXCHANGE_NAME = <span class="string">&quot;delayed.exec.exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Dead Letter Queue</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXEC_QUEUE_NAME = <span class="string">&quot;delayed.exec.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Dead Letter Routing Key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXEC_ROUTING_KEY = <span class="string">&quot;delayed.exec.routing.key&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXCHANGE_NAME = <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_QUEUE_NAME = <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_ROUTING_KEY = <span class="string">&quot;delayed.routing.key&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(CachingConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">        RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">        rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;correlationData:&quot;</span> + correlationData + <span class="string">&quot;,cause:&quot;</span> + cause);</span><br><span class="line">        <span class="keyword">if</span>(!ack)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送失败！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有找到对应的队列!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;message:&quot;</span> + message +</span><br><span class="line">                <span class="string">&quot;,replyCode:&quot;</span> + replyCode +</span><br><span class="line">                <span class="string">&quot;,replyText:&quot;</span> + replyText +</span><br><span class="line">                <span class="string">&quot;,exchange:&quot;</span> + exchange +</span><br><span class="line">                <span class="string">&quot;,routingKey:&quot;</span> + routingKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delayedQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DELAYED_EXEC_EXCHANGE_NAME);</span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, DELAYED_EXEC_ROUTING_KEY);</span><br><span class="line"><span class="comment">//        params.put(&quot;x-message-ttl&quot;, 5 * 1000);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAYED_QUEUE_NAME, <span class="keyword">true</span>,<span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">delayedExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(DELAYED_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">delayedBind</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayedExchange()).with(DELAYED_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delayedExecQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAYED_EXEC_QUEUE_NAME,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">delayedExecExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(DELAYED_EXEC_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">delayedExecBind</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedExecQueue()).to(delayedExecExchange()).with(DELAYED_EXEC_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RabbitMQ延迟消息发送：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDelayedMsg</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.DELAYED_EXCHANGE_NAME, RabbitMQConfig.DELAYED_ROUTING_KEY, data, message -&gt; &#123;</span><br><span class="line">            message.getMessageProperties().setExpiration(<span class="number">5</span> * <span class="number">1000</span> + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延迟队列监听：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMQConfig.DELAYED_EXEC_QUEUE_NAME&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delayedExec</span><span class="params">(String data, Message message, Channel channel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;data:&quot;</span> + data);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">//消息确认</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用RabbitMQ的延迟任务实现适用于分布式环境，并且消息也支持持久化，消息的发送和消费也因为有了确认机制的支持而有了更高的可靠性。但需要注意的是，用这种方式实现的延时任务，如果需要实现不同消息的消息有不同的延迟时间的话，共用一个队列是不可行的。比如两条消息，一条延迟时间为20s的消息先抵达队列，另一条延迟时间为10s的消息后抵达，那么此时的消息消费顺序是，经过20s后，第一条消息将会先被消费，第二条消息在紧接其后被消费（与入队顺序保持了一致），在这种情况下，就只能通过设置多个不同延时时间的队列来实现了。</p>
]]></content>
      <tags>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>认识高性能队列——Disruptor</title>
    <url>/2023/05/01/%E8%AE%A4%E8%AF%86%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Disruptor/</url>
    <content><![CDATA[<h2 id="Disruptor是什么"><a href="#Disruptor是什么" class="headerlink" title="Disruptor是什么"></a>Disruptor是什么</h2><p>Disruptor是一个由英国外汇交易公司LMAX研发并开源的高性能的有界内存队列，其主要用于在线程之间完成数据的传递。<a href="https://github.com/LMAX-Exchange/disruptor">github地址</a><br>那么，以高性能著称的Disruptor到底有多快呢？</p>
<span id="more"></span>

<p>我将常用的2种线程安全队列（ArrayBlockingQueue和LinkedBlockingQueue）与Disruptor作了个简单对比，场景是启动两个线程，一个线程往队列填充自增数字，另一个线程取数字进行累加，其对比结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000w</span><br><span class="line">ArrayBlockingQueue耗时：927ms</span><br><span class="line">LinkedBlockingQueue耗时：1495ms</span><br><span class="line">Disruptor耗时：598ms</span><br><span class="line">5000w</span><br><span class="line">ArrayBlockingQueue耗时：4044ms</span><br><span class="line">LinkedBlockingQueue耗时：11145ms</span><br><span class="line">Disruptor耗时：2824ms</span><br><span class="line">1e</span><br><span class="line">ArrayBlockingQueue耗时：7514ms</span><br><span class="line">LinkedBlockingQueue耗时：23144ms</span><br><span class="line">Disruptor耗时：4668ms</span><br></pre></td></tr></table></figure>
<p>可以看到，Disruptor在速度上较其他两个队列有着明显的优势。</p>
<h2 id="为什么可以这么快"><a href="#为什么可以这么快" class="headerlink" title="为什么可以这么快"></a>为什么可以这么快</h2><h3 id="内存预分配"><a href="#内存预分配" class="headerlink" title="内存预分配"></a>内存预分配</h3><p>在Disruptor里，底层存储为数组结构，而事件（Event）作为真实数据的一个载体，在初始化时会调用预设的EventFactory创建对应数量的Event填充数组，加上其环形数组的设计，数组中的Event对象可以很方便地实现复用，这在一定程度可以减少GC的次数，提升了性能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void fill(EventFactory&lt;E&gt; eventFactory)&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; bufferSize; i++)&#123;</span><br><span class="line">        entries[BUFFER_PAD + i] &#x3D; eventFactory.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消除“伪共享”，充分利用硬件缓存"><a href="#消除“伪共享”，充分利用硬件缓存" class="headerlink" title="消除“伪共享”，充分利用硬件缓存"></a>消除“伪共享”，充分利用硬件缓存</h3><h4 id="什么是“伪共享”"><a href="#什么是“伪共享”" class="headerlink" title="什么是“伪共享”"></a>什么是“伪共享”</h4><p>每个CPU核心都有自己独立的cache和寄存器，主存与CPU之间存在着多级cache，L3，L2，L1，而越靠近CPU核心，速度也越快，为也提高处理速度，处理器不直接与主存通信，主存的访问首先会进入cache，所有的修改默认会异步刷新到主存。同时在多核心处理器下，为了保证各个核心的缓存是一致的，会实现缓存一致性协议。<br>而伪共享指的是由于共享缓存行（通常为64个字节）导致缓存无效的场景：</p>
<p><img src="http://storage.laixiaoming.space/blog/cpu_cache.jpg" alt="cpu_cache"></p>
<p>就上图场景而言，线程1和线程2运行分别运行在两个核心上，线程1对putIndex读写，线程2对takeIndex读写，由于putIndex与takeIndex内存的相邻性，在加载到缓存时将被读到同一个缓存行中，而由于对其中一个变量的写操作会使缓存回写到主存，造成整个缓存行的失效，这也导致了同处于同一个缓存行的其他变量的缓存失效。</p>
<h4 id="它是如何被消除的"><a href="#它是如何被消除的" class="headerlink" title="它是如何被消除的"></a>它是如何被消除的</h4><p>一方面，底层采用数组结构，CPU在加载数据时，会根据空间局部性原理，把相邻的数据一起加载进来，由于由于数组上结构的内存分配是连续的，也就能更好地利用CPU的缓存；<br>另一方面，通过增加无意义变量，增大变量间的间隔，使得一个变量可以独占一个缓存行，以空间换取时间（注： Java 8 可以使用@Contended注解，配合JVM参数-XX:-RestrictContended，来消除“伪共享”）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LhsPadding</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;7*8个字节</span><br><span class="line">    protected long p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Value extends LhsPadding</span><br><span class="line">&#123;</span><br><span class="line">    protected volatile long value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RhsPadding extends Value</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;7*8个字节</span><br><span class="line">    protected long p9, p10, p11, p12, p13, p14, p15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无锁数据结构RingBuffer"><a href="#无锁数据结构RingBuffer" class="headerlink" title="无锁数据结构RingBuffer"></a>无锁数据结构RingBuffer</h3><p><img src="http://storage.laixiaoming.space/blog/ringbuffer.jpg" alt="ringbuffer"></p>
<p>RingBuffer作为Disruptor的底层数据结构，其内部有一个cursor变量，表示当前可读的最大下标，cursor是Sequence类的一个对象，其内部维护了一个long类型的value成员，value使用了volatile修饰，在不使用锁的前提下保证了线程之间的可见性，并通过Unsafe工具封装了对value变量的CAS系列操作。<br>关于volatile变量，有以下两个特性：<br>可见性：对一个volatile变量读，总能看到（任意线程）对这个变量的最后写入；<br>原子性：对任意单个volatile变量的读/写具有原子性；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Sequence extends RhsPadding</span><br><span class="line">&#123;</span><br><span class="line">	static final long INITIAL_VALUE &#x3D; -1L;</span><br><span class="line">    private static final Unsafe UNSAFE;</span><br><span class="line">    private static final long VALUE_OFFSET;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h4><p>RingBuffer数据的写入分为两个阶段，在第一阶段会先申请下一个可写入节点（cursor+1），多写入者模式下通过CAS操作移动cursor，来保存线程安全性；第二阶段，数据提交，提交时为保证顺序写，需要保证cursor追上当前提交的写入位置。<br>写入成功后，再调用具体的WaitStrategy实现通知其他消费线程</p>
<p><img src="http://storage.laixiaoming.space/blog/ringbuffer_write.jpg" alt="ringbuffer_write"></p>
<h4 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h4><p>在读取数据的时候，多个消费者可以同时消费，每个消费者都会维护有一个读取位置，在没有可读数据时，通过具体的WaitStrategy进行等待（阻塞等待或自旋等）。</p>
<p><img src="http://storage.laixiaoming.space/blog/ringbuffer_read.jpg" alt="ringbuffer_read"></p>
<h2 id="简单上手-生产者-消费者模型"><a href="#简单上手-生产者-消费者模型" class="headerlink" title="简单上手(生产者-消费者模型)"></a>简单上手(生产者-消费者模型)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DisruptorStart &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; RingBuffer大小，2的幂次</span><br><span class="line">        int bufferSize &#x3D; 1024;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建Disruptor</span><br><span class="line">        Disruptor&lt;LongEvent&gt; disruptor &#x3D; new Disruptor&lt;&gt;(</span><br><span class="line">                LongEvent::new,</span><br><span class="line">                bufferSize,</span><br><span class="line">                DaemonThreadFactory.INSTANCE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 事件消费</span><br><span class="line">        disruptor.handleEventsWith((event, sequence, endOfBatch) -&gt; System.out.println(&quot;Event: &quot; + event));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 启动</span><br><span class="line">        disruptor.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 拿到RingBuffer，用于向队列传输数据</span><br><span class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer &#x3D; disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">        ByteBuffer bb &#x3D; ByteBuffer.allocate(8);</span><br><span class="line">        for (long l &#x3D; 0; true; l++) &#123;</span><br><span class="line">            bb.putLong(0, l);</span><br><span class="line">            &#x2F;&#x2F;往队列填充数据</span><br><span class="line">            ringBuffer.publishEvent((event, sequence, buffer) -&gt; event.set(buffer.getLong(0)), bb);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考：<br><a href="https://ifeve.com/disruptor">并发框架Disruptor译文</a><br><a href="https://tech.meituan.com/2016/11/18/disruptor.html">高性能队列——Disruptor</a><br><a href="https://blog.csdn.net/twypx/article/details/80398886">Disruptor系列3：Disruptor样例实战</a></p>
]]></content>
      <tags>
        <tag>内存队列</tag>
      </tags>
  </entry>
  <entry>
    <title>问题记录：Spring Cloud Gateway线程爆满</title>
    <url>/2024/08/25/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9ASpring%20Cloud%20Gateway%E7%BA%BF%E7%A8%8B%E7%88%86%E6%BB%A1/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>某日告警群突发OOM日志告警：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: unable to create <span class="keyword">new</span> <span class="keyword">native</span> thread</span><br></pre></td></tr></table></figure>

<p>开发、运维、运营相关人员立马被召集了起来，首先确认了业务未受到明显的影响。</p>
<span id="more"></span>



<h3 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h3><p>我首先回想最近该服务更新的内容，但改动并不多，而且距离最近一次发版也有一定的时间了。</p>
<p>运维人员则确认告警的服务后，打算登入对应的服务器一探究竟，但无奈发现服务器也登录不进去，一时范了难。</p>
<p>回想告警的内容，是因为无法创建线程，合理猜测会不会是服务器的线程已经爆满了，导致物理机也受到影响。于是建议运维首先将部署在该物理机上的其他一个服务杀掉（考虑到保留线程信息），以释放掉部分线程出来，尝试后终于登进去了。</p>
<p>登录进去后，查看该服务器总线程数，达到了近3w，确认了问题是因为线程爆满导致，再针对告警的服务，使用<strong>top</strong>指定对应的进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -Hp 进程id</span><br></pre></td></tr></table></figure>



<p>但发现该服务占用线程数并不高，只有不到200个；于是针对部署在该物理机上的服务，逐个进行排查，最终发现是服务网关gateway导致，其线程数达到了2w多个。</p>
<p>知道是gateway导致后，则立马进入到该gateway所在pod，使用<strong>jstack</strong>输出该服务进程的堆栈信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jstack 1 &gt; 1.log</span><br></pre></td></tr></table></figure>

<p>导出堆栈信息后，重启gateway服务。</p>
<p>这边开始分析堆栈信息，发现有大量的命名为<strong>boundedElastic-evictor-xxx</strong>的线程，而且都处理<strong>TIMED_WAITING</strong>状态。</p>
<p>于是打开gateway服务的代码工程（spring-cloud-starter-gateway为3.0.0版本）：</p>
<p>尝试全局搜索<strong>boundedElastic</strong>关键字的类，发现了<strong>BoundedElasticScheduler</strong>这个类，查看其源代码，发现里面有这么一个线程工厂静态对象，其创建的线程命名与堆栈信息输出的一致：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final ThreadFactory EVICTOR_FACTORY &#x3D; r -&gt; &#123;</span><br><span class="line">   Thread t &#x3D; new Thread(r, Schedulers.BOUNDED_ELASTIC + &quot;-evictor-&quot; + EVICTOR_COUNTER.incrementAndGet());</span><br><span class="line">   t.setDaemon(true);</span><br><span class="line">   return t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>于是逐一查看其调用的位置，一路找一路排除，来到了<strong>DefaultPartHttpMessageReader</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Scheduler blockingOperationScheduler = Schedulers.newBoundedElastic(Schedulers.DEFAULT_BOUNDED_ELASTIC_SIZE,</span><br><span class="line">      Schedulers.DEFAULT_BOUNDED_ELASTIC_QUEUESIZE, IDENTIFIER, <span class="number">60</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>又一路找，来到了创建<strong>DefaultPartHttpMessageReader</strong>的来源<strong>ServerDefaultCodecsImpl#extendTypedReaders</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">extendTypedReaders</span><span class="params">(List&lt;HttpMessageReader&lt;?&gt;&gt; typedReaders)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.multipartReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      addCodec(typedReaders, <span class="keyword">this</span>.multipartReader);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   DefaultPartHttpMessageReader partReader = <span class="keyword">new</span> DefaultPartHttpMessageReader();</span><br><span class="line">   addCodec(typedReaders, partReader);</span><br><span class="line">   addCodec(typedReaders, <span class="keyword">new</span> MultipartHttpMessageReader(partReader));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续排查代码，发现来到<strong>DefaultServerWebExchange</strong>这里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static Mono&lt;MultiValueMap&lt;String, String&gt;&gt; initFormData(ServerHttpRequest request,</span><br><span class="line">      ServerCodecConfigurer configurer, String logPrefix) &#123;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      MediaType contentType &#x3D; request.getHeaders().getContentType();</span><br><span class="line">      if (MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(contentType)) &#123;</span><br><span class="line">         return ((HttpMessageReader&lt;MultiValueMap&lt;String, String&gt;&gt;) configurer.getReaders().stream()</span><br><span class="line">               .filter(reader -&gt; reader.canRead(FORM_DATA_TYPE, MediaType.APPLICATION_FORM_URLENCODED))</span><br><span class="line">               .findFirst()</span><br><span class="line">               .orElseThrow(() -&gt; new IllegalStateException(&quot;No form data HttpMessageReader.&quot;)))</span><br><span class="line">               .readMono(FORM_DATA_TYPE, request, Hints.from(Hints.LOG_PREFIX_HINT, logPrefix))</span><br><span class="line">               .switchIfEmpty(EMPTY_FORM_DATA)</span><br><span class="line">               .cache();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (InvalidMediaTypeException ex) &#123;</span><br><span class="line">      &#x2F;&#x2F; Ignore</span><br><span class="line">   &#125;</span><br><span class="line">   return EMPTY_FORM_DATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private static Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; initMultipartData(ServerHttpRequest request,</span><br><span class="line">      ServerCodecConfigurer configurer, String logPrefix) &#123;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      MediaType contentType &#x3D; request.getHeaders().getContentType();</span><br><span class="line">      if (MediaType.MULTIPART_FORM_DATA.isCompatibleWith(contentType)) &#123;</span><br><span class="line">         return ((HttpMessageReader&lt;MultiValueMap&lt;String, Part&gt;&gt;) configurer.getReaders().stream()</span><br><span class="line">               .filter(reader -&gt; reader.canRead(MULTIPART_DATA_TYPE, MediaType.MULTIPART_FORM_DATA))</span><br><span class="line">               .findFirst()</span><br><span class="line">               .orElseThrow(() -&gt; new IllegalStateException(&quot;No multipart HttpMessageReader.&quot;)))</span><br><span class="line">               .readMono(MULTIPART_DATA_TYPE, request, Hints.from(Hints.LOG_PREFIX_HINT, logPrefix))</span><br><span class="line">               .switchIfEmpty(EMPTY_MULTIPART_DATA)</span><br><span class="line">               .cache();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (InvalidMediaTypeException ex) &#123;</span><br><span class="line">      &#x2F;&#x2F; Ignore</span><br><span class="line">   &#125;</span><br><span class="line">   return EMPTY_MULTIPART_DATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了代码后，初步确认是在处理<strong>application/x-www-form-urlencoded</strong>或<strong>multipart/form-data</strong>请求时发生的。</p>
<p>于是在测试环境，找了个这种请求，使用jmeter简单跑了下，果然会导致线程爆满的问题，至此问题元凶终于确认。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>解决方法也比较简单，就是使用WebFlux的自定义接口，配置上默认的multipart解析器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureHttpMessageCodecs</span><span class="params">(ServerCodecConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        DefaultPartHttpMessageReader partReader = <span class="keyword">new</span> DefaultPartHttpMessageReader();</span><br><span class="line">        MultipartHttpMessageReader multipartReader = <span class="keyword">new</span> MultipartHttpMessageReader(partReader);</span><br><span class="line">        configurer.defaultCodecs().multipartReader(multipartReader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对该类问题，后续可以针对每个pod单独限制线程的上限，避免服务之间的相互影响。</p>
<p>对于服务创建的线程数，可以设定阈值，并添加到告警项，避免业务受损问题才暴露出来。</p>
]]></content>
      <tags>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo源码学习：SPI机制</title>
    <url>/2024/06/23/Dubbo%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9ASPI%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>SPI全称是Service Provider Interface，是一种服务自发现机制，本质是将接口实现类的全限定名配置在文件中，在使用中，通过运行时加载，并动态地替换为具体的接口实现类。</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Dubbo 2.7.12版本</p>
</blockquote>
<h3 id="JDK-SPI"><a href="#JDK-SPI" class="headerlink" title="JDK SPI"></a>JDK SPI</h3><p>在开发中，SPI的应用中最让我们熟知的便是JDBC的使用，JDBC中定义了<strong>java.sql.Driver</strong>接口，当我们调用<strong>DriverManager#getConnection方法时</strong>，将触发<strong>DriverManager</strong>类的初始化，并利用SPI机制自动加载驱动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">       loadInitialDrivers();</span><br><span class="line">       println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//省略...</span></span><br><span class="line">     AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//加载驱动类</span></span><br><span class="line">             ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">             <span class="comment">//获取驱动器迭代器，类型为LazyIterator</span></span><br><span class="line">             Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">             </span><br><span class="line">             <span class="keyword">try</span>&#123;</span><br><span class="line">                 <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                     driversIterator.next();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">             <span class="comment">// Do nothing</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//省略...</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在调用<strong>ServiceLoader#load</strong>时，将首先获取当前线程绑定的类加载器（ServiceLoader由启动类加载器加载，启动类加载器无法加载应用类代码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后将对迭代器<strong>driversIterator</strong>进行遍历，加载<strong>META-INF/services/java.sql.Driver</strong>路径下所有的文件，并按行读取 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//META-INF/services/java.sql.Driver</span></span><br><span class="line">            String fullName = PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到**driversIterator.next()**的调用中，会触发具体驱动类的加载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private S nextService() &#123;</span><br><span class="line">    if (!hasNextService())</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    String cn &#x3D; nextName;</span><br><span class="line">    nextName &#x3D; null;</span><br><span class="line">    Class&lt;?&gt; c &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">    	&#x2F;&#x2F;加载驱动类</span><br><span class="line">        c &#x3D; Class.forName(cn, false, loader);</span><br><span class="line">    &#125; catch (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             &quot;Provider &quot; + cn + &quot; not found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">        if (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">            fail(service,</span><br><span class="line">                 &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            S p &#x3D; service.cast(c.newInstance())</span><br><span class="line">            &#x2F;&#x2F;缓存驱动类实例</span><br><span class="line">            providers.put(cn, p);</span><br><span class="line">            return p;</span><br><span class="line">        &#125; catch (Throwable x) &#123;</span><br><span class="line">            fail(service,</span><br><span class="line">                 &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,</span><br><span class="line">                 x);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new Error();          &#x2F;&#x2F; This cannot happen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以MySQL为例，加载的类为<strong>com.mysql.cj.jdbc</strong>，可以看到该段初始化代码中会通过<strong>DriverManager#registerDriver</strong>注册当前驱动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在整个流程中，我们可以看出，JDK的SPI会一次性的加载并实例化，通过配置文件发现的所有的服务实现类，如果存在多个服务实现类，而我们只需要其中一个的话，则在一定程度上损耗了资源。</p>
<h3 id="Dubbo-SPI实现"><a href="#Dubbo-SPI实现" class="headerlink" title="Dubbo SPI实现"></a>Dubbo SPI实现</h3><p>在Dubbo中，所有的组件组件都是由SPI进行加载，但Dubbo并示直接使用JDK提供的SPI机制，而是借鉴其核心思想，并对其进行了增强，实现了自身的一套SPI机制，其用法与JDK的类似，核心类是<strong>ExtensionLoader</strong>，配置文件也定义在**META-INF/**路径下，但Dubbo对配置文件具体分为了三类：</p>
<ul>
<li>META-INF/services/ 目录：该目录下的 SPI 配置文件用来兼容 JDK SPI 。</li>
<li>META-INF/dubbo/ 目录：该目录用于存放用户自定义 SPI 配置文件。</li>
<li>META-INF/dubbo/internal/ 目录：该目录用于存放 Dubbo 内部使用的 SPI 配置文件。</li>
</ul>
<p>且配置文件的内容也不再是类名，而是K-V形式，key被称为扩展名，value则是扩展实现类，并通指定扩展名实现按需加载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dubbo&#x3D;org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>定义扩展接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义扩展实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a cat&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a dog&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件，位置：META-INF/dubbo/org.apache.dubbo.mytest.Animal：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cat=org.apache.dubbo.mytest.Cat</span><br><span class="line">dog=org.apache.dubbo.mytest.Dog</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExtensionLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;Animal&gt; extensionLoader =</span><br><span class="line">                ExtensionLoader.getExtensionLoader(Animal.class);</span><br><span class="line">        Animal cat = extensionLoader.getExtension(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        System.out.println(cat.name());</span><br><span class="line">        Animal dog = extensionLoader.getExtension(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        System.out.println(dog.name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="获取ExtensionLoader实例"><a href="#获取ExtensionLoader实例" class="headerlink" title="获取ExtensionLoader实例"></a>获取ExtensionLoader实例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) &#123;</span><br><span class="line">&#x2F;&#x2F;省略...</span><br><span class="line">      ExtensionLoader&lt;T&gt; loader &#x3D; (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">      if (loader &#x3D;&#x3D; null) &#123;</span><br><span class="line">          EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">          loader &#x3D; (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">      &#125;</span><br><span class="line">      return loader;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，通过EXTENSION_LOADERS缓存字段，保证一个扩展接口有且只有一个ExtensionLoader实例。</p>
<h5 id="获取扩展实例"><a href="#获取扩展实例" class="headerlink" title="获取扩展实例"></a>获取扩展实例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name, <span class="keyword">boolean</span> wrap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Extension name == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩展对象持有器</span></span><br><span class="line">    <span class="keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name);</span><br><span class="line">    Object instance = holder.get();</span><br><span class="line">    <span class="comment">//双检锁使用，创建扩展实例</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = createExtension(name, wrap);</span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先检查缓存 ，没有则通过<strong>createExtension</strong>创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name, <span class="keyword">boolean</span> wrap)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//加载所有扩展类，并通过扩展名称获取对应扩展类</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span> || unacceptableExceptions.contains(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">//获取/创建扩展实例</span></span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.getDeclaredConstructor().newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//扩展实例依赖注入</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//包装扩展实例（如果有的话）并返回</span></span><br><span class="line">        <span class="keyword">if</span> (wrap) &#123;</span><br><span class="line"></span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; wrapperClassesList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (cachedWrapperClasses != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wrapperClassesList.addAll(cachedWrapperClasses);</span><br><span class="line">                wrapperClassesList.sort(WrapperComparator.COMPARATOR);</span><br><span class="line">                Collections.reverse(wrapperClassesList);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClassesList)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClassesList) &#123;</span><br><span class="line">                    Wrapper wrapper = wrapperClass.getAnnotation(Wrapper.class);</span><br><span class="line">                    <span class="keyword">if</span> (wrapper == <span class="keyword">null</span></span><br><span class="line">                            || (ArrayUtils.contains(wrapper.matches(), name) &amp;&amp; !ArrayUtils.contains(wrapper.mismatches(), name))) &#123;</span><br><span class="line">                        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//初始化实例</span></span><br><span class="line">        initExtension(instance);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Extension instance (name: &quot;</span> + name + <span class="string">&quot;, class: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;) couldn&#x27;t be instantiated: &quot;</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>createExtension</strong>主要包含了4个步骤：</p>
<ol>
<li>通过getExtensionClasses获取所有扩展实现类；</li>
<li>获取/通过反射创建扩展实例；</li>
<li>向扩展实例注入依赖；</li>
<li>包装扩展实例；</li>
</ol>
<h6 id="获取所有的扩展类"><a href="#获取所有的扩展类" class="headerlink" title="获取所有的扩展类"></a>获取所有的扩展类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">//从缓存中获取扩展类</span></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="comment">//双检锁使用，加载所有的扩展类</span></span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<strong>loadExtensionClasses</strong>加载扩展类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    	<span class="comment">//缓存默认扩展名</span></span><br><span class="line">      cacheDefaultExtensionName();</span><br><span class="line"></span><br><span class="line">      Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//从不同目录加载扩展类</span></span><br><span class="line">      <span class="keyword">for</span> (LoadingStrategy strategy : strategies) &#123;</span><br><span class="line">          loadDirectory(extensionClasses, strategy.directory(), type.getName(), strategy.preferExtensionClassLoader(),</span><br><span class="line">                  strategy.overridden(), strategy.excludedPackages());</span><br><span class="line">          loadDirectory(extensionClasses, strategy.directory(), type.getName().replace(<span class="string">&quot;org.apache&quot;</span>, <span class="string">&quot;com.alibaba&quot;</span>),</span><br><span class="line">                  strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> extensionClasses;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里首先解析了@SPI注解，获取到默认的扩展名并缓存下来，然后通过不同的策略加载扩展类，那这里的策略都有哪些呢，通过定位可以看到是通过<strong>loadLoadingStrategies</strong>获取的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LoadingStrategy[] loadLoadingStrategies() &#123;</span><br><span class="line">    <span class="keyword">return</span> stream(load(LoadingStrategy.class).spliterator(), <span class="keyword">false</span>)</span><br><span class="line">            .sorted()</span><br><span class="line">            .toArray(LoadingStrategy[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续深入可以发现，该策略是最终是通过JDK的SPI机制加载的，而通过配置文件可以看到主要包含了有一种策略类<strong>org.apache.dubbo.common.extension.DubboInternalLoadingStrategy</strong>、<strong>org.apache.dubbo.common.extension.DubboLoadingStrategy</strong>、<strong>org.apache.dubbo.common.extension.ServicesLoadingStrategy</strong>，而这3种策略类则分别对应了前端提到的3个配置文件的目录。</p>
<p>回到<strong>loadDirectory</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir, String type,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> extensionLoaderClassLoaderFirst, <span class="keyword">boolean</span> overridden, String... excludedPackages)</span> </span>&#123;</span><br><span class="line">    String fileName = dir + type;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;java.net.URL&gt; urls = <span class="keyword">null</span>;</span><br><span class="line">        ClassLoader classLoader = findClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try to load from ExtensionLoader&#x27;s ClassLoader first</span></span><br><span class="line">        <span class="keyword">if</span> (extensionLoaderClassLoaderFirst) &#123;</span><br><span class="line">            ClassLoader extensionLoaderClassLoader = ExtensionLoader.class.getClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (ClassLoader.getSystemClassLoader() != extensionLoaderClassLoader) &#123;</span><br><span class="line">                urls = extensionLoaderClassLoader.getResources(fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (urls == <span class="keyword">null</span> || !urls.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                urls = classLoader.getResources(fileName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                java.net.URL resourceURL = urls.nextElement();</span><br><span class="line">                loadResource(extensionClasses, classLoader, resourceURL, overridden, excludedPackages);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, description file: &quot;</span> + fileName + <span class="string">&quot;).&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到了对应所有的文件资源，并通过<strong>loadResource</strong>加载：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                          java.net.URL resourceURL, <span class="keyword">boolean</span> overridden, String... excludedPackages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(resourceURL.openStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            String clazz = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//只取#前端内容</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> ci = line.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                &#125;</span><br><span class="line">                line = line.trim();</span><br><span class="line">                <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//分隔以获取扩展名及扩展类名</span></span><br><span class="line">                        String name = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> i = line.indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                            clazz = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            clazz = line;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isNotEmpty(clazz) &amp;&amp; !isExcluded(clazz, excludedPackages)) &#123;</span><br><span class="line">                            <span class="comment">//加载扩展类</span></span><br><span class="line">                            loadClass(extensionClasses, resourceURL, Class.forName(clazz, <span class="keyword">true</span>, classLoader), name, overridden);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                                <span class="string">&quot;Failed to load extension class (interface: &quot;</span> + type + <span class="string">&quot;, class line: &quot;</span> + line + <span class="string">&quot;) in &quot;</span> + resourceURL +</span><br><span class="line">                                        <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">                        exceptions.put(line, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, class file: &quot;</span> + resourceURL + <span class="string">&quot;) in &quot;</span> + resourceURL, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载扩展类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">boolean</span> overridden)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Error occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, class line: &quot;</span> + clazz.getName() + <span class="string">&quot;), class &quot;</span></span><br><span class="line">                + clazz.getName() + <span class="string">&quot; is not subtype of interface.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">        <span class="comment">//缓存自适应扩展类</span></span><br><span class="line">        cacheAdaptiveClass(clazz, overridden);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">        <span class="comment">//缓存包装类</span></span><br><span class="line">        cacheWrapperClass(clazz);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//普通扩展类</span></span><br><span class="line">        clazz.getConstructor();</span><br><span class="line">        <span class="comment">//如果名称为空，则通过@Extension注解获取</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">            name = findAnnotationName(clazz);</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">&quot;No such extension name for the class &quot;</span> + clazz.getName() + <span class="string">&quot; in the config &quot;</span> + resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//切分为多个扩展名</span></span><br><span class="line">        String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">        <span class="keyword">if</span> (ArrayUtils.isNotEmpty(names)) &#123;</span><br><span class="line">            cacheActivateClass(clazz, names[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                <span class="comment">//添加到扩展类集合</span></span><br><span class="line">                cacheName(clazz, n);</span><br><span class="line">                saveInExtensionClass(extensionClasses, clazz, n, overridden);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码分支上看，加载扩展类这里分为3种情况，分别为自适应扩展类、包装类及普通扩展类：</p>
<ol>
<li>该类上有<strong>Adaptive</strong>，为自适应扩展类；</li>
<li>该类有扩展类类型的构造函数，则为包装类；</li>
<li>其他为普通扩展类；</li>
</ol>
<h6 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h6><p>创建扩展实例后，下一步则是向扩展实例注入依赖，具体逻辑是<strong>injectExtension</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (objectFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历扩展类的所有方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">            <span class="comment">//是否setter方法</span></span><br><span class="line">            <span class="keyword">if</span> (!isSetter(method)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Check &#123;@link DisableInject&#125; to see if we need autowire injection for this property</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//获取方法参数类型</span></span><br><span class="line">            Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Check &#123;@link Inject&#125; to see if we need auto-injection for this property</span></span><br><span class="line"><span class="comment">             * &#123;@link Inject#enable&#125; == false will skip inject property phase</span></span><br><span class="line"><span class="comment">             * &#123;@link Inject#InjectType#ByName&#125; default inject by name</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//获取setter属性名</span></span><br><span class="line">            String property = getSetterProperty(method);</span><br><span class="line">            Inject inject = method.getAnnotation(Inject.class);</span><br><span class="line">            <span class="keyword">if</span> (inject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//注入依赖值</span></span><br><span class="line">                injectValue(instance, method, pt, property);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!inject.enable()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (inject.type() == Inject.InjectType.ByType) &#123;</span><br><span class="line">                    <span class="comment">//按类型注入</span></span><br><span class="line">                    injectValue(instance, method, pt, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//按名称注入</span></span><br><span class="line">                    injectValue(instance, method, pt, property);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">injectValue</span><span class="params">(T instance, Method method, Class&lt;?&gt; pt, String property)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">            method.invoke(instance, object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Failed to inject via method &quot;</span> + method.getName()</span><br><span class="line">                + <span class="string">&quot; of interface &quot;</span> + type.getName() + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里的依赖注入是通过解析set方法进行注入，可以通过类型或名称进行注入，具体的注入逻辑由<strong>objectFactory</strong>决定，通过深入查看发现此处<strong>objectFactory</strong>通过<strong>ExtensionLoader#getAdaptiveExtension</strong>方法获取得到，其类型为<strong>AdaptiveExtensionFactory</strong>，该类被称为自适应扩展类，而它也是通过SPI机制加载得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Adaptive</span><br><span class="line">public class AdaptiveExtensionFactory implements ExtensionFactory &#123;</span><br><span class="line"></span><br><span class="line">    private final List&lt;ExtensionFactory&gt; factories;</span><br><span class="line"></span><br><span class="line">    public AdaptiveExtensionFactory() &#123;</span><br><span class="line">        ExtensionLoader&lt;ExtensionFactory&gt; loader &#x3D; ExtensionLoader.getExtensionLoader(ExtensionFactory.class);</span><br><span class="line">        List&lt;ExtensionFactory&gt; list &#x3D; new ArrayList&lt;ExtensionFactory&gt;();</span><br><span class="line">        for (String name : loader.getSupportedExtensions()) &#123;</span><br><span class="line">            list.add(loader.getExtension(name));</span><br><span class="line">        &#125;</span><br><span class="line">        factories &#x3D; Collections.unmodifiableList(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name) &#123;</span><br><span class="line">    	&#x2F;&#x2F;遍历所有ExtensionFactory，获取到依赖后便直接返回</span><br><span class="line">        for (ExtensionFactory factory : factories) &#123;</span><br><span class="line">            T extension &#x3D; factory.getExtension(type, name);</span><br><span class="line">            if (extension !&#x3D; null) &#123;</span><br><span class="line">                return extension;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<strong>AdaptiveExtensionFactory</strong>中维护了factories集合，在Spring环境下，该集合包括<strong>SpiExtensionFactory</strong>和<strong>SpringExtensionFactory</strong>。</p>
<h5 id="获取自适应扩展类"><a href="#获取自适应扩展类" class="headerlink" title="获取自适应扩展类"></a>获取自适应扩展类</h5><p>什么是自适应扩展类呢？在前文了解到，Dubbo的依赖注入有用到自适应扩展类，通过观察其实现，可以发现它实际上是一种代理类。在Dubbo中，可以通过**@Adaptive<strong>注解标注扩展接口或接口方法，而Dubbo将自动为其生成具有代理功能的代码，并通过编译得到Class类，当调用自适应扩展类时，将通过方法中的URL参数决定具体调用的扩展实例。其关键代码在于</strong>getAdaptiveExtension**：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从缓存中获取自适应扩展类</span></span><br><span class="line">    Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to create adaptive instance: &quot;</span> +</span><br><span class="line">                    createAdaptiveInstanceError.toString(),</span><br><span class="line">                    createAdaptiveInstanceError);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//创建自适应扩展实例</span></span><br><span class="line">        <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">            instance = cachedAdaptiveInstance.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    instance = createAdaptiveExtension();</span><br><span class="line">                    cachedAdaptiveInstance.set(instance);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    createAdaptiveInstanceError = t;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to create adaptive instance: &quot;</span> + t.toString(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Can&#x27;t create adaptive extension &quot;</span> + type + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与创建普通的扩展实例相似，创建自适应扩展实例也分为3个步骤：</p>
<ol>
<li>获取自适应扩展类；</li>
<li>创建自应用扩展实例；</li>
<li>依赖注入；</li>
</ol>
<p>我们具体看下<strong>getAdaptiveExtensionClass</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    if (cachedAdaptiveClass !&#x3D; null) &#123;</span><br><span class="line">        return cachedAdaptiveClass;</span><br><span class="line">    &#125;</span><br><span class="line">    return cachedAdaptiveClass &#x3D; createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getAdaptiveExtensionClass</strong>同样包含了3个步骤：</p>
<ol>
<li>获取扩展类（与获取普通的扩展类的调用是同一个方法，这里会缓存**@Adaptive**注解标注的类为cachedAdaptiveClass）；</li>
<li>缓存的自适应扩展类cachedAdaptiveClass不为空时，直接返回；</li>
<li>创建自适应扩展类；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">//生成自适应扩展类的代码</span></span><br><span class="line">    String code = <span class="keyword">new</span> AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();</span><br><span class="line">    <span class="comment">//获取编译器实现类</span></span><br><span class="line">    ClassLoader classLoader = findClassLoader();</span><br><span class="line">    org.apache.dubbo.common.compiler.Compiler compiler =</span><br><span class="line">            ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">    <span class="comment">//编译代码，并生成Class</span></span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createAdaptiveExtensionClass用于生成自适应扩展类代码，并通过<strong>org.apache.dubbo.common.compiler.Compiler</strong>实例编码代码，得到Class类。通过查看其配置文件可知，目前存在<strong>JdkCompiler</strong>和<strong>JavassistCompiler</strong>两种编译器，而Dubbo默认使用<strong>JavassistCompiler</strong>。</p>
<p>那生成的自适应扩展类是什么样的呢，这里以<strong>ProxyFactory</strong>为例，使用arthas工具反编译得到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span>$<span class="title">Adaptive</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Invoker invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (invoker.getUrl() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        URL uRL = invoker.getUrl();</span><br><span class="line">        String string = uRL.getParameter(<span class="string">&quot;proxy&quot;</span>, <span class="string">&quot;javassist&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (string == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="keyword">new</span> StringBuffer().append(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url (&quot;</span>).append(uRL.toString()).append(<span class="string">&quot;) use keys([proxy])&quot;</span>).toString());</span><br><span class="line">        &#125;</span><br><span class="line">        ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getExtension(string);</span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getProxy(invoker);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Invoker invoker, <span class="keyword">boolean</span> bl)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (invoker.getUrl() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        URL uRL = invoker.getUrl();</span><br><span class="line">        String string = uRL.getParameter(<span class="string">&quot;proxy&quot;</span>, <span class="string">&quot;javassist&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (string == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="keyword">new</span> StringBuffer().append(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url (&quot;</span>).append(uRL.toString()).append(<span class="string">&quot;) use keys([proxy])&quot;</span>).toString());</span><br><span class="line">        &#125;</span><br><span class="line">        ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getExtension(string);</span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getProxy(invoker, bl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Invoker <span class="title">getInvoker</span><span class="params">(Object object, Class clazz, URL uRL)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uRL == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        URL uRL2 = uRL;</span><br><span class="line">        String string = uRL2.getParameter(<span class="string">&quot;proxy&quot;</span>, <span class="string">&quot;javassist&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (string == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="keyword">new</span> StringBuffer().append(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url (&quot;</span>).append(uRL2.toString()).append(<span class="string">&quot;) use keys([proxy])&quot;</span>).toString());</span><br><span class="line">        &#125;</span><br><span class="line">        ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getExtension(string);</span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getInvoker(object, clazz, uRL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，自适应扩展类就是通过获取指定URL参数，来动态决定扩展实现类。</p>
<h5 id="自动包装类"><a href="#自动包装类" class="headerlink" title="自动包装类"></a>自动包装类</h5><p>回到<strong>ExtensionLoader#loadClass</strong>方法中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> private void loadClass(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name,</span><br><span class="line">                        boolean overridden) throws NoSuchMethodException &#123;</span><br><span class="line">     &#x2F;&#x2F;省略...</span><br><span class="line">     if (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">         cacheAdaptiveClass(clazz, overridden);</span><br><span class="line">         &#x2F;&#x2F;是否包含拷贝构造函数</span><br><span class="line">     &#125; else if (isWrapperClass(clazz)) &#123;</span><br><span class="line">     	&#x2F;&#x2F;缓存包装类</span><br><span class="line">         cacheWrapperClass(clazz);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;省略...</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>那包装类是什么呢，通过查看cachedWrapperClasses的使用位置，可以看到，在<strong>ExtensionLoader#createExtension</strong>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (wrap) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; wrapperClassesList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if (cachedWrapperClasses !&#x3D; null) &#123;</span><br><span class="line">        wrapperClassesList.addAll(cachedWrapperClasses);</span><br><span class="line">        wrapperClassesList.sort(WrapperComparator.COMPARATOR);</span><br><span class="line">        Collections.reverse(wrapperClassesList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (CollectionUtils.isNotEmpty(wrapperClassesList)) &#123;</span><br><span class="line">        for (Class&lt;?&gt; wrapperClass : wrapperClassesList) &#123;</span><br><span class="line">            Wrapper wrapper &#x3D; wrapperClass.getAnnotation(Wrapper.class);</span><br><span class="line">            if (wrapper &#x3D;&#x3D; null</span><br><span class="line">                    || (ArrayUtils.contains(wrapper.matches(), name) &amp;&amp; !ArrayUtils.contains(wrapper.mismatches(), name))) &#123;</span><br><span class="line">                instance &#x3D; injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包装类是一种装饰类，其作用更多用于将扩展类的公共逻辑处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文简单介绍了 Java SPI 与 Dubbo SPI 用法，并通过源码分析了 Dubbo SPI 加载拓展类的过程，总的来说，</p>
<ol>
<li>Dubbo实现了自己的一套SPI机制，可以按需进行加载；</li>
<li>在Dubbo中可以通过**@Adaptive**注解创建自适应扩展类，根据传入的URL参数加载具体的扩展实现；</li>
<li>Dubbo可以对创建的扩展实例进行依赖注入，但只针对setter方法进行注入，目前存在两种注入实现，分别为<strong>SpiExtensionFactory</strong>和<strong>SpringExtensionFactory</strong>;</li>
<li>Dubbo可以通过包装类实现对扩展类的装饰；</li>
</ol>
]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo源码学习：服务订阅</title>
    <url>/2024/09/28/Dubbo%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%9C%8D%E5%8A%A1%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[<p>在前一篇 <a href="https://laixiaoming.space/2024/07/13/Dubbo%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8/#more">Dubbo源码学习：服务引用</a> 中我们了解到，在Dubbo服务消费端，Invoker对象具有远程调用的功能，但服务消费端是如何感知服务端的地址呢？在实际使用时，同一个服务提供者往往具有多个实例，在服务提供者实例上下线或实例数量发生变更时，服务消费端会如何做出相应的更新？</p>
<p>在深入了解之前，我们需要先了解下服务目录的概念。</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Dubbo 2.7.12版本</p>
</blockquote>
<h3 id="服务目录Directory"><a href="#服务目录Directory" class="headerlink" title="服务目录Directory"></a>服务目录Directory</h3><p>服务目录是服务提供者的集合，包含了多个Invoker，其中存储了与服务提供者有关的信息，通过服务目录，服务消费者可以获取到服务提供者的地址等信息。服务目录分为<strong>StaticDirectory</strong>和<strong>DynamicDirectory</strong>，其类继承体系图如下：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20240928154310365.png" alt="image-20240928154310365"></p>
<ol>
<li><strong>StaticDirectory</strong> 是静态服务目录，其服务提供者列表是静态的，在创建完成之后不会在运行期间发生变化。</li>
<li><strong>DynamicDirectory</strong> 是动态服务目录，其维护的提供者列表是动态变化的。动态服务目录实现了 <strong>NotifyListener</strong> 接口，在创建后向注册中心订阅服务提供者的变化信息，当收到来自注册中心的服务提供者变更通知后，会根据变更内容更新其中维护的服务提供者列表。</li>
<li>动态服务目录有两种：<strong>RegistryDirectory</strong> 和 <strong>ServiceDiscoveryRegistryDirectory</strong> 。<strong>RegistryDirectory</strong> 用于记录和监听接口级服务提供者，而 <strong>ServiceDiscoveryRegistryDirectory</strong> 则用来记录和监听应用级服务提供者。</li>
</ol>
<p>本文主要以 <strong>RegistryDirectory</strong> 为例进行深入了解。</p>
<h3 id="服务订阅"><a href="#服务订阅" class="headerlink" title="服务订阅"></a>服务订阅</h3><p>在前一篇 <a href="https://laixiaoming.space/2024/07/13/Dubbo%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8/#more">Dubbo源码学习：服务引用</a> 中我们了解到，远程调用的Invoker是通过 <strong>InterfaceCompatibleRegistryProtocol##getInvoker</strong> 创建的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ClusterInvoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建RegistryDirectory实例</span></span><br><span class="line">    DynamicDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;&gt;(type, url);</span><br><span class="line">    <span class="keyword">return</span> doCreateInvoker(directory, cluster, registry, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>RegistryProtocol#doCreateInvoker</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">ClusterInvoker&lt;T&gt; <span class="title">doCreateInvoker</span><span class="params">(DynamicDirectory&lt;T&gt; directory, Cluster cluster, Registry registry, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    directory.setRegistry(registry);</span><br><span class="line">    directory.setProtocol(protocol);</span><br><span class="line">    <span class="comment">// all attributes of REFER_KEY</span></span><br><span class="line">    Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getConsumerUrl().getParameters());</span><br><span class="line">    URL urlToRegistry = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">    <span class="keyword">if</span> (directory.isShouldRegister()) &#123;</span><br><span class="line">        directory.setRegisteredConsumerUrl(urlToRegistry);</span><br><span class="line">        registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    directory.buildRouterChain(urlToRegistry);</span><br><span class="line">    <span class="comment">//订阅服务变更通知</span></span><br><span class="line">    directory.subscribe(toSubscribeUrl(urlToRegistry));</span><br><span class="line">	<span class="comment">//cluster类型为MockClusterWrapper</span></span><br><span class="line">    <span class="keyword">return</span> (ClusterInvoker&lt;T&gt;) cluster.join(directory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MockClusterWrapper#join</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockClusterWrapper</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line">	<span class="comment">//FailoverCluster实现类</span></span><br><span class="line">    <span class="keyword">private</span> Cluster cluster;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MockClusterWrapper</span><span class="params">(Cluster cluster)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cluster = cluster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    	<span class="comment">//返回MockClusterInvoker实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MockClusterInvoker&lt;T&gt;(directory,</span><br><span class="line">                <span class="keyword">this</span>.cluster.join(directory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractCluster#join</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">	<span class="comment">//doJoin返回FailoverClusterInvoker实例</span></span><br><span class="line">    <span class="keyword">return</span> buildClusterInterceptors(doJoin(directory), directory.getUrl().getParameter(REFERENCE_INTERCEPTOR_KEY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在创建 <strong>RegistryDirectory</strong> 实例后，则通过 <strong>RegistryDirectory#subscribe</strong> 订阅服务提供方变更通知：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    setConsumerUrl(url);</span><br><span class="line">    <span class="comment">//将当前RegistryDirectory作为配置监听器注册</span></span><br><span class="line">    CONSUMER_CONFIGURATION_LISTENER.addNotifyListener(<span class="keyword">this</span>);</span><br><span class="line">    referenceConfigurationListener = <span class="keyword">new</span> ReferenceConfigurationListener(<span class="keyword">this</span>, url);</span><br><span class="line">    <span class="comment">//订阅服务变更通知</span></span><br><span class="line">    registry.subscribe(url, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>深入subscribe方法，这里以 Nacos 注册中心为例，来到 <strong>NacosRegistry#doSubscribe</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> NotifyListener listener)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取服务名，这里为了兼容旧版本服务，同一个服务会生成两个服务名</span></span><br><span class="line">    Set&lt;String&gt; serviceNames = getServiceNames(url, listener);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新旧版本的同一个服务名关联起来，以便于后续一起处理</span></span><br><span class="line">    <span class="keyword">if</span> (isServiceNamesWithCompatibleMode(url)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String serviceName : serviceNames) &#123;</span><br><span class="line">            NacosInstanceManageUtil.setCorrespondingServiceNames(serviceName, serviceNames);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doSubscribe(url, listener, serviceNames);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> NotifyListener listener, <span class="keyword">final</span> Set&lt;String&gt; serviceNames)</span> </span>&#123;</span><br><span class="line">    execute(namingService -&gt; &#123;</span><br><span class="line">        <span class="comment">//服务名称兼容模式</span></span><br><span class="line">        <span class="keyword">if</span> (isServiceNamesWithCompatibleMode(url)) &#123;</span><br><span class="line">            List&lt;Instance&gt; allCorrespondingInstanceList = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Get all instances with serviceNames to avoid instance overwrite and but with empty instance mentioned</span></span><br><span class="line"><span class="comment">             * in https://github.com/apache/dubbo/issues/5885 and https://github.com/apache/dubbo/issues/5899</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * namingService.getAllInstances with &#123;<span class="doctag">@link</span> org.apache.dubbo.registry.support.AbstractRegistry#registryUrl&#125;</span></span><br><span class="line"><span class="comment">             * default &#123;<span class="doctag">@link</span> DEFAULT_GROUP&#125;</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * in https://github.com/apache/dubbo/issues/5978</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (String serviceName : serviceNames) &#123;</span><br><span class="line">                <span class="comment">//从nacos获取所有已有实例</span></span><br><span class="line">                List&lt;Instance&gt; instances = namingService.getAllInstances(serviceName,</span><br><span class="line">                        getUrl().getParameter(GROUP_KEY, Constants.DEFAULT_GROUP));</span><br><span class="line">                NacosInstanceManageUtil.initOrRefreshServiceInstanceList(serviceName, instances);</span><br><span class="line">                allCorrespondingInstanceList.addAll(instances);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//以当前获取到的所有实例通知到directory进行刷新</span></span><br><span class="line">            notifySubscriber(url, listener, allCorrespondingInstanceList);</span><br><span class="line">            <span class="keyword">for</span> (String serviceName : serviceNames) &#123;</span><br><span class="line">                <span class="comment">//订阅服务变更</span></span><br><span class="line">                subscribeEventListener(serviceName, url, listener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Instance&gt; instances = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String serviceName : serviceNames) &#123;</span><br><span class="line">                instances.addAll(namingService.getAllInstances(serviceName</span><br><span class="line">                        , getUrl().getParameter(GROUP_KEY, Constants.DEFAULT_GROUP)));</span><br><span class="line">                notifySubscriber(url, listener, instances);</span><br><span class="line">                subscribeEventListener(serviceName, url, listener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，服务订阅主要做了以下3个事：</p>
<ol>
<li>从注册中心获取所有实例；</li>
<li>以获取到的所有实例，通知并刷新（初始化）服务目录；</li>
<li>订阅服务变更通知。</li>
</ol>
<h3 id="接收服务变更通知"><a href="#接收服务变更通知" class="headerlink" title="接收服务变更通知"></a>接收服务变更通知</h3><p>当注册中心的服务配置变更时，将通过 <strong>NotifyListener#notify</strong> 方法接口通知，而 <strong>NacosDirectory</strong> 实现了该接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//按照category分成configurators、routers、providers三类</span></span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; categoryUrls = urls.stream()</span><br><span class="line">            .filter(Objects::nonNull)</span><br><span class="line">            .filter(<span class="keyword">this</span>::isValidCategory)</span><br><span class="line">            .filter(<span class="keyword">this</span>::isNotCompatibleFor26x)</span><br><span class="line">            .collect(Collectors.groupingBy(<span class="keyword">this</span>::judgeCategory));</span><br><span class="line">	<span class="comment">//取configurators类型的URL，并转换成Configurator对象</span></span><br><span class="line">    List&lt;URL&gt; configuratorURLs = categoryUrls.getOrDefault(CONFIGURATORS_CATEGORY, Collections.emptyList());</span><br><span class="line">    <span class="keyword">this</span>.configurators = Configurator.toConfigurators(configuratorURLs).orElse(<span class="keyword">this</span>.configurators);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取routers类型的URL，并转成Router对象，添加到RouterChain中</span></span><br><span class="line">    List&lt;URL&gt; routerURLs = categoryUrls.getOrDefault(ROUTERS_CATEGORY, Collections.emptyList());</span><br><span class="line">    toRouters(routerURLs).ifPresent(<span class="keyword">this</span>::addRouters);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取providers类型的URL，调用refreshOverrideAndInvoker方法进行处理</span></span><br><span class="line">    List&lt;URL&gt; providerURLs = categoryUrls.getOrDefault(PROVIDERS_CATEGORY, Collections.emptyList());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.x added for extend URL address</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ExtensionLoader&lt;AddressListener&gt; addressListenerExtensionLoader = ExtensionLoader.getExtensionLoader(AddressListener.class);</span><br><span class="line">    List&lt;AddressListener&gt; supportedListeners = addressListenerExtensionLoader.getActivateExtension(getUrl(), (String[]) <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (supportedListeners != <span class="keyword">null</span> &amp;&amp; !supportedListeners.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AddressListener addressListener : supportedListeners) &#123;</span><br><span class="line">            providerURLs = addressListener.notify(providerURLs, getConsumerUrl(), <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    refreshOverrideAndInvoker(providerURLs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <strong>RegistryDirectory#notify</strong> 方法中，首先会按照 category 将 URL 分成 configurators、routers、providers 三类，并分别对不同类型的 URL 进行处理：</p>
<ol>
<li>将 configurators 类型的 URL 转化为 Configurator，保存到 configurators 字段中；</li>
<li>将 router 类型的 URL 转化为 Router，并添加到 routerChain ；</li>
<li>将 provider 类型的 URL 通过refreshOverrideAndInvoker方法进行刷新。</li>
</ol>
<p><strong>RegistryDirectory#refreshOverrideAndInvoker</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">refreshOverrideAndInvoker</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mock zookeeper://xxx?mock=return null</span></span><br><span class="line">    overrideDirectoryUrl();</span><br><span class="line">    refreshInvoker(urls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要看 <strong>refreshInvoker</strong> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshInvoker</span><span class="params">(List&lt;URL&gt; invokerUrls)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(invokerUrls, <span class="string">&quot;invokerUrls should not be null&quot;</span>);</span><br><span class="line">	<span class="comment">//invokerUrls长度为1，并且协议为empty，则销毁所有invoker</span></span><br><span class="line">    <span class="keyword">if</span> (invokerUrls.size() == <span class="number">1</span></span><br><span class="line">            &amp;&amp; invokerUrls.get(<span class="number">0</span>) != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; EMPTY_PROTOCOL.equals(invokerUrls.get(<span class="number">0</span>).getProtocol())) &#123;</span><br><span class="line">        <span class="comment">//标记为禁止访问</span></span><br><span class="line">        <span class="keyword">this</span>.forbidden = <span class="keyword">true</span>; <span class="comment">// Forbid to access</span></span><br><span class="line">        <span class="comment">//销毁所有invoker实例</span></span><br><span class="line">        <span class="keyword">this</span>.invokers = Collections.emptyList();</span><br><span class="line">        routerChain.setInvokers(<span class="keyword">this</span>.invokers);</span><br><span class="line">        destroyAllInvokers(); <span class="comment">// Close all invokers</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Map&lt;URL, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">        <span class="keyword">if</span> (invokerUrls == Collections.&lt;URL&gt;emptyList()) &#123;</span><br><span class="line">            invokerUrls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果invokerUrls为空，并且cachedInvokerUrls不为空，则使用cachedInvokerUrls</span></span><br><span class="line">        <span class="keyword">if</span> (invokerUrls.isEmpty() &amp;&amp; <span class="keyword">this</span>.cachedInvokerUrls != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invokerUrls.addAll(<span class="keyword">this</span>.cachedInvokerUrls);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//缓存invokerUrls</span></span><br><span class="line">            <span class="keyword">this</span>.cachedInvokerUrls = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.cachedInvokerUrls.addAll(invokerUrls);<span class="comment">//Cached invoker urls, convenient for comparison</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (invokerUrls.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.forbidden = <span class="keyword">false</span>; <span class="comment">// Allow to access</span></span><br><span class="line">        <span class="comment">//将url转换为invoker实例</span></span><br><span class="line">        Map&lt;URL, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);<span class="comment">// Translate url list to Invoker map</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * If the calculation is wrong, it is not processed.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. The protocol configured by the client is inconsistent with the protocol of the server.</span></span><br><span class="line"><span class="comment">         *    eg: consumer protocol = dubbo, provider only has other protocol services(rest).</span></span><br><span class="line"><span class="comment">         * 2. The registration center is not robust and pushes illegal specification data.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmptyMap(newUrlInvokerMap)) &#123;</span><br><span class="line">            logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;urls to invokers error .invokerUrls.size :&quot;</span> + invokerUrls.size() + <span class="string">&quot;, invoker.size :0. urls :&quot;</span> + invokerUrls</span><br><span class="line">                    .toString()));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新服务目录中的invoker列表</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; newInvokers = Collections.unmodifiableList(<span class="keyword">new</span> ArrayList&lt;&gt;(newUrlInvokerMap.values()));</span><br><span class="line">        <span class="comment">// pre-route and build cache, notice that route cache should build on original Invoker list.</span></span><br><span class="line">        <span class="comment">// toMergeMethodInvokerMap() will wrap some invokers having different groups, those wrapped invokers not should be routed.</span></span><br><span class="line">        routerChain.setInvokers(newInvokers);</span><br><span class="line">        <span class="keyword">this</span>.invokers = multiGroup ? toMergeInvokerList(newInvokers) : newInvokers;</span><br><span class="line">        <span class="keyword">this</span>.urlInvokerMap = newUrlInvokerMap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//销毁无用的invoker</span></span><br><span class="line">        <span class="comment">// Close the unused Invoker</span></span><br><span class="line">        destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// notify invokers refreshed</span></span><br><span class="line">    <span class="keyword">this</span>.invokersChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其核心逻辑在于 <strong>toInvokers</strong> 方法，该方法用于将 invokerUrls 转换为 invoker实例集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;URL, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class="line">    Map&lt;URL, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(urls)) &#123;</span><br><span class="line">        <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;URL&gt; keys = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">//获取消费端支持的协议</span></span><br><span class="line">    String queryProtocols = <span class="keyword">this</span>.queryMap.get(PROTOCOL_KEY);</span><br><span class="line">    <span class="keyword">for</span> (URL providerUrl : urls) &#123;</span><br><span class="line">        <span class="comment">// If protocol is configured at the reference side, only the matching protocol is selected</span></span><br><span class="line">        <span class="keyword">if</span> (queryProtocols != <span class="keyword">null</span> &amp;&amp; queryProtocols.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> accept = <span class="keyword">false</span>;</span><br><span class="line">            String[] acceptProtocols = queryProtocols.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String acceptProtocol : acceptProtocols) &#123;</span><br><span class="line">                <span class="keyword">if</span> (providerUrl.getProtocol().equals(acceptProtocol)) &#123;</span><br><span class="line">                    accept = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//是否支持消费端协议，不支持则忽略</span></span><br><span class="line">            <span class="keyword">if</span> (!accept) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//忽略empty协议的URL</span></span><br><span class="line">        <span class="keyword">if</span> (EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过SPI的方式检测消费端是否存在对应的扩展实现</span></span><br><span class="line">        <span class="keyword">if</span> (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) &#123;</span><br><span class="line">            logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unsupported protocol &quot;</span> + providerUrl.getProtocol() +</span><br><span class="line">                    <span class="string">&quot; in notified url: &quot;</span> + providerUrl + <span class="string">&quot; from registry &quot;</span> + getUrl().getAddress() +</span><br><span class="line">                    <span class="string">&quot; to consumer &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot;, supported protocol: &quot;</span> +</span><br><span class="line">                    ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并URL，按一定优先级合并配置</span></span><br><span class="line">        URL url = mergeUrl(providerUrl);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (keys.contains(url)) &#123; <span class="comment">// Repeated url</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        keys.add(url);</span><br><span class="line">        <span class="comment">// Cache key is url that does not merge with consumer side parameters, regardless of how the consumer combines parameters, if the server url changes, then refer again</span></span><br><span class="line">        Map&lt;URL, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="keyword">null</span> ? <span class="keyword">null</span> : localUrlInvokerMap.get(url);</span><br><span class="line">        <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123; <span class="comment">// Not in the cache, refer again</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> enabled = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//根据URL参数决定是否创建invoker</span></span><br><span class="line">                <span class="keyword">if</span> (url.hasParameter(DISABLED_KEY)) &#123;</span><br><span class="line">                    enabled = !url.getParameter(DISABLED_KEY, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    enabled = url.getParameter(ENABLED_KEY, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//通过Protocol#refer方法创建invoker实例</span></span><br><span class="line">                <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                    invoker = <span class="keyword">new</span> InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Failed to refer invoker for interface:&quot;</span> + serviceType + <span class="string">&quot;,url:(&quot;</span> + url + <span class="string">&quot;)&quot;</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123; <span class="comment">// Put new invoker in cache</span></span><br><span class="line">                newUrlInvokerMap.put(url, invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newUrlInvokerMap.put(url, invoker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    keys.clear();</span><br><span class="line">    <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说， <strong>refreshInvoker</strong> 在刷新invoker列表过程中：</p>
<ol>
<li>校验 invokerUrls 中的 URL 协议是否为 “empty” ，是则代表该服务的实例数为0，此时将销毁所有已有的 invoker 实例，并将该服务标记为禁止访问；</li>
<li>否则，则缓存 invokerUrls ，并将 invokerUrls 转换为 invoker 实例列表：<ol>
<li>对 URL 进行检测，过滤消费端不支持的 URL ；</li>
<li>合并 URL 配置；</li>
<li>根据具体协议，通过Protocol#refer方法创建invoker实例；</li>
</ol>
</li>
<li>将转换后的 invoker 实例列表更新到服务目录的 invoker 实例列表；</li>
<li>销毁旧的无用的 invoker 实例。</li>
</ol>
<p>在创建 invoker 实例时，protocol 实例类型为自适应扩展实现类，而 url 协议类型为 dubbo ，可知最终使用的是 DubboProtocol实例，但通过 debug 会发现，会先经过多个 Protocol 的包装类（其中便包括用于构建Filter拦截器链的 ProtocolFilterWrapper 包装类）处理过后，最终才到 DubboProtocol ：</p>
<p><strong>AbstractProtocol#refer</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AsyncToSyncInvoker&lt;&gt;(protocolBindingRefer(type, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个点值得注意的是，在使用 protocolBindingRefer 生成 DubboInvoker 实例后，会将 DubboInovker 实例包装为 <strong>AsyncToSyncInvoker</strong> 实例，实际上 Dubbo 的调用是天然被设计为异步的，而该 Invoker 实例的作用则是将异步结果转化同步。</p>
<p><strong>DubboProtocol#protocolBindingRefer</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">protocolBindingRefer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建dubbo invoker</span></span><br><span class="line">    DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">    invokers.add(invoker);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DubboProtocol#getClients</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ExchangeClient[] getClients(URL url) &#123;</span><br><span class="line">    <span class="comment">// 是否共享连接</span></span><br><span class="line">    <span class="keyword">int</span> connections = url.getParameter(CONNECTIONS_KEY, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// if not configured, connection is shared, otherwise, one connection for one service</span></span><br><span class="line">    <span class="keyword">if</span> (connections == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The xml configuration should have a higher priority than properties.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String shareConnectionsStr = url.getParameter(SHARE_CONNECTIONS_KEY, (String) <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//获取连接数</span></span><br><span class="line">        connections = Integer.parseInt(StringUtils.isBlank(shareConnectionsStr) ? ConfigUtils.getProperty(SHARE_CONNECTIONS_KEY,</span><br><span class="line">                DEFAULT_SHARE_CONNECTIONS) : shareConnectionsStr);</span><br><span class="line">        <span class="keyword">return</span> getSharedClient(url, connections).toArray(<span class="keyword">new</span> ExchangeClient[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//初始化新的客户端</span></span><br><span class="line">        ExchangeClient[] clients = <span class="keyword">new</span> ExchangeClient[connections];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clients.length; i++) &#123;</span><br><span class="line">            clients[i] = initClient(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clients;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会先根据 connections 数量决定是获取共享客户端实例还是创建新的客户端实例，获取到客户端连接实例后，将其封装后创建 <strong>DubboInvoker</strong> 实例并返回。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>本文简单介绍了服务目录的概念，以及<strong>StaticDirectory</strong>  和 <strong>DynamicDirectory</strong>  两种服务目录类型的区别；</li>
<li>以 Nacos 作为注册中心为例，针对 <strong>RegistryDirectory</strong> 的源码作了一定的学习，包括服务的订阅过程、服务变更的通知处理流程等；</li>
<li>服务变更后将刷新内部维护的 invoker 列表，将根据实际配置初始连接或使用共享连接。</li>
</ol>
]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo源码学习：服务引用</title>
    <url>/2024/07/13/Dubbo%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>在上一篇中我们学习了Dubbo服务导出的过程，在开发中，如果我们需要引用一个服务的话，只需要在成员或方法上标注**@DubboReference**注解即可，那它内部是如何实现的呢，我们一起来看下。</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Dubbo 2.7.12版本</p>
</blockquote>
<h3 id="DubboReference注解的解析"><a href="#DubboReference注解的解析" class="headerlink" title="@DubboReference注解的解析"></a>@DubboReference注解的解析</h3><p>在通过**@EnableDubbo<strong>注解导入的</strong>DubboComponentScanRegistrar**：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata);</span><br><span class="line"></span><br><span class="line">        registerServiceClassPostProcessor(packagesToScan, registry);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// @since 2.7.6 Register the common beans</span></span><br><span class="line">        registerCommonBeans(registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>DubboBeanUtils#registerCommonBeans</strong>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerCommonBeans</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since 2.5.7 Register @Reference Annotation Bean Processor as an infrastructure Bean</span></span><br><span class="line">    registerInfrastructureBean(registry, ReferenceAnnotationBeanPostProcessor.BEAN_NAME,</span><br><span class="line">            ReferenceAnnotationBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转到<strong>ReferenceAnnotationBeanPostProcessor</strong>，查看类继承关系图：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20240713190631268.png" alt="image-20240713190631268"></p>
<p>可发现这是一个<strong>BeanPostProcessor</strong>的实现类，并实现了<strong>InstantiationAwareBeanPostProcessor</strong>和<strong>MergedBeanDefinitionPostProcessor</strong>，了解过@Autowired的注入原理的看到这里应该都会有一种熟悉感，回到其代码实现可以看到其父类<strong>AbstractAnnotationBeanPostProcessor</strong>实现了<strong>postProcessPropertyValues</strong>，不难看出，该方法也是**@DubboReference**解析的入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">//解析注解元数据</span></span><br><span class="line">    InjectionMetadata metadata = findInjectionMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//注入</span></span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Injection of @&quot;</span> + getAnnotationType().getSimpleName()</span><br><span class="line">                + <span class="string">&quot; dependencies is failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractAnnotationBeanPostProcessor#findInjectionMetadata</strong>主要是解析并获取成员或方法上的**@DubboReference<strong>注解，封装并得到</strong>AbstractAnnotationBeanPostProcessor.AnnotatedInjectionMetadata**类型对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AbstractAnnotationBeanPostProcessor.<span class="function">AnnotatedInjectionMetadata <span class="title">buildAnnotatedMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//解析要成员上的@DubboReference注解</span></span><br><span class="line">    Collection&lt;AbstractAnnotationBeanPostProcessor.AnnotatedFieldElement&gt; fieldElements = findFieldAnnotationMetadata(beanClass);</span><br><span class="line">    <span class="comment">//解析要方法上的@DubboReference注解</span></span><br><span class="line">    Collection&lt;AbstractAnnotationBeanPostProcessor.AnnotatedMethodElement&gt; methodElements = findAnnotatedMethodMetadata(beanClass);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AbstractAnnotationBeanPostProcessor.AnnotatedInjectionMetadata(beanClass, fieldElements, methodElements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后统一调用<strong>InjectionMetadata#inject</strong>方法进行注入，继续追踪则来到了<strong>ReferenceAnnotationBeanPostProcessor#doGetInjectedBean</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doGetInjectedBean</span><span class="params">(AnnotationAttributes attributes, Object bean, String beanName, Class&lt;?&gt; injectedType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   InjectionMetadata.InjectedElement injectedElement)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//生成ServiceBean名称</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The name of bean that annotated Dubbo&#x27;s &#123;<span class="doctag">@link</span> Service <span class="doctag">@Service</span>&#125; in local Spring &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String referencedBeanName = buildReferencedBeanName(attributes, injectedType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成ReferenceBean名称</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The name of bean that is declared by &#123;<span class="doctag">@link</span> Reference <span class="doctag">@Reference</span>&#125; annotation injection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String referenceBeanName = getReferenceBeanName(attributes, injectedType);</span><br><span class="line"></span><br><span class="line">    referencedBeanNameIdx.computeIfAbsent(referencedBeanName, k -&gt; <span class="keyword">new</span> TreeSet&lt;String&gt;()).add(referenceBeanName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成ReferenceBean</span></span><br><span class="line">    ReferenceBean referenceBean = buildReferenceBeanIfAbsent(referenceBeanName, attributes, injectedType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否本地Service</span></span><br><span class="line">    <span class="keyword">boolean</span> localServiceBean = isLocalServiceBean(referencedBeanName, referenceBean, attributes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保待注入服务已经导出</span></span><br><span class="line">    prepareReferenceBean(referencedBeanName, referenceBean, localServiceBean);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册ReferenceBean到Spring容器</span></span><br><span class="line">    registerReferenceBean(referencedBeanName, referenceBean, localServiceBean, referenceBeanName);</span><br><span class="line"></span><br><span class="line">    cacheInjectedReferenceBean(referenceBean, injectedElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对ReferenceBean应用其他bean后置处理器</span></span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().applyBeanPostProcessorsAfterInitialization(referenceBean.get(), referenceBeanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，<strong>buildReferencedBeanName</strong>生成的是ServiceBean（服务提供者）的名称，生成的规则遵循<strong>ServiceBean:interfaceClassName:version:group</strong>，用于后续判断待注入的服务是否可以由本地提供，而<strong>getReferenceBeanName</strong>生成的是待注入的bean的名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder beanNameBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ServiceBean&quot;</span>);</span><br><span class="line">    <span class="comment">// Required</span></span><br><span class="line">    append(beanNameBuilder, interfaceClassName);</span><br><span class="line">    <span class="comment">// Optional</span></span><br><span class="line">    append(beanNameBuilder, version);</span><br><span class="line">    append(beanNameBuilder, group);</span><br><span class="line">    <span class="comment">// Build and remove last &quot;:&quot;</span></span><br><span class="line">    String rawBeanName = beanNameBuilder.toString();</span><br><span class="line">    <span class="comment">// Resolve placeholders</span></span><br><span class="line">    <span class="keyword">return</span> environment.resolvePlaceholders(rawBeanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是待注入的服务是本地暴露的服务，直接从spring容器里获取，并以referenceBeanName为名注册一个别名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerReferenceBean</span><span class="params">(String referencedBeanName, ReferenceBean referenceBean,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">boolean</span> localServiceBean, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	/是否本地ServiceBean</span><br><span class="line">    <span class="keyword">if</span> (localServiceBean) &#123;  <span class="comment">// If @Service bean is local one</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Get  the <span class="doctag">@Service</span>&#x27;s BeanDefinition from &#123;<span class="doctag">@link</span> BeanFactory&#125;</span></span><br><span class="line"><span class="comment">         * Refer to &#123;<span class="doctag">@link</span> ServiceClassPostProcessor#buildServiceBeanDefinition&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        AbstractBeanDefinition beanDefinition = (AbstractBeanDefinition) beanFactory.getBeanDefinition(referencedBeanName);</span><br><span class="line">        RuntimeBeanReference runtimeBeanReference = (RuntimeBeanReference) beanDefinition.getPropertyValues().get(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        <span class="comment">// The name of bean annotated @Service</span></span><br><span class="line">        String serviceBeanName = runtimeBeanReference.getBeanName();</span><br><span class="line">        <span class="comment">// register Alias rather than a new bean name, in order to reduce duplicated beans</span></span><br><span class="line">        beanFactory.registerAlias(serviceBeanName, beanName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Remote @Service Bean</span></span><br><span class="line">        <span class="keyword">if</span> (!beanFactory.containsBean(beanName)) &#123;</span><br><span class="line">            beanFactory.registerSingleton(beanName, referenceBean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果由远程提供服务的话，则注册ReferenceBean，后续通过<strong>ReferenceConfig#get</strong>方法获取实际的对象并调用其他的bean后置处理器。</p>
<h3 id="ReferenceBean的生成"><a href="#ReferenceBean的生成" class="headerlink" title="ReferenceBean的生成"></a>ReferenceBean的生成</h3><p>我们注意到，<strong>ReferenceBean</strong>实现了<strong>FactoryBean</strong>接口，实际注册的bean由<strong>getObject</strong>方法提供，查看其实现可以知道<strong>getObject</strong>中也调用了<strong>ReferenceConfig#get</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The invoker of ReferenceConfig(&quot;</span> + url + <span class="string">&quot;) has already destroyed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里判断接口代理对象是否存在，不存在则进行初始化。</p>
<p>来到<strong>init</strong>方法，我们重点关注下其中的<strong>createProxy</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否本地服务引用</span></span><br><span class="line">    <span class="keyword">if</span> (shouldJvmRefer(map)) &#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(LOCAL_PROTOCOL, LOCALHOST_VALUE, <span class="number">0</span>, interfaceClass.getName()).addParameters(map);</span><br><span class="line">        invoker = REF_PROTOCOL.refer(interfaceClass, url);</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Using injvm service &quot;</span> + interfaceClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        urls.clear();</span><br><span class="line">        <span class="comment">//配置了url属性，可能是点对点调用，也可能是写的注册中心的url</span></span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; <span class="comment">// user specified URL, could be peer-to-peer address, or register center&#x27;s address.</span></span><br><span class="line">            String[] us = SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">            <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">                    URL url = URL.valueOf(u);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isEmpty(url.getPath())) &#123;</span><br><span class="line">                        url = url.setPath(interfaceName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果是registry协议，说明连接的是注册中心，就设置refer参数到url</span></span><br><span class="line">                    <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">                        urls.add(url.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//参数合并</span></span><br><span class="line">                        urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// assemble URL from register center&#x27;s configuration</span></span><br><span class="line">            <span class="comment">// if protocols not injvm checkRegistry</span></span><br><span class="line">            <span class="keyword">if</span> (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) &#123;</span><br><span class="line">                <span class="comment">//加载注册中心url</span></span><br><span class="line">                checkRegistry();</span><br><span class="line">                List&lt;URL&gt; us = ConfigValidationUtils.loadRegistries(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(us)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                        URL monitorUrl = ConfigValidationUtils.loadMonitor(<span class="keyword">this</span>, u);</span><br><span class="line">                        <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//添加refer参数到url中</span></span><br><span class="line">                        urls.add(u.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (urls.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                            <span class="string">&quot;No such any registry to reference &quot;</span> + interfaceName + <span class="string">&quot; on the consumer &quot;</span> + NetUtils.getLocalHost() +</span><br><span class="line">                                    <span class="string">&quot; use dubbo version &quot;</span> + Version.getVersion() +</span><br><span class="line">                                    <span class="string">&quot;, please config &lt;dubbo:registry address=\&quot;...\&quot; /&gt; to your spring config.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//单个注册中心或服务提供者</span></span><br><span class="line">        <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">            URL registryURL = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//获取所有的 Invoker</span></span><br><span class="line">            <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                Invoker&lt;?&gt; referInvoker = REF_PROTOCOL.refer(interfaceClass, url);</span><br><span class="line">                <span class="keyword">if</span> (shouldCheck()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (referInvoker.isAvailable()) &#123;</span><br><span class="line">                        invokers.add(referInvoker);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        referInvoker.destroy();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    invokers.add(referInvoker);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">                    registryURL = url; <span class="comment">// use last registry url</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shouldCheck() &amp;&amp; invokers.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to check the status of the service &quot;</span></span><br><span class="line">                        + interfaceName</span><br><span class="line">                        + <span class="string">&quot;. No provider available for the service &quot;</span></span><br><span class="line">                        + (group == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : group + <span class="string">&quot;/&quot;</span>)</span><br><span class="line">                        + interfaceName +</span><br><span class="line">                        (version == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;:&quot;</span> + version)</span><br><span class="line">                        + <span class="string">&quot; from the multi registry cluster&quot;</span></span><br><span class="line">                        + <span class="string">&quot; use dubbo version &quot;</span> + Version.getVersion());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">// registry url is available</span></span><br><span class="line">                <span class="comment">//对有注册中心的Cluster 只用ZoneAwareCluster</span></span><br><span class="line">                <span class="comment">// for multi-subscription scenario, use &#x27;zone-aware&#x27; policy by default</span></span><br><span class="line">                String cluster = registryURL.getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME);</span><br><span class="line">                <span class="comment">// The invoker wrap sequence would be: ZoneAwareClusterInvoker(StaticDirectory) -&gt; FailoverClusterInvoker(RegistryDirectory, routing happens here) -&gt; Invoker</span></span><br><span class="line">                invoker = Cluster.getCluster(cluster, <span class="keyword">false</span>).join(<span class="keyword">new</span> StaticDirectory(registryURL, invokers));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// not a registry url, must be direct invoke.</span></span><br><span class="line">                String cluster = CollectionUtils.isNotEmpty(invokers)</span><br><span class="line">                        ?</span><br><span class="line">                        (invokers.get(<span class="number">0</span>).getUrl() != <span class="keyword">null</span> ? invokers.get(<span class="number">0</span>).getUrl().getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME) :</span><br><span class="line">                                Cluster.DEFAULT)</span><br><span class="line">                        : Cluster.DEFAULT;</span><br><span class="line">                invoker = Cluster.getCluster(cluster).join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Refer dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; from url &quot;</span> + invoker.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    URL consumerURL = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, map.remove(REGISTER_IP_KEY), <span class="number">0</span>, map.get(INTERFACE_KEY), map);</span><br><span class="line">    MetadataUtils.publishServiceDefinition(consumerURL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建服务代理</span></span><br><span class="line">    <span class="comment">// create service proxy</span></span><br><span class="line">    <span class="keyword">return</span> (T) PROXY_FACTORY.getProxy(invoker, ProtocolUtils.isGeneric(generic));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是根据本地调用或远程调用创建不同的Invoker实例，然后创建服务代理对象。</p>
<h4 id="本地服务调用Invoker"><a href="#本地服务调用Invoker" class="headerlink" title="本地服务调用Invoker"></a>本地服务调用Invoker</h4><p>本地调用时，URL协议为injvm，Protocol实现类为<strong>InjvmProtocol</strong>，其refer方法由AbstractProtocol提供：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AsyncToSyncInvoker&lt;&gt;(protocolBindingRefer(type, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>InjvmProtocol#protocolBindingRefer</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">protocolBindingRefer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjvmInvoker&lt;T&gt;(serviceType, url, url.getServiceKey(), exporterMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里得到<strong>InjvmInvoker</strong>实例后，又将其包装成<strong>AsyncToSyncInvoker</strong>返回。</p>
<h4 id="远程服务调用Invoker"><a href="#远程服务调用Invoker" class="headerlink" title="远程服务调用Invoker"></a>远程服务调用Invoker</h4><p>在只存在一个注册中心的情况下，从传入的Url为**<em>registry://**</em>，可知由<strong>InterfaceCompatibleRegistryProtocol</strong>提供实现，<strong>InterfaceCompatibleRegistryProtocol</strong>继承自<strong>RegistryProtocol</strong>，查看<strong>InterfaceCompatibleRegistryProtocol</strong>可以发现，<strong>InterfaceCompatibleRegistryProtocol</strong>没有重写refer方法，而是重写了一些getInoker方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">ClusterInvoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        DynamicDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;&gt;(type, url);</span><br><span class="line">        <span class="keyword">return</span> doCreateInvoker(directory, cluster, registry, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">ClusterInvoker&lt;T&gt; <span class="title">getServiceDiscoveryInvoker</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            registry = registryFactory.getRegistry(<span class="keyword">super</span>.getRegistryUrl(url));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            String protocol = url.getProtocol();</span><br><span class="line">            logger.warn(protocol + <span class="string">&quot; do not support service discovery, automatically switch to interface-level service discovery.&quot;</span>);</span><br><span class="line">            registry = AbstractRegistryFactory.getDefaultNopRegistryIfNotSupportServiceDiscovery();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DynamicDirectory&lt;T&gt; directory = <span class="keyword">new</span> ServiceDiscoveryRegistryDirectory&lt;&gt;(type, url);</span><br><span class="line">        <span class="keyword">return</span> doCreateInvoker(directory, cluster, registry, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">ClusterInvoker&lt;T&gt; <span class="title">getMigrationInvoker</span><span class="params">(RegistryProtocol registryProtocol, Cluster cluster, Registry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        Class&lt;T&gt; type, URL url, URL consumerUrl)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        ClusterInvoker&lt;T&gt; invoker = getInvoker(cluster, registry, type, url);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MigrationInvoker&lt;T&gt;(registryProtocol, cluster, registry, type, url, consumerUrl);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而以上这3种Invoker，则分别用于：</p>
<ol>
<li>getInvoker为接口级Invoker;</li>
<li>getServiceDiscoveryInvoker为应用级Invoker；</li>
<li>getMigrationInvoker则同时兼容了接口级及应用级Invoker；</li>
</ol>
<p>对于接口级Invoker及应用级的Invoker，在创建对应的服务目录Directory后，都是由<strong>RegistryProtocol#doCreateInvoker</strong>创建而来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected &lt;T&gt; ClusterInvoker&lt;T&gt; doCreateInvoker(DynamicDirectory&lt;T&gt; directory, Cluster cluster, Registry registry, Class&lt;T&gt; type) &#123;</span><br><span class="line">	&#x2F;&#x2F;设置注册中心和协议</span><br><span class="line">    directory.setRegistry(registry);</span><br><span class="line">    directory.setProtocol(protocol);</span><br><span class="line">    &#x2F;&#x2F; all attributes of REFER_KEY</span><br><span class="line">    Map&lt;String, String&gt; parameters &#x3D; new HashMap&lt;String, String&gt;(directory.getConsumerUrl().getParameters());</span><br><span class="line">    &#x2F;&#x2F;生成服务消费者链接</span><br><span class="line">    URL urlToRegistry &#x3D; new URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), 0, type.getName(), parameters);</span><br><span class="line">    if (directory.isShouldRegister()) &#123;</span><br><span class="line">        directory.setRegisteredConsumerUrl(urlToRegistry);</span><br><span class="line">        registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    directory.buildRouterChain(urlToRegistry);</span><br><span class="line">    &#x2F;&#x2F;服务订阅</span><br><span class="line">    directory.subscribe(toSubscribeUrl(urlToRegistry));</span><br><span class="line">    &#x2F;&#x2F;调用MockClusterWrapper#join生成Invoker，这里的Invoker类型为MockClusterInvoker</span><br><span class="line">    return (ClusterInvoker&lt;T&gt;) cluster.join(directory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于doCreateInvoker返回的invoker类型，这里通过debug继续深入到 <strong>MockClusterWrapper#join</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//cluster类型为FailoverCluster</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MockClusterInvoker&lt;T&gt;(directory,</span><br><span class="line">            <span class="keyword">this</span>.cluster.join(directory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractCluster#join</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//通过doJoin构建 FailoverClusterInvoker ，然后构建cluster拦截器链并返回，此时返回的类型为 InterceptorInvokerNode</span></span><br><span class="line">    <span class="keyword">return</span> buildClusterInterceptors(doJoin(directory), directory.getUrl().getParameter(REFERENCE_INTERCEPTOR_KEY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到doCreateInvoker最终得到的类型为 <strong>InterceptorInvokerNode</strong>。</p>
<p>回到<strong>RegistryProtocol#refer</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">	<span class="comment">//转换协议头，比如nacos://</span></span><br><span class="line">    url = getRegistryUrl(url);</span><br><span class="line">    <span class="comment">//获取注册中心实例</span></span><br><span class="line">    Registry registry = getRegistry(url);</span><br><span class="line">    <span class="keyword">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将url查询字符串转化为map</span></span><br><span class="line">    <span class="comment">// group=&quot;a,b&quot; or group=&quot;*&quot;</span></span><br><span class="line">    Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">    String group = qs.get(GROUP_KEY);</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="number">1</span> || <span class="string">&quot;*&quot;</span>.equals(group)) &#123;</span><br><span class="line">            <span class="keyword">return</span> doRefer(Cluster.getCluster(MergeableCluster.NAME), registry, type, url, qs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//获取集群容错模式，默认failover，此处经过包装为MockClusterWrapper</span></span><br><span class="line">    Cluster cluster = Cluster.getCluster(qs.get(CLUSTER_KEY));</span><br><span class="line">    <span class="keyword">return</span> doRefer(cluster, registry, type, url, qs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url, Map&lt;String, String&gt; parameters)</span> </span>&#123;</span><br><span class="line">        URL consumerUrl = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">        <span class="comment">//生成MigrationInvoker</span></span><br><span class="line">        ClusterInvoker&lt;T&gt; migrationInvoker = getMigrationInvoker(<span class="keyword">this</span>, cluster, registry, type, url, consumerUrl);</span><br><span class="line">        <span class="keyword">return</span> interceptInvoker(migrationInvoker, url, consumerUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到这里实际创建的是MigrationInvoker，在得到MigrationInvoker后，一路跟踪来到<strong>MigrationRuleListener#onRefer</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized void onRefer(RegistryProtocol registryProtocol, ClusterInvoker&lt;?&gt; invoker, URL url) &#123;</span><br><span class="line">    MigrationInvoker&lt;?&gt; migrationInvoker &#x3D; (MigrationInvoker&lt;?&gt;) invoker;</span><br><span class="line"></span><br><span class="line">    MigrationRuleHandler&lt;?&gt; migrationListener &#x3D; new MigrationRuleHandler&lt;&gt;(migrationInvoker);</span><br><span class="line">    listeners.add(migrationListener);</span><br><span class="line"></span><br><span class="line">    migrationListener.doMigrate(rawRule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入规则信息，进入到<strong>MigrationRuleHandler#doMigrate</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doMigrate</span><span class="params">(String rawRule)</span> </span>&#123;</span><br><span class="line">    MigrationRule rule = MigrationRule.parse(rawRule);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != currentStep &amp;&amp; currentStep.equals(rule.getStep())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Migration step is not change. rule.getStep is &quot;</span> + currentStep.name());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentStep = rule.getStep();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    migrationInvoker.setMigrationRule(rule);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (migrationInvoker.isMigrationMultiRegistry()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (migrationInvoker.isServiceInvoker()) &#123;</span><br><span class="line">            migrationInvoker.refreshServiceDiscoveryInvoker();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            migrationInvoker.refreshInterfaceInvoker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (rule.getStep()) &#123;</span><br><span class="line">            <span class="comment">//应用级优先</span></span><br><span class="line">            <span class="keyword">case</span> APPLICATION_FIRST:</span><br><span class="line">                migrationInvoker.migrateToServiceDiscoveryInvoker(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//应用级</span></span><br><span class="line">            <span class="keyword">case</span> FORCE_APPLICATION:</span><br><span class="line">                migrationInvoker.migrateToServiceDiscoveryInvoker(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//接口级</span></span><br><span class="line">            <span class="keyword">case</span> FORCE_INTERFACE:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                migrationInvoker.fallbackToInterfaceInvoker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里根据不同规则，来到<strong>MigrationRuleHandler#migrateToServiceDiscoveryInvoker</strong>，最终调用 <strong>RegistryProtocol#doCreateInvoker</strong> 创建对应的接口级或应用级Invoker:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">migrateToServiceDiscoveryInvoker</span><span class="params">(<span class="keyword">boolean</span> forceMigrate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!forceMigrate) &#123;</span><br><span class="line">   		<span class="comment">//应用级及接口级服务发现双订阅</span></span><br><span class="line">        refreshServiceDiscoveryInvoker();</span><br><span class="line">        refreshInterfaceInvoker();</span><br><span class="line">        setListener(invoker, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.compareAddresses(serviceDiscoveryInvoker, invoker);</span><br><span class="line">        &#125;);</span><br><span class="line">        setListener(serviceDiscoveryInvoker, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.compareAddresses(serviceDiscoveryInvoker, invoker);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">//应用级服务发现</span></span><br><span class="line">        refreshServiceDiscoveryInvoker();</span><br><span class="line">        setListener(serviceDiscoveryInvoker, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.destroyInterfaceInvoker(<span class="keyword">this</span>.invoker);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建服务代理类"><a href="#创建服务代理类" class="headerlink" title="创建服务代理类"></a>创建服务代理类</h4><p>Invoker 创建完毕后，最后通过<strong>ProxyFactory #getProxy</strong>创建服务代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory PROXY_FACTORY = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br><span class="line"><span class="comment">//省略...</span></span><br><span class="line">   <span class="keyword">return</span> (T) PROXY_FACTORY.getProxy(invoker, ProtocolUtils.isGeneric(generic));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的PROXY_FACTORY是一个自适应扩展点，根据url的proxy参数使用使用不同的代理实现，默认使用<strong>JavassistProxyFactory</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那最终生成的代理类是什么样的呢，这里通过arthas反编译得到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxy0</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ClassGenerator</span>.<span class="title">DC</span>,</span></span><br><span class="line"><span class="class"><span class="title">EchoService</span>,</span></span><br><span class="line"><span class="class"><span class="title">Destroyable</span>,</span></span><br><span class="line"><span class="class"><span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method[] methods;</span><br><span class="line">    <span class="keyword">private</span> InvocationHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object $echo(Object object) &#123;</span><br><span class="line">        Object[] objectArray = <span class="keyword">new</span> Object[]&#123;object&#125;;</span><br><span class="line">        Object object2 = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], objectArray);</span><br><span class="line">        <span class="keyword">return</span> object2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object[] objectArray = <span class="keyword">new</span> Object[]&#123;&#125;;</span><br><span class="line">        Object object = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">1</span>], objectArray);</span><br><span class="line">        <span class="keyword">return</span> (String)object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> $destroy() &#123;</span><br><span class="line">        Object[] objectArray = <span class="keyword">new</span> Object[]&#123;&#125;;</span><br><span class="line">        Object object = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">2</span>], objectArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">(InvocationHandler invocationHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = invocationHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，对Dubbo接口的调用，都会转发给<strong>InvokerInvocationHandler</strong>，最终调用到对应的invoker。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p><strong>@DubboReference</strong>的注解由<strong>ReferenceAnnotationBeanPostProcessor</strong>解析并注入，注入的对象是通过<strong>ReferenceBean#get</strong>根据实际情况生成的Invoker实例；</p>
</li>
<li><p><strong>ReferenceBean#get</strong>获取到的对象是代理过的Invoker实例，而Invoker实例由<strong>Protocol#refer</strong>得到：</p>
<ol>
<li>若是，则调用<strong>InjvmProtocol</strong>的refer方法生成Invoker实例；</li>
<li>否则读取直连配置项或注册中心url，并将读取到的url存储到urls中，此时Invoker由<strong>InterfaceCompatibleRegistryProtocol</strong>生成：<ol>
<li>若urls元素数量为1，则直接通过Protocol自适应拓展类构建 Invoker实例接口；</li>
<li>若urls元素数量大于1，即存在多个注册中心或服务直连url，此时先根据url构建Invoker，然后再通过Cluster合并多个Invoker，</li>
</ol>
</li>
</ol>
</li>
<li><p>生成对应的Invoker实例后，再创建服务代理实例。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo源码学习：服务导出</title>
    <url>/2024/07/06/Dubbo%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<p>我们都知道，在Dubbo微服务项目开发中，只需要通过**@EnableDubbo<strong>和</strong>@DubboService**注解就可以把服务注册到注册中心，那整个过程是怎么发生的呢？</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Dubbo 2.7.12版本</p>
</blockquote>
<h3 id="从-EnableDubbo说起"><a href="#从-EnableDubbo说起" class="headerlink" title="从@EnableDubbo说起"></a>从@EnableDubbo说起</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//省略...</span></span><br><span class="line"><span class="meta">@EnableDubboConfig</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDubbo &#123;</span><br><span class="line">	<span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@EnableDubbo</strong>主要包含了**@EnableDubboConfig<strong>和</strong>@DubboComponentScan<strong>，我们重点看下</strong>@DubboComponentScan**：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//省略...</span></span><br><span class="line"><span class="meta">@Import(DubboComponentScanRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DubboComponentScan &#123;</span><br><span class="line">	<span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个熟悉的**@Import<strong>注解，它导入了一个</strong>DubboComponentScanRegistrar**类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//获取元数据扫描路径</span></span><br><span class="line">        Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata);</span><br><span class="line">		<span class="comment">//注册ServiceClassPostProcessor</span></span><br><span class="line">        registerServiceClassPostProcessor(packagesToScan, registry);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//注册通用bean</span></span><br><span class="line">        <span class="comment">// @since 2.7.6 Register the common beans</span></span><br><span class="line">        registerCommonBeans(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceClassPostProcessor</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BeanDefinitionBuilder builder = rootBeanDefinition(ServiceClassPostProcessor.class);</span><br><span class="line">        builder.addConstructorArgValue(packagesToScan);</span><br><span class="line">        builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line">        BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>DubboComponentScanRegistrar</strong>最终又将<strong>ServiceClassPostProcessor</strong>注册到了IOC容器：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20240630164051353.png" alt="image-20240630164051353"></p>
<p><strong>ServiceClassPostProcessor</strong>实现了<strong>BeanDefinitionRegistryPostProcessor</strong>接口，可以通过实现<strong>postProcessBeanDefinitionRegistry</strong>新增bean定义，并将其注册到IOC容器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册一个监听器</span></span><br><span class="line">    registerInfrastructureBean(registry, DubboBootstrapApplicationListener.BEAN_NAME, DubboBootstrapApplicationListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取扫描路径</span></span><br><span class="line">    Set&lt;String&gt; resolvedPackagesToScan = resolvePackagesToScan(packagesToScan);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(resolvedPackagesToScan)) &#123;</span><br><span class="line">        <span class="comment">//注册ServiceBean</span></span><br><span class="line">        registerServiceBeans(resolvedPackagesToScan, registry);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到<strong>registerServiceBeans</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBeans</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DubboClassPathBeanDefinitionScanner scanner =</span><br><span class="line">            <span class="keyword">new</span> DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader);</span><br><span class="line"></span><br><span class="line">    BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry);</span><br><span class="line"></span><br><span class="line">    scanner.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描@DubboService、@Service、@com.alibaba.dubbo.config.annotation.Service注解</span></span><br><span class="line">    serviceAnnotationTypes.forEach(annotationType -&gt; &#123;</span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(annotationType));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String packageToScan : packagesToScan) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Registers @Service Bean first</span></span><br><span class="line">        scanner.scan(packageToScan);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描并获取所有满足条件的BeanDefinition</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders =</span><br><span class="line">                findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(beanDefinitionHolders)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) &#123;</span><br><span class="line">                <span class="comment">//注册ServiceBean</span></span><br><span class="line">                registerServiceBean(beanDefinitionHolder, registry, scanner);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//省略...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们知道了，Dubbo启动后会通过扫描**@DubboService<strong>等注解，并注册</strong>ServiceBean**到IOC容器，除此之外，未发现Dubbo服务启动和注册相关的逻辑。</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20240630212039912.png" alt="ServiceBean类继承关系图"></p>
<p>这里有一个值得注意的点是，在<strong>AbstractConfig</strong>类中，有一个<strong>addIntoConfigManager</strong>初始化方法，会将当前配置类添加到全局的配置管理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIntoConfigManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationModel.getConfigManager().addConfig(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到<strong>postProcessBeanDefinitionRegistry</strong>，我们还发现它注册了一个<strong>DubboBootstrapApplicationListener</strong>监听器，查看其实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationContextEvent</span><span class="params">(ApplicationContextEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DubboBootstrapStartStopListenerSpringAdapter.applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        DubboBootstrapStartStopListenerSpringAdapter.applicationContext = event.getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">        onContextRefreshedEvent((ContextRefreshedEvent) event);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">        onContextClosedEvent((ContextClosedEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onContextRefreshedEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">    dubboBootstrap.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出，Dubbo服务的启动是在 Spring 容器发布刷新事件后，由<strong>DubboBootstrapApplicationListener</strong>监听器触发的。</p>
<h3 id="服务导出"><a href="#服务导出" class="headerlink" title="服务导出"></a>服务导出</h3><p>来到<strong>DubboBootstrap#start</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DubboBootstrap <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//乐观锁，避免重复启动</span></span><br><span class="line">    <span class="keyword">if</span> (started.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        destroyed.set(<span class="keyword">false</span>);</span><br><span class="line">        ready.set(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        initialize();</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(NAME + <span class="string">&quot; is starting...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 服务导出</span></span><br><span class="line">        exportServices();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Not only provider register</span></span><br><span class="line">        <span class="keyword">if</span> (!isOnlyRegisterProvider() || hasExportedServices()) &#123;</span><br><span class="line">            <span class="comment">//导出元数据服务</span></span><br><span class="line">            exportMetadataService();</span><br><span class="line">            <span class="comment">//注册本地服务实例</span></span><br><span class="line">            registerServiceInstance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        referServices();</span><br><span class="line">		<span class="comment">//省略...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重点看下服务的导出，<strong>DubboBootstrap#exportServices</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历需要导出的服务</span></span><br><span class="line">    configManager.getServices().forEach(sc -&gt; &#123;</span><br><span class="line">        <span class="comment">// TODO, compatible with ServiceConfig.export()</span></span><br><span class="line">        ServiceConfig serviceConfig = (ServiceConfig) sc;yn</span><br><span class="line">        serviceConfig.setBootstrap(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步导出</span></span><br><span class="line">        <span class="keyword">if</span> (exportAsync) &#123;</span><br><span class="line">            ExecutorService executor = executorRepository.getServiceExporterExecutor();</span><br><span class="line">            Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    exportService(serviceConfig);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;export async catch error : &quot;</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            asyncExportingFutures.add(future);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exportService(serviceConfig);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到<strong>ServiceConfig#export</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查bootstrap是否初始化</span></span><br><span class="line">    <span class="keyword">if</span> (bootstrap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        bootstrap = DubboBootstrap.getInstance();</span><br><span class="line">        <span class="comment">// compatible with api call.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.getRegistry()) &#123;</span><br><span class="line">            bootstrap.registries(<span class="keyword">this</span>.getRegistries());</span><br><span class="line">        &#125;</span><br><span class="line">        bootstrap.initialize();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//检查相关配置</span></span><br><span class="line">    checkAndUpdateSubConfigs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化元数据</span></span><br><span class="line">    initServiceMetadata(provider);</span><br><span class="line">    serviceMetadata.setServiceType(getInterfaceClass());</span><br><span class="line">    serviceMetadata.setTarget(getRef());</span><br><span class="line">    serviceMetadata.generateServiceKey();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否导出</span></span><br><span class="line">    <span class="keyword">if</span> (!shouldExport()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否延迟导出</span></span><br><span class="line">    <span class="keyword">if</span> (shouldDelay()) &#123;</span><br><span class="line">        DELAY_EXPORT_EXECUTOR.schedule(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Delay export server should print stack trace if there are exception occur.</span></span><br><span class="line">                <span class="keyword">this</span>.doExport();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;delay export server occur exception, please check it.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getDelay(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doExport();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exported();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ServiceConfig#doExportUrls</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取服务仓库，缓存provider</span></span><br><span class="line">    ServiceRepository repository = ApplicationModel.getServiceRepository();</span><br><span class="line">    ServiceDescriptor serviceDescriptor = repository.registerService(getInterfaceClass());</span><br><span class="line">    repository.registerProvider(</span><br><span class="line">            getUniqueServiceName(),</span><br><span class="line">            ref,</span><br><span class="line">            serviceDescriptor,</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            serviceMetadata</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取服务注册中心，协议为registry://</span></span><br><span class="line">    List&lt;URL&gt; registryURLs = ConfigValidationUtils.loadRegistries(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在每个协议下注册服务</span></span><br><span class="line">    <span class="keyword">int</span> protocolConfigNum = protocols.size();</span><br><span class="line">    <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">        String pathKey = URL.buildKey(getContextPath(protocolConfig)</span><br><span class="line">                .map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path)</span><br><span class="line">                .orElse(path), group, version);</span><br><span class="line">        <span class="comment">// In case user specified path, register service one more time to map it to path.</span></span><br><span class="line">        repository.registerService(pathKey, interfaceClass);</span><br><span class="line">        doExportUrlsFor1Protocol(protocolConfig, registryURLs, protocolConfigNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，Dubbo允许我们使用不同的协议导出服务，同时向多个注册中心注册服务。</p>
<p>进入到<strong>ServiceConfig#doExportUrlsFor1Protocol</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs, <span class="keyword">int</span> protocolConfigNum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//转义名默认为dubbo</span></span><br><span class="line">    String name = protocolConfig.getName();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        name = DUBBO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收集URL参数</span></span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(SIDE_KEY, PROVIDER_SIDE);</span><br><span class="line"></span><br><span class="line">    ServiceConfig.appendRuntimeParameters(map);</span><br><span class="line">    AbstractConfig.appendParameters(map, getMetrics());</span><br><span class="line">    AbstractConfig.appendParameters(map, getApplication());</span><br><span class="line">    AbstractConfig.appendParameters(map, getModule());</span><br><span class="line">    <span class="comment">// remove &#x27;default.&#x27; prefix for configs from ProviderConfig</span></span><br><span class="line">    <span class="comment">// appendParameters(map, provider, Constants.DEFAULT_KEY);</span></span><br><span class="line">    AbstractConfig.appendParameters(map, provider);</span><br><span class="line">    AbstractConfig.appendParameters(map, protocolConfig);</span><br><span class="line">    AbstractConfig.appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">    MetadataReportConfig metadataReportConfig = getMetadataReportConfig();</span><br><span class="line">    <span class="keyword">if</span> (metadataReportConfig != <span class="keyword">null</span> &amp;&amp; metadataReportConfig.isValid()) &#123;</span><br><span class="line">        map.putIfAbsent(METADATA_KEY, REMOTE_METADATA_STORAGE_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析收集org.apache.dubbo.config.annotation.Method注解参数</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(getMethods())) &#123;</span><br><span class="line">        <span class="keyword">for</span> (MethodConfig method : getMethods()) &#123;</span><br><span class="line">			<span class="comment">//省略...</span></span><br><span class="line">        &#125; <span class="comment">// end of methods for</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否泛化调用</span></span><br><span class="line">    <span class="keyword">if</span> (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">        map.put(GENERIC_KEY, generic);</span><br><span class="line">        map.put(METHODS_KEY, ANY_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">        <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(REVISION_KEY, revision);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       	<span class="comment">//获取接口方法并添加到URL参数</span></span><br><span class="line">        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">        <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;No method found in service interface &quot;</span> + interfaceClass.getName());</span><br><span class="line">            map.put(METHODS_KEY, ANY_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(METHODS_KEY, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">&quot;,&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加token到参数map</span></span><br><span class="line">    <span class="keyword">if</span> (ConfigUtils.isEmpty(token) &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        token = provider.getToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">            map.put(TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(TOKEN_KEY, token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//init serviceMetadata attachments</span></span><br><span class="line">    serviceMetadata.getAttachments().putAll(map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取主机和端口，得到最终的URL，如dubbo://192.168.1.1:20880/x.y.z.HelloService?a=b</span></span><br><span class="line">    String host = findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">    Integer port = findConfigedPorts(protocolConfig, name, map, protocolConfigNum);</span><br><span class="line">    URL url = <span class="keyword">new</span> URL(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path).orElse(path), map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加额外参数</span></span><br><span class="line">    <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">            .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String scope = url.getParameter(SCOPE_KEY);</span><br><span class="line">    <span class="comment">// don&#x27;t export when none is configured</span></span><br><span class="line">    <span class="keyword">if</span> (!SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">		<span class="comment">//是否本地导出</span></span><br><span class="line">        <span class="comment">// export to local if the config is not remote (export to remote only when config is remote)</span></span><br><span class="line">        <span class="keyword">if</span> (!SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            exportLocal(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是否远程导出</span></span><br><span class="line">        <span class="comment">// export to remote if the config is not local (export to local only when config is local)</span></span><br><span class="line">        <span class="keyword">if</span> (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(registryURLs)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (SERVICE_REGISTRY_PROTOCOL.equals(registryURL.getProtocol())) &#123;</span><br><span class="line">                        url = url.addParameterIfAbsent(REGISTRY_TYPE_KEY, SERVICE_REGISTRY_TYPE);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//if protocol is only injvm ,not register</span></span><br><span class="line">                    <span class="keyword">if</span> (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));</span><br><span class="line">                    <span class="comment">//加载监视器链接并追加</span></span><br><span class="line">                    URL monitorUrl = ConfigValidationUtils.loadMonitor(<span class="keyword">this</span>, registryURL);</span><br><span class="line">                    <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            logger.info(<span class="string">&quot;Register dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; url &quot;</span> + url + <span class="string">&quot; to registry &quot;</span> +</span><br><span class="line">                                    registryURL);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to url &quot;</span> + url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//是否使用自定义动态代理</span></span><br><span class="line">                    <span class="comment">// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class="line">                    String proxy = url.getParameter(PROXY_KEY);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                        registryURL = registryURL.addParameter(PROXY_KEY, proxy);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//生成代理类invoker</span></span><br><span class="line">                    Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass,</span><br><span class="line">                            registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));</span><br><span class="line">                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line">					</span><br><span class="line">                    <span class="comment">//导出服务，并生成exporter</span></span><br><span class="line">                    Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);</span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不存在注册中心，仅导出exporter</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to url &quot;</span> + url);</span><br><span class="line">                &#125;</span><br><span class="line">                Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line">                <span class="comment">//协议为dubbo://，使用DubboProtocol导出</span></span><br><span class="line">                Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);</span><br><span class="line">                exporters.add(exporter);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            MetadataUtils.publishServiceDefinition(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.urls.add(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里主要做了几件事：</p>
<ol>
<li>构建参数map，组装URL对象，这里需要注意的是，这里的 URL 不是<strong>java.net.URL</strong>，而是<strong>com.alibaba.dubbo.common.URL</strong>；</li>
<li>根据scope参数导出服务，同时生成代理Invoker：<ul>
<li>为none时，不导出服务</li>
<li>不为remote时，导出到本地</li>
<li>不为local时，导出到远程</li>
</ul>
</li>
</ol>
<h4 id="创建Invoker"><a href="#创建Invoker" class="headerlink" title="创建Invoker"></a>创建Invoker</h4><p>Invoker是由<strong>ProxyFactory</strong>创建的，Dubbo默认使用的ProxyFactory实现类为<strong>JavassistProxyFactory</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistProxyFactory</span> <span class="keyword">extends</span> <span class="title">AbstractProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Wrapper类实例</span></span><br><span class="line">        <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">&#x27;$&#x27;</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">        <span class="comment">//覆写doInvoke方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<strong>JavassistProxyFactory</strong>首先创建了Wrapper类，然后重写了<strong>AbstractProxyInvoker</strong>的<strong>doInvoke</strong>方法，并将调用转发给了Wrapper实例。我们直接看下Wrapper类是如何创建的，深入可发现其关键方法在于<strong>Wrapper#makeWrapper</strong>，这里我们直接通过arthas工具反编译生成的Wrapper类的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper1</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Wrapper</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ClassGenerator</span>.<span class="title">DC</span> </span>&#123;</span><br><span class="line">    <span class="comment">//公有字段、getter、setter字段名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] pns;</span><br><span class="line">    <span class="comment">//公有字段、getter、setter字段名及类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map pts;</span><br><span class="line">    <span class="comment">//所有方法名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] mns;</span><br><span class="line">    <span class="comment">//当前类方法名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] dmns;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class[] mts0;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getPropertyNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> pns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasProperty</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pts.containsKey(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">getPropertyType</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Class)pts.get(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getMethodNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> mns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getDeclaredMethodNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> dmns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(Object object, String string, Object object2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HelloServiceImpl helloServiceImpl = (HelloServiceImpl)object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (string.equals(<span class="string">&quot;foo&quot;</span>)) &#123;</span><br><span class="line">            helloServiceImpl.foo = (String)object2;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchPropertyException(<span class="keyword">new</span> StringBuffer().append(<span class="string">&quot;Not found property \&quot;&quot;</span>).append(string).append(<span class="string">&quot;\&quot; field or setter method in class laixiaoming.service.HelloServiceImpl.&quot;</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getPropertyValue</span><span class="params">(Object object, String string)</span> </span>&#123;</span><br><span class="line">        HelloServiceImpl helloServiceImpl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            helloServiceImpl = (HelloServiceImpl)object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (string.equals(<span class="string">&quot;foo&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> helloServiceImpl.foo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchPropertyException(<span class="keyword">new</span> StringBuffer().append(<span class="string">&quot;Not found property \&quot;&quot;</span>).append(string).append(<span class="string">&quot;\&quot; field or getter method in class laixiaoming.service.HelloServiceImpl.&quot;</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invokeMethod</span><span class="params">(Object object, String string, Class[] classArray, Object[] objectArray)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</span><br><span class="line">        HelloServiceImpl helloServiceImpl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            helloServiceImpl = (HelloServiceImpl)object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;sayHello&quot;</span>.equals(string) &amp;&amp; classArray.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> helloServiceImpl.sayHello();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvocationTargetException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(<span class="keyword">new</span> StringBuffer().append(<span class="string">&quot;Not found method \&quot;&quot;</span>).append(string).append(<span class="string">&quot;\&quot; in class laixiaoming.service.HelloServiceImpl.&quot;</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看其实现可以知道，服务提供类的Invoker主要提供3个方法，其中<strong>setPropertyValue</strong>用于设置服务提供类的属性值，<strong>getPropertyValue</strong>用于获取服务提供类的属性值，<strong>invokeMethod</strong>方则用于调用服务提供类的方法。</p>
<h4 id="导出服务到本地"><a href="#导出服务到本地" class="headerlink" title="导出服务到本地"></a>导出服务到本地</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportLocal</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    URL local = URLBuilder.from(url)</span><br><span class="line">            .setProtocol(LOCAL_PROTOCOL)</span><br><span class="line">            .setHost(LOCALHOST_VALUE)</span><br><span class="line">            .setPort(<span class="number">0</span>)</span><br><span class="line">            .build();</span><br><span class="line">    Exporter&lt;?&gt; exporter = PROTOCOL.export(</span><br><span class="line">            PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, local));</span><br><span class="line">    exporters.add(exporter);</span><br><span class="line">    logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to local registry url : &quot;</span> + local);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>导出服务到本地时，先创建Invoker，然后调用<strong>Protocol#export</strong>导出，此时URL协议头为<strong>injvm</strong>，使用的Protocol实现为<strong>InjvmProtocol</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将Invoker包装为Exporter后就返回了。</p>
<h4 id="导出服务到远程"><a href="#导出服务到远程" class="headerlink" title="导出服务到远程"></a>导出服务到远程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol PROTOCOL = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>

<p>根据<strong>registryURL</strong>可判断这里调用的是<strong>RegistryProtocol</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//获取注册地址</span></span><br><span class="line">    URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">    <span class="comment">//获取服务地址，即传递进来的export参数，如dubbo://...</span></span><br><span class="line">    <span class="comment">// url to export locally</span></span><br><span class="line">    URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向注册中心进行订阅 override 数据</span></span><br><span class="line">    <span class="comment">// Subscribe the override data</span></span><br><span class="line">    <span class="comment">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call</span></span><br><span class="line">    <span class="comment">//  the same service. Because the subscribed is cached key with the name of the service, it causes the</span></span><br><span class="line">    <span class="comment">//  subscription information to cover.</span></span><br><span class="line">    <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);</span><br><span class="line">    <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">    providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class="line">    <span class="comment">//导出到provider</span></span><br><span class="line">    <span class="comment">// export invoker</span></span><br><span class="line">    <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// url to registry</span></span><br><span class="line">    <span class="comment">//获取注册中心实例</span></span><br><span class="line">    <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">    <span class="keyword">final</span> URL registeredProviderUrl = getUrlToRegistry(providerUrl, registryUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// decide if we need to delay publish</span></span><br><span class="line">    <span class="keyword">boolean</span> register = providerUrl.getParameter(REGISTER_KEY, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (register) &#123;</span><br><span class="line">        <span class="comment">//注册</span></span><br><span class="line">        registry.register(registeredProviderUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register stated url on provider model</span></span><br><span class="line">    registerStatedUrl(registryUrl, registeredProviderUrl, register);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">    exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deprecated! Subscribe to override rules in 2.6.x or before.</span></span><br><span class="line">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">    notifyExport(exporter);</span><br><span class="line">    <span class="comment">//Ensure that a new exporter instance is returned every time export</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;&gt;(exporter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到<strong>RegistryProtocol#doLocalExport</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private &lt;T&gt; ExporterChangeableWrapper&lt;T&gt; doLocalExport(final Invoker&lt;T&gt; originInvoker, URL providerUrl) &#123;</span><br><span class="line">    String key &#x3D; getCacheKey(originInvoker);</span><br><span class="line"></span><br><span class="line">    return (ExporterChangeableWrapper&lt;T&gt;) bounds.computeIfAbsent(key, s -&gt; &#123;</span><br><span class="line">        Invoker&lt;?&gt; invokerDelegate &#x3D; new InvokerDelegate&lt;&gt;(originInvoker, providerUrl);</span><br><span class="line">        return new ExporterChangeableWrapper&lt;&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegate), originInvoker);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的运行时协议是dubbo，协议为dubbo://，则protocol实例则是<strong>DubboProtocol</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取服务标识</span></span><br><span class="line">    <span class="comment">// export service.</span></span><br><span class="line">    String key = serviceKey(url);</span><br><span class="line">    <span class="comment">//创建DubboExporter并放入缓存</span></span><br><span class="line">    DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">    exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//export an stub service for dispatching event</span></span><br><span class="line">    Boolean isStubSupportEvent = url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);</span><br><span class="line">    Boolean isCallbackservice = url.getParameter(IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">        String stubServiceMethods = url.getParameter(STUB_EVENT_METHODS_KEY);</span><br><span class="line">        <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;consumer [&quot;</span> + url.getParameter(INTERFACE_KEY) +</span><br><span class="line">                        <span class="string">&quot;], has set stubproxy support event ,but no stub methods founded.&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动本地服务器</span></span><br><span class="line">    openServer(url);</span><br><span class="line">    optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 Exporter实例，并将其放入 DubboProtocol 的 <strong>exporterMap</strong> 缓存，启动本地服务器后，就是注册服务。</p>
<h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><p>获取注册中心实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Registry <span class="title">getRegistry</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; originInvoker)</span> </span>&#123;</span><br><span class="line">    URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">    <span class="keyword">return</span> getRegistry(registryUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这里使用的注册中心为nacos，此时registryUrl的协议被转换为了nacos：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Registry <span class="title">getRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> registryFactory.getRegistry(url);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        LOGGER.error(t.getMessage(), t);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里registryFactory为<strong>RegistryFactory</strong>的自适应扩展类，由<strong>SpiExtensionFactory</strong>注入，最终获取到的RegistryFactory实例类型为<strong>ListenerRegistryWrapper</strong>，由包装类<strong>RegistryFactoryWrapper#getRegistry</strong>返回，registryFactory类型为<strong>NacosRegistryFactory</strong>，getResistry获取到的Registry类型为<strong>NacosRegistry</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Registry getRegistry(URL url) &#123;</span><br><span class="line">    return new ListenerRegistryWrapper(registryFactory.getRegistry(url),</span><br><span class="line">            Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(RegistryServiceListener.class)</span><br><span class="line">                    .getActivateExtension(url, &quot;registry.listeners&quot;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RegistryFactoryWrapper#register</strong>方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registry.register(url);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(listeners)) &#123;</span><br><span class="line">            RuntimeException exception = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (RegistryServiceListener listener : listeners) &#123;</span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        listener.onRegister(url);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException t) &#123;</span><br><span class="line">                        logger.error(t.getMessage(), t);</span><br><span class="line">                        exception = t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终来到<strong>NacosRegistry#doRegister</strong>，向Nacos注册服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取服务名</span></span><br><span class="line">    <span class="keyword">final</span> String serviceName = getServiceName(url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务实例信息</span></span><br><span class="line">    <span class="keyword">final</span> Instance instance = createInstance(url);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  namingService.registerInstance with &#123;<span class="doctag">@link</span> org.apache.dubbo.registry.support.AbstractRegistry#registryUrl&#125;</span></span><br><span class="line"><span class="comment">     *  default &#123;<span class="doctag">@link</span> DEFAULT_GROUP&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * in https://github.com/apache/dubbo/issues/5978</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    execute(namingService -&gt; namingService.registerInstance(serviceName,</span><br><span class="line">            getUrl().getParameter(GROUP_KEY, Constants.DEFAULT_GROUP), instance));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文简单分析了，Dubbo服务的启动和注册过程，包括：</p>
<ol>
<li><strong>@EnableDubbo</strong>注解的原理及Dubbo的启动入口；</li>
<li>Dubbo服务导出的过程：包括URL组装、服务的导出及本地服务的启动；</li>
<li>在没有注册中心时，根据dubbo://协议，使用DubboProtocol导出；存在注册中心的情况下，先根据registry://协议使用RegistryProtocol导出，再使用传递进来的export参数，使用DubboProtocol进行导出；</li>
<li>远程服务的情况下，创建注册中心实例，进行服务注册（以Nacos为例）。</li>
</ol>
]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：@Autowired的解析</title>
    <url>/2023/05/18/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A@Autowired%E7%9A%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>@Autowired是开发中常用的注解，我们可以使用@Autowired将其标记在构造函数、成员变量、setter方法上，并由Spring自动完成依赖注入的工作。但是，这个过程是怎么完成的呢？</p>
<span id="more"></span>

<p>理解这个之前，我们需要先了解一下<strong>BeanPostProcessor</strong>概念。</p>
<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<h3 id="BeanPostProcessor是什么"><a href="#BeanPostProcessor是什么" class="headerlink" title="BeanPostProcessor是什么"></a>BeanPostProcessor是什么</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory hook that allows for custom modification of new bean instances,</span></span><br><span class="line"><span class="comment"> * e.g. checking for marker interfaces or wrapping them with proxies.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;ApplicationContexts can autodetect BeanPostProcessor beans in their</span></span><br><span class="line"><span class="comment"> * bean definitions and apply them to any beans subsequently created.</span></span><br><span class="line"><span class="comment"> * Plain bean factories allow for programmatic registration of post-processors,</span></span><br><span class="line"><span class="comment"> * applying to all beans created through this factory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Typically, post-processors that populate beans via marker interfaces</span></span><br><span class="line"><span class="comment"> * or the like will implement &#123;<span class="doctag">@link</span> #postProcessBeforeInitialization&#125;,</span></span><br><span class="line"><span class="comment"> * while post-processors that wrap beans with proxies will normally</span></span><br><span class="line"><span class="comment"> * implement &#123;<span class="doctag">@link</span> #postProcessAfterInitialization&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由注释我们可以看到，我们可以通过<strong>BeanPostProcessor</strong>修改bean的实例，例如检查bean的接口或将将bean包装为代理对象。接口中提供了两个方法，通常情况下，<strong>postProcessBeforeInitialization</strong>被用于填充bean的属性，而<strong>postProcessAfterInitialization</strong>用于返回bean的代理对象，另外需要注意的是，如果该方法返回了null，则表示后续的BeanPostProcessors不会再被调用。</p>
<p>了解<strong>BeanPostProcessor</strong>，我们不禁猜测，@Autowire注解会不会也是由<strong>BeanPostProcessor</strong>解析和注入的呢，没错，它正是由<strong>BeanPostProcessor</strong>的实现类<strong>AutowiredAnnotationBeanPostProcessor</strong>处理的。</p>
<h2 id="理解AutowiredAnnotationBeanPostProcessor"><a href="#理解AutowiredAnnotationBeanPostProcessor" class="headerlink" title="理解AutowiredAnnotationBeanPostProcessor"></a>理解AutowiredAnnotationBeanPostProcessor</h2><p><img src="http://storage.laixiaoming.space/blog/AutowiredAnnotationBeanPostProcessor.jpg" alt="AutowiredAnnotationBeanPostProcessor"></p>
<p>但查看<strong>AutowiredAnnotationBeanPostProcessor</strong>的类继承关系图我们会发现，<strong>AutowiredAnnotationBeanPostProcessor</strong></p>
<p>并不是直接实现<strong>BeanPostProcessor</strong>，而是实现自<strong>BeanPostProcessor</strong>的子接口，<strong>MergedBeanDefinitionPostProcessor</strong>和<strong>SmartInstantiationAwareBeanPostProcessor</strong>。</p>
<p>回到<strong>AutowiredAnnotationBeanPostProcessor</strong>的源码，我们看到它主要有实现了几个关键的方法：determineCandidateConstructors、postProcessMergedBeanDefinition、postProcessProperties，我们逐个看。</p>
<h3 id="determineCandidateConstructors"><a href="#determineCandidateConstructors" class="headerlink" title="determineCandidateConstructors"></a>determineCandidateConstructors</h3><p>这个方法是<strong>SmartInstantiationAwareBeanPostProcessor</strong>接口中定义的，从方法注释我们可以知道，该方法用于确定给定bean的构造函数，这里我们不展开细说。</p>
<h3 id="postProcessMergedBeanDefinition"><a href="#postProcessMergedBeanDefinition" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h3><p>这个方法是<strong>MergedBeanDefinitionPostProcessor</strong>接口中定义的，查看其实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">    InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">    metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="findAutowiringMetadata"><a href="#findAutowiringMetadata" class="headerlink" title="findAutowiringMetadata"></a>findAutowiringMetadata</h4><p>该方法作用是构建Autowired的元数据，深入发现，其核心是调用了org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    List&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Class&lt;?&gt; targetClass = clazz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;InjectionMetadata.InjectedElement&gt; currElements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="comment">//解析类所有属性字段，将其封装为AutowiredFieldElement</span></span><br><span class="line">        ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">            <span class="comment">//解析该字段上的@Autowired注解，查看该方法可以发现，该处理器不仅解析了@Autowired注解，还有@Value及@Inject注解</span></span><br><span class="line">            AnnotationAttributes ann = findAutowiredAnnotation(field);</span><br><span class="line">            <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//忽略static字段</span></span><br><span class="line">                <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;Autowired annotation is not supported on static fields: &quot;</span> + field);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析类方法，将其封装为AutowiredMethodElement</span></span><br><span class="line">        ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">            Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">            <span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//解析该方法上的@Autowire注解</span></span><br><span class="line">            AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">            <span class="keyword">if</span> (ann != <span class="keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">                <span class="comment">//忽略静态方法</span></span><br><span class="line">                <span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;Autowired annotation is not supported on static methods: &quot;</span> + method);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//忽略无参方法</span></span><br><span class="line">                <span class="keyword">if</span> (method.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;Autowired annotation should only be used on methods with parameters: &quot;</span> +</span><br><span class="line">                                    method);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">                currElements.add(<span class="keyword">new</span> AutowiredMethodElement(method, required, pd));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">        targetClass = targetClass.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环解析父类</span></span><br><span class="line">    <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjectionMetadata(clazz, elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，buildAutowiringMetadata主要是收集被@Autowired修饰的字段以及方法。</p>
<h4 id="checkConfigMembers"><a href="#checkConfigMembers" class="headerlink" title="checkConfigMembers"></a>checkConfigMembers</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkConfigMembers</span><span class="params">(RootBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    Set&lt;InjectedElement&gt; checkedElements = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.injectedElements.size());</span><br><span class="line">    <span class="keyword">for</span> (InjectedElement element : <span class="keyword">this</span>.injectedElements) &#123;</span><br><span class="line">        Member member = element.getMember();</span><br><span class="line">        <span class="keyword">if</span> (!beanDefinition.isExternallyManagedConfigMember(member)) &#123;</span><br><span class="line">            beanDefinition.registerExternallyManagedConfigMember(member);</span><br><span class="line">            checkedElements.add(element);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Registered injected element on class [&quot;</span> + <span class="keyword">this</span>.targetClass.getName() + <span class="string">&quot;]: &quot;</span> + element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.checkedElements = checkedElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会缓存已经检验过的注入点，但是这个作用是什么，查看checkConfigMembers的调用位置，发现除了被 用于<strong>AutowiredAnnotationBeanPostProcessor</strong>这个处理器外，还在<strong>CommonAnnotationBeanPostProcessor</strong>中出现，而<strong>CommonAnnotationBeanPostProcessor</strong>是用于解析@Resource注解的，不难看出，这里主要是避免重复注入的问题。</p>
<h3 id="postProcessProperties"><a href="#postProcessProperties" class="headerlink" title="postProcessProperties"></a>postProcessProperties</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line"> 	<span class="comment">//省略...</span></span><br><span class="line">    <span class="comment">//注入</span></span><br><span class="line">    metadata.inject(bean, beanName, pvs);</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Collection&lt;InjectedElement&gt; checkedElements = <span class="keyword">this</span>.checkedElements;</span><br><span class="line">    Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line">        (checkedElements != <span class="keyword">null</span> ? checkedElements : <span class="keyword">this</span>.injectedElements);</span><br><span class="line">    <span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line">            element.inject(target, beanName, pvs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到了前面解析过程得到的@Autowired元数据后，进行值的注入，我们以字段的注入为例，查看其注入流程，来到AutowiredFieldElement#inject方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object bean, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Field field = (Field) <span class="keyword">this</span>.member;</span><br><span class="line">    Object value;</span><br><span class="line">    <span class="comment">//从缓存中读取值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cached) &#123;</span><br><span class="line">        value = resolvedCachedArgument(beanName, <span class="keyword">this</span>.cachedFieldValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        DependencyDescriptor desc = <span class="keyword">new</span> DependencyDescriptor(field, <span class="keyword">this</span>.required);</span><br><span class="line">        desc.setContainingClass(bean.getClass());</span><br><span class="line">        Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        Assert.state(beanFactory != <span class="keyword">null</span>, <span class="string">&quot;No BeanFactory available&quot;</span>);</span><br><span class="line">        TypeConverter typeConverter = beanFactory.getTypeConverter();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从beanFactory中解析依赖的bean</span></span><br><span class="line">            value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(<span class="keyword">null</span>, beanName, <span class="keyword">new</span> InjectionPoint(field), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.cached) &#123;</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span> || <span class="keyword">this</span>.required) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cachedFieldValue = desc;</span><br><span class="line">                    <span class="comment">//注册依赖关系</span></span><br><span class="line">                    registerDependentBeans(beanName, autowiredBeanNames);</span><br><span class="line">                    <span class="keyword">if</span> (autowiredBeanNames.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                        String autowiredBeanName = autowiredBeanNames.iterator().next();</span><br><span class="line">                        <span class="keyword">if</span> (beanFactory.containsBean(autowiredBeanName) &amp;&amp;</span><br><span class="line">                            beanFactory.isTypeMatch(autowiredBeanName, field.getType())) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.cachedFieldValue = <span class="keyword">new</span> ShortcutDependencyDescriptor(</span><br><span class="line">                                desc, autowiredBeanName, field.getType());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cachedFieldValue = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.cached = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//通过反射设置依赖值</span></span><br><span class="line">        ReflectionUtils.makeAccessible(field);</span><br><span class="line">        field.set(bean, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中关键是使用DefaultListableBeanFactory#resolveDependency解析依赖值，查看其实现，主要逻辑在DefaultListableBeanFactory#doResolveDependency：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object shortcut = descriptor.resolveShortcut(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (shortcut != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> shortcut;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理@Value注解，并获取对应值</span></span><br><span class="line">        Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">        Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String strVal = resolveEmbeddedValue((String) value);</span><br><span class="line">                BeanDefinition bd = (beanName != <span class="keyword">null</span> &amp;&amp; containsBean(beanName) ?</span><br><span class="line">                                     getMergedBeanDefinition(beanName) : <span class="keyword">null</span>);</span><br><span class="line">                value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">            &#125;</span><br><span class="line">            TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (UnsupportedOperationException ex) &#123;</span><br><span class="line">                <span class="comment">// A custom TypeConverter which does not support TypeDescriptor resolution...</span></span><br><span class="line">                <span class="keyword">return</span> (descriptor.getField() != <span class="keyword">null</span> ?</span><br><span class="line">                        converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">                        converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理集合bean的注入</span></span><br><span class="line">        Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">        <span class="keyword">if</span> (multipleBeans != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> multipleBeans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理单个bean的注入</span></span><br><span class="line">        Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">        <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String autowiredBeanName;</span><br><span class="line">        Object instanceCandidate;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果获取到的bean有多个，将根据@Primary及@Priority确定最优的一个</span></span><br><span class="line">        <span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line">                    <span class="comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line">                    <span class="comment">// (before 4.3 in particular when we didn&#x27;t even look for collection beans).</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We have exactly one match.</span></span><br><span class="line">            Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">            autowiredBeanName = entry.getKey();</span><br><span class="line">            instanceCandidate = entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (instanceCandidate <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            <span class="comment">//根据beanName，从beanFactory获取bean实例</span></span><br><span class="line">            instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = instanceCandidate;</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ClassUtils.isAssignableValue(type, result)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解了<strong>AutowiredAnnotationBeanPostProcessor</strong>的处理流程，那该处理器是在什么时候被调用的呢？</p>
<h3 id="AutowiredAnnotationBeanPostProcessor的调用时机"><a href="#AutowiredAnnotationBeanPostProcessor的调用时机" class="headerlink" title="AutowiredAnnotationBeanPostProcessor的调用时机"></a>AutowiredAnnotationBeanPostProcessor的调用时机</h3><p>查看其方法调用位置，不难看出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory#createBean</span><br><span class="line">	-&gt;AbstractAutowireCapableBeanFactory#doCreateBean</span><br><span class="line">        -&gt;AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors</span><br><span class="line">        	-&gt;MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition</span><br><span class="line">        -&gt;AbstractAutowireCapableBeanFactory#populateBean</span><br><span class="line">            -&gt;InstantiationAwareBeanPostProcessor#postProcessProperties</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>@Autowired、@Value等是由<strong>AutowiredAnnotationBeanPostProcessor</strong>处理的；</li>
<li><strong>AutowiredAnnotationBeanPostProcessor</strong>的postProcessMergedBeanDefinition方法用于解析构建@Autowired元数据，而postProcessProperties方法则用于@Autowired解析后值的注入；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：@Configuration类的解析</title>
    <url>/2023/05/04/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A@Configuration%E7%B1%BB%E7%9A%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用@Configuration注解可以为一个类声明为配置类，一个配置类声明了一个或多个@Bean方法，这些方法返回值将作为bean定义注册到Spring IoC容器中，并允许在配置类中通过调用同一类中的其他@Bean方法来定义bean之间的依赖关系。</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<h2 id="Configuration类解析流程"><a href="#Configuration类解析流程" class="headerlink" title="@Configuration类解析流程"></a>@Configuration类解析流程</h2><p>Spring Boot是如何解析@Configuration配置类的呢？要弄懂这个过程，首先我们需要先了解一个BeanFactoryPostProcessor的概念。</p>
<h3 id="BeanFactoryPostProcessor是什么"><a href="#BeanFactoryPostProcessor是什么" class="headerlink" title="BeanFactoryPostProcessor是什么"></a>BeanFactoryPostProcessor是什么</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Modify the application context&#x27;s internal bean factory after its standard</span></span><br><span class="line"><span class="comment">	 * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment">	 * will have been instantiated yet. This allows for overriding or adding</span></span><br><span class="line"><span class="comment">	 * properties even to eager-initializing beans.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>BeanFactoryPostProcessor是Spring 提供的一个接口，从代码注释中我们可以了解到，我们可以利用BeanFactoryPostProcessor实现对内部bean工厂进行修改，允许我们通过它完成bean定义或者属性的修改，另外需要注意的一点是，BeanFactoryPostProcessor的执行时机是在BeanFactory标准初始化后，并且是在Bean实例化之前。</p>
<p>而@Configuration配置类的解析正是由BeanFactoryPostProcessor的实现类<strong>ConfigurationClassPostProcessor</strong>处理的：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20220511233922833.png" alt="image-20220511233922833"></p>
<p>由ConfigurationClassPostProcessor的类继承关系图，我们可以发现ConfigurationClassPostProcessor并不直接实现BeanFactoryPostProcessor接口，而是实现了BeanFactoryPostProcessor的子接口BeanDefinitionRegistryPostProcessor，那么BeanDefinitionRegistryPostProcessor是什么呢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Modify the application context&#x27;s internal bean definition registry after its</span></span><br><span class="line"><span class="comment">	 * standard initialization. All regular bean definitions will have been loaded,</span></span><br><span class="line"><span class="comment">	 * but no beans will have been instantiated yet. This allows for adding further</span></span><br><span class="line"><span class="comment">	 * bean definitions before the next post-processing phase kicks in.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry the bean definition registry used by the application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor，它额外定义了一个方法，通过这个方法参数BeanDefinitionRegistry我们可以看出，它与BeanFactoryPostProcessor的区别在于，我们可以通过这个方法新增Bean定义，另外，它的执行时机是在BeanFactoryPostProcessor之前。</p>
<p>回到ConfigurationClassPostProcessor，这个BeanDefinitionRegistryPostProcessor的实现类到底做了哪些事情呢，我们一起来看下它的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConfigurationClassPostProcessor#processConfigBeanDefinitions：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充配置类的full或lite属性</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">        BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">            configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类解析器</span></span><br><span class="line">    ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">        <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//解析配置类（处理@ComponentScan，@Import，@Bean方法等注解），但这里实际上只会把@ComponentScan注解扫描的类注册为BeanDefinition</span></span><br><span class="line">        parser.parse(candidates);</span><br><span class="line">        parser.validate();</span><br><span class="line"></span><br><span class="line">        Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">        configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">                registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">                <span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里会解析上一步parse操作中获取到的ConfigurationClass，比如由@Import生成的配置类、或标注了@Bean注解的方法等注册为BeanDefinition</span></span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">        alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">        candidates.clear();</span><br><span class="line">        <span class="comment">//判断经过loadBeanDefinitions处理后，是否有新增配置类，有则继续解析</span></span><br><span class="line">        <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">            String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">            Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">            Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">                    BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">                    <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                        !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                        candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            candidateNames = newCandidateNames;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="full和lite的区别"><a href="#full和lite的区别" class="headerlink" title="full和lite的区别"></a>full和lite的区别</h3><p>ConfigurationClassUtils#checkConfigurationClassCandidate：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkConfigurationClassCandidate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    <span class="keyword">if</span> (isFullConfigurationCandidate(metadata)) &#123;</span><br><span class="line">        beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isLiteConfigurationCandidate(metadata)) &#123;</span><br><span class="line">        beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It&#x27;s a full or lite configuration candidate... Let&#x27;s determine the order value, if any.</span></span><br><span class="line">    Integer order = getOrder(metadata);</span><br><span class="line">    <span class="keyword">if</span> (order != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanDef.setAttribute(ORDER_ATTRIBUTE, order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConfigurationClassUtils#isFullConfigurationCandidate：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFullConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> metadata.isAnnotated(Configuration.class.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConfigurationClassUtils#isLiteConfigurationCandidate：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; candidateIndicators = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    candidateIndicators.add(Component.class.getName());</span><br><span class="line">    candidateIndicators.add(ComponentScan.class.getName());</span><br><span class="line">    candidateIndicators.add(Import.class.getName());</span><br><span class="line">    candidateIndicators.add(ImportResource.class.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLiteConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do not consider an interface or an annotation...</span></span><br><span class="line">    <span class="keyword">if</span> (metadata.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Any of the typical annotations found?</span></span><br><span class="line">    <span class="keyword">for</span> (String indicator : candidateIndicators) &#123;</span><br><span class="line">        <span class="keyword">if</span> (metadata.isAnnotated(indicator)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, let&#x27;s look for @Bean methods...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> metadata.hasAnnotatedMethods(Bean.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Failed to introspect @Bean methods on class [&quot;</span> + metadata.getClassName() + <span class="string">&quot;]: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以知道：</p>
<p><strong>full：</strong>@Configuration标注的类；</p>
<p><strong>lite：</strong>@Component、@ComponentScan、@Import、@ImportResource或者存在@Bean方法的类；</p>
<p>那么问题来了，区分full和lite有什么作用呢？</p>
<p>通过查找ConfigurationClassUtils#isFullConfigurationClass的调用位置，我们可以定位到ConfigurationClassPostProcessor#enhanceConfigurationClasses：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">			BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">            <span class="comment">//判断是否full配置类</span></span><br><span class="line">			<span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;</span><br><span class="line">				<span class="comment">//省略...</span></span><br><span class="line">				configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">		ConfigurationClassEnhancer enhancer = <span class="keyword">new</span> ConfigurationClassEnhancer();</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">			AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line">			<span class="comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">			beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">				Class&lt;?&gt; configClass = beanDef.resolveBeanClass(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">				<span class="keyword">if</span> (configClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//对full配置类进行增强</span></span><br><span class="line">					Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">					<span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">						<span class="comment">//省略...</span></span><br><span class="line">						beanDef.setBeanClass(enhancedClass);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="comment">//省略...</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Boot会对full配置类进行增强，那么为什么要对其进行增加呢？想必大家都看到过以下这种用法，这实际上就是为了支持@Bean方法能够在同一配置类相互调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B(a());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="parser-pase"><a href="#parser-pase" class="headerlink" title="parser.pase()"></a>parser.pase()</h3><p>通过查看其调用链路，定位到具体处理解析代码processConfigurationClass：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">ConfigurationClassParser#parse(java.util.Set&lt;org.springframework.beans.factory.config.BeanDefinitionHolder&gt;)</span><br><span class="line">-&gt;</span><br><span class="line">ConfigurationClassParse#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String)</span><br><span class="line">-&gt;</span><br><span class="line">ConfigurationClassParser#processConfigurationClass</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//省略...</span></span><br><span class="line">		<span class="comment">//递归处理配置类及其父类</span></span><br><span class="line">		SourceClass sourceClass = asSourceClass(configClass);</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>来到doProcessConfigurationClass：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">        <span class="comment">// 处理内部类，如果内部类也是一个配置类，将会递归去解析</span></span><br><span class="line">        processMemberClasses(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理@PropertySource注解</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">        org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">            processPropertySource(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//省略...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@ComponentScan注解，扫描指定包下的所有.class，这里也是一个递归解析的过程</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">        !<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">            <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                <span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">            <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                <span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bdCand = holder.getBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@Import注解</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@ImportResource注解</span></span><br><span class="line">    AnnotationAttributes importResource =</span><br><span class="line">        AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">    <span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">        Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">            String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">            configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@Bean方法</span></span><br><span class="line">    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">        configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理接口默认方法</span></span><br><span class="line">    processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取父类并返回，用以递归解析</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">        String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">            !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">            <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="this-reader-loadBeanDefinitions"><a href="#this-reader-loadBeanDefinitions" class="headerlink" title="this.reader.loadBeanDefinitions()"></a>this.reader.loadBeanDefinitions()</h3><p>定位到具体处理逻辑，ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForConfigurationClass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">        <span class="comment">//对于被导入的类，将其注册为BeanDefinition</span></span><br><span class="line">        registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">        <span class="comment">//将@Bean方法，注册为BeanDefinition</span></span><br><span class="line">        loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@ImportResource</span></span><br><span class="line">    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">    <span class="comment">//处理@Import注解中，导入的是ImportBeanDefinitionRegistrar接口实现类，调用其registerBeanDefinitions方法</span></span><br><span class="line">    loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>我们可以通过实现BeanFactoryPostProcessor对bean进行定义或修改，而Spring Boot是也是通过其实现类ConfigurationClassPostProcessor进行配置类的解析；</li>
<li>配置类分为full和lite，区别为前者会被增强处理；</li>
<li>我们常用的@ComponentScan包扫描，@Import注解，@Bean注解方法等也都是通过ConfigurationClassPostProcessor处理的；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：getBean方法解析</title>
    <url>/2023/05/30/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9AgetBean%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>getBean方法是BeanFactory定义的一系列方法，用于从Spring容器中获取bean实例。</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20220531064102379.png" alt="image-20220531064102379"></p>
<p>这些方法在AbstractBeanFactory均得到了具体实现，而这几个getBean方法最终都是调用了doGetBean方法，本文一起来看下</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<h2 id="doGetBean"><a href="#doGetBean" class="headerlink" title="doGetBean"></a>doGetBean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理别名，去除FactoryBean名称前缀&#x27;&amp;&#x27;</span></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果之前已经实例化好了，直接返回</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                             <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理FactoryBean的情况</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果该bean在当前线程下处于创建中状态，则认为其产生了循环依赖并抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果该bean在当前容器中不存在，则从其父容器获取</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                    nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理@DependsOn依赖，先实例化依赖的bean</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                        <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                        <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建单例bean</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                        <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//创建原型bean</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">finally</span> &#123;</span><br><span class="line">                            afterPrototypeCreation(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                                    <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                                                    <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                                                    ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查所需类型是否与bean实际类型一致，不一致则异常</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">            <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> convertedBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">                             ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取bean的时候，会尝试先从单例缓存中获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试从一级缓存获取</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">//一级缓存获取不到，并且当bean正在创建中时，尝试从二级缓存中获取</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">//二级缓存中获取不到时，尝试从三级缓存中获取，在三级缓存中存在时，将提前暴露AOP代理对象，并将其放于二级缓存</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面涉及到了三级缓存：</p>
<p><strong>singletonObjects：</strong>用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用；</p>
<p><strong>earlySingletonObjects：</strong>二级缓存，提前暴露出的代理对象，未填充属性及初始化的单例对象；</p>
<p><strong>singletonFactories：</strong>三级缓存，存放单例对象工厂，用于提前暴露bean的代理对象；</p>
<p>如果从缓存获取不到，bean的创建会根据bean的作用域进行创建，这里以单例bean的创建为例。</p>
<h3 id="getSingleton"><a href="#getSingleton" class="headerlink" title="getSingleton"></a>getSingleton</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">//尝试从缓存中获取单例bean</span></span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">                                                          <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">                                                          <span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将当前bean标记为正在创建中</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">                <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">                singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">                        ex.addRelatedCause(suppressedException);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">//将创建好的bean放入单例缓存中</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从getSingleton方法中可以看出，它与原型bean的创建的主要区别在于，单例bean的创建多了一层缓存，用于复用已经创建好的bean，而两者最终都是调用了AbstractAutowireCapableBeanFactory#createBean进行bean的创建。</p>
<h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取bean的类型</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  lookup method和replace method的校验和准备工作</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                                               beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//提交创建代理对象并返回，不走后续创建bean的流程，深入查看可以发现，</span></span><br><span class="line">        <span class="comment">//里面会寻找InstantiationAwareBeanPostProcessor处理器，并调用postProcessBeforeInstantiation方法</span></span><br><span class="line">        <span class="comment">//查找InstantiationAwareBeanPostProcessor实现类，会发现只有AbstractAutoProxyCreator这个类中有具体实现</span></span><br><span class="line">        <span class="comment">//并且在实现中，只有存在自定义targetsource的情况下，该方法才有可能返回非空</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                                        <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里开始bean的创建</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">        <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="doCreateBean"><a href="#doCreateBean" class="headerlink" title="doCreateBean"></a>doCreateBean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化bean，将bean封装为BeanWrapper</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition处理器调用</span></span><br><span class="line">    <span class="comment">// 我们前面讲到的@Autowired正是在这里，由AutowiredAnnotationBeanPostProcessor解析的</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在允许循环依赖（单例&amp;&amp;允许循环依赖&amp;&amp;当前bean正在创建中）的前提下，</span></span><br><span class="line">    <span class="comment">//将bean工厂（用于提前暴露AOP代理对象）放于三级缓存</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                         <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getEarlyBeanReference方法里会寻找SmartInstantiationAwareBeanPostProcessor处理器，</span></span><br><span class="line">        <span class="comment">//并调用其getEarlyBeanReference方法提前返回代理对象</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bean的初始化</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//bean属性的填充，InstantiationAwareBeanPostProcessor#postProcessProperties的调用</span></span><br><span class="line">        <span class="comment">//我们前面讲到的@Autowired是在这里进行真正的注入操作</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">//初始化bean对象</span></span><br><span class="line">        <span class="comment">//Aware方法</span></span><br><span class="line">        <span class="comment">//BeanPostProcessor#postProcessBeforeInitialization</span></span><br><span class="line">        <span class="comment">//InitializingBean#afterPropertiesSet，init-method方法</span></span><br><span class="line">        <span class="comment">//BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line">        <span class="comment">//将在这里被依次调用</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//尝试从二级缓存中重新获取一遍，将提前暴露的aop代理对象（如果有的话）替换原bean实例并返回</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                                                               <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                                                               StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                                               <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，doCreateBean做的事情：</p>
<ol>
<li>createBeanInstance：bean的实例化；</li>
<li>addSingletonFactory：将bean放入三级缓存；</li>
<li>populateBean：依赖注入；</li>
<li>initializeBean：bean后置处理器的调用，bean的初始化等；</li>
</ol>
<p>这里有一个细节点，那就是三级缓存的放入是在bean的实例化之后的，而三级缓存是用于解决循环依赖的，这也是为什么当构造函数注入存在循环依赖时而无法解决的原因。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后以A实例及B实例循环场景为例，bean的创建流程如下：</p>
<p><img src="http://storage.laixiaoming.space/blog/circular_dependency.jpg" alt="circular_dependency"></p>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：事务生效原理</title>
    <url>/2024/04/13/Spring%20Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E4%BA%8B%E5%8A%A1%E7%94%9F%E6%95%88%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们都知道，在使用Spring进行项目开发时，开启事务只需要在类或者上标注一个**@Transactional**注解即可实现，那么这个是怎么做到的呢？</p>
<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<p>探究其实现原理之前，我们先来看一个**@EnableTransactionManagement**注解。</p>
<span id="more"></span>

<h3 id="从-EnableTransactionManagement说起"><a href="#从-EnableTransactionManagement说起" class="headerlink" title="从@EnableTransactionManagement说起"></a>从@EnableTransactionManagement说起</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(TransactionManagementConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，该注解导入了<strong>TransactionManagementConfigurationSelector</strong>类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TransactionManagementConfigurationSelector extends AdviceModeImportSelector&lt;EnableTransactionManagement&gt; &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">		switch (adviceMode) &#123;</span><br><span class="line">			case PROXY:</span><br><span class="line">				return new String[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">						ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">			case ASPECTJ:</span><br><span class="line">				return new String[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line">			default:</span><br><span class="line">				return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在默认的PROXY模式下，<strong>TransactionManagementConfigurationSelector</strong>类注册了<strong>AutoProxyRegistrar</strong>和<strong>ProxyTransactionManagementConfiguration</strong>类：</p>
<h4 id="AutoProxyRegistrar"><a href="#AutoProxyRegistrar" class="headerlink" title="AutoProxyRegistrar"></a>AutoProxyRegistrar</h4><p>通过深入<strong>AutoProxyRegistrar</strong>可以看到，该类最终又调用了<strong>AopConfigUtils#registerAutoProxyCreatorIfNecessary</strong>注册了<strong>InfrastructureAdvisorAutoProxyCreator</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AopConfigUtils &#123;</span><br><span class="line">	private static final List&lt;Class&lt;?&gt;&gt; APC_PRIORITY_LIST &#x3D; new ArrayList&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">	static &#123;</span><br><span class="line">		&#x2F;&#x2F; Set up the escalation list...</span><br><span class="line">		APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);</span><br><span class="line">		APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class);</span><br><span class="line">		APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">	@Nullable</span><br><span class="line">	public static BeanDefinition registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		return registerAutoProxyCreatorIfNecessary(registry, null);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static BeanDefinition registerAutoProxyCreatorIfNecessary(</span><br><span class="line">			BeanDefinitionRegistry registry, @Nullable Object source) &#123;</span><br><span class="line"></span><br><span class="line">		return registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Nullable</span><br><span class="line">	private static BeanDefinition registerOrEscalateApcAsRequired(</span><br><span class="line">			Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source) &#123;</span><br><span class="line"></span><br><span class="line">		Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;如果该bean已存在，将根据APC_PRIORITY_LIST中定义的优先级进行加载&#x2F;替换</span><br><span class="line">		if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">			BeanDefinition apcDefinition &#x3D; registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">			if (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">				int currentPriority &#x3D; findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">				int requiredPriority &#x3D; findPriorityForClass(cls);</span><br><span class="line">				if (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">					apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		RootBeanDefinition beanDefinition &#x3D; new RootBeanDefinition(cls);</span><br><span class="line">		beanDefinition.setSource(source);</span><br><span class="line">		beanDefinition.getPropertyValues().add(&quot;order&quot;, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">		beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">		registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">		return beanDefinition;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，<strong>InfrastructureAdvisorAutoProxyCreator</strong>有什么作用呢</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Auto-proxy creator that considers infrastructure Advisor beans only,</span><br><span class="line"> * ignoring any application-defined Advisors.</span><br><span class="line"> *</span><br><span class="line"> * @author Juergen Hoeller</span><br><span class="line"> * @since 2.0.7</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SuppressWarnings(&quot;serial&quot;)</span><br><span class="line">public class InfrastructureAdvisorAutoProxyCreator extends AbstractAdvisorAutoProxyCreator &#123;</span><br><span class="line"></span><br><span class="line">	@Nullable</span><br><span class="line">	private ConfigurableListableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected void initBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">		super.initBeanFactory(beanFactory);</span><br><span class="line">		this.beanFactory &#x3D; beanFactory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected boolean isEligibleAdvisorBean(String beanName) &#123;</span><br><span class="line">		return (this.beanFactory !&#x3D; null &amp;&amp; this.beanFactory.containsBeanDefinition(beanName) &amp;&amp;</span><br><span class="line">				this.beanFactory.getBeanDefinition(beanName).getRole() &#x3D;&#x3D; BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码注释中可以看出，这是一个代理对象创建器。</p>
<p>了解过**@EnableAspectJAutoProxy<strong>注解原理的可能会发现，这俩走的是同一个注册方法，而对于同时开启</strong>EnableAspectJAutoProxy<strong>和</strong>EnableTransactionManagement<strong>的情况下，在注册的时候会根据定义的优先级</strong>AnnotationAwareAspectJAutoProxyCreator &gt; AspectJAwareAdvisorAutoProxyCreator &gt; InfrastructureAdvisorAutoProxyCreator<strong>，保留其中一个，通过对比其实现可以知道，</strong>AnnotationAwareAspectJAutoProxyCreator**具有的功能更全面。</p>
<h4 id="ProxyTransactionManagementConfiguration"><a href="#ProxyTransactionManagementConfiguration" class="headerlink" title="ProxyTransactionManagementConfiguration"></a>ProxyTransactionManagementConfiguration</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ProxyTransactionManagementConfiguration extends AbstractTransactionManagementConfiguration &#123;</span><br><span class="line"></span><br><span class="line">	@Bean(name &#x3D; TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span><br><span class="line">	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">	public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor() &#123;</span><br><span class="line">		BeanFactoryTransactionAttributeSourceAdvisor advisor &#x3D; new BeanFactoryTransactionAttributeSourceAdvisor();</span><br><span class="line">		advisor.setTransactionAttributeSource(transactionAttributeSource());</span><br><span class="line">		advisor.setAdvice(transactionInterceptor());</span><br><span class="line">		if (this.enableTx !&#x3D; null) &#123;</span><br><span class="line">			advisor.setOrder(this.enableTx.&lt;Integer&gt;getNumber(&quot;order&quot;));</span><br><span class="line">		&#125;</span><br><span class="line">		return advisor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">	public TransactionAttributeSource transactionAttributeSource() &#123;</span><br><span class="line">		return new AnnotationTransactionAttributeSource();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">	public TransactionInterceptor transactionInterceptor() &#123;</span><br><span class="line">		TransactionInterceptor interceptor &#x3D; new TransactionInterceptor();</span><br><span class="line">		interceptor.setTransactionAttributeSource(transactionAttributeSource());</span><br><span class="line">		if (this.txManager !&#x3D; null) &#123;</span><br><span class="line">			interceptor.setTransactionManager(this.txManager);</span><br><span class="line">		&#125;</span><br><span class="line">		return interceptor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ProxyTransactionManagementConfiguration</strong>注册了3个bean。</p>
<h5 id="transactionAdvisor"><a href="#transactionAdvisor" class="headerlink" title="transactionAdvisor"></a>transactionAdvisor</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BeanFactoryTransactionAttributeSourceAdvisor extends AbstractBeanFactoryPointcutAdvisor &#123;</span><br><span class="line"></span><br><span class="line">	@Nullable</span><br><span class="line">	private TransactionAttributeSource transactionAttributeSource;</span><br><span class="line"></span><br><span class="line">	private final TransactionAttributeSourcePointcut pointcut &#x3D; new TransactionAttributeSourcePointcut() &#123;</span><br><span class="line">		@Override</span><br><span class="line">		@Nullable</span><br><span class="line">		protected TransactionAttributeSource getTransactionAttributeSource() &#123;</span><br><span class="line">			return transactionAttributeSource;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Set the transaction attribute source which is used to find transaction</span><br><span class="line">	 * attributes. This should usually be identical to the source reference</span><br><span class="line">	 * set on the transaction interceptor itself.</span><br><span class="line">	 * @see TransactionInterceptor#setTransactionAttributeSource</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void setTransactionAttributeSource(TransactionAttributeSource transactionAttributeSource) &#123;</span><br><span class="line">		this.transactionAttributeSource &#x3D; transactionAttributeSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Set the &#123;@link ClassFilter&#125; to use for this pointcut.</span><br><span class="line">	 * Default is &#123;@link ClassFilter#TRUE&#125;.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void setClassFilter(ClassFilter classFilter) &#123;</span><br><span class="line">		this.pointcut.setClassFilter(classFilter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Pointcut getPointcut() &#123;</span><br><span class="line">		return this.pointcut;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAttributeSourcePointcut</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcut</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (TransactionalProxy.class.isAssignableFrom(targetClass) ||</span><br><span class="line">				PlatformTransactionManager.class.isAssignableFrom(targetClass) ||</span><br><span class="line">				PersistenceExceptionTranslator.class.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">		<span class="keyword">return</span> (tas == <span class="keyword">null</span> || tas.getTransactionAttribute(method, targetClass) != <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<strong>BeanFactoryTransactionAttributeSourceAdvisor</strong>的类继承关系图可以看出，它是一个事务增强器，并且其切入点实现依赖于<strong>TransactionAttributeSource</strong>，在这里的具体实现是<strong>AnnotationTransactionAttributeSource</strong>，其关键的方法是<strong>TransactionAttributeSource#getTransactionAttribute</strong>。</p>
<h5 id="AnnotationTransactionAttributeSource"><a href="#AnnotationTransactionAttributeSource" class="headerlink" title="AnnotationTransactionAttributeSource"></a>AnnotationTransactionAttributeSource</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">This class reads Spring&#39;s JDK 1.5+ Transactional annotation and exposes corresponding transaction attributes to Spring&#39;s transaction infrastructure. Also supports JTA 1.2&#39;s javax.transaction.Transactional and EJB3&#39;s javax.ejb.TransactionAttribute annotation (if present). This class may also serve as base class for a custom TransactionAttributeSource, or get customized through TransactionAnnotationParser strategies.</span><br><span class="line">**&#x2F;</span><br><span class="line">public class AnnotationTransactionAttributeSource extends AbstractFallbackTransactionAttributeSource</span><br><span class="line">		implements Serializable &#123;</span><br><span class="line">		&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从该类的注释可以看出，该类主要用于解析**@Transactional<strong>注解，并将其属性提供给事务框架使用，而从其构造函数可以知道，它使用了</strong>SpringTransactionAnnotationParser**作为事务属性配置的解析器。</p>
<h5 id="transactionInterceptor"><a href="#transactionInterceptor" class="headerlink" title="transactionInterceptor"></a>transactionInterceptor</h5><p><img src="http://storage.laixiaoming.space/blog/image-20240413174621857.png" alt="image-20240413174621857"></p>
<p>从该类的继承关系图可以看出，<strong>TransactionInterceptor</strong>实现了<strong>MethodInterceptor</strong>，是一个方法拦截器，不验证猜出事务是行为是在这个类中实现的，接下来我们具体看下<strong>TransactionInterceptor</strong> 到底做了什么。</p>
<h3 id="TransactionInterceptor工作原理"><a href="#TransactionInterceptor工作原理" class="headerlink" title="TransactionInterceptor工作原理"></a>TransactionInterceptor工作原理</h3><p><strong>invoke</strong>是<strong>MethodInterceptor</strong>的核心方法，其主要逻辑在<strong>invokeWithinTransaction</strong>体现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="comment">// Work out the target class: may be &#123;@code null&#125;.</span></span><br><span class="line">	<span class="comment">// The TransactionAttributeSource should be passed the target class</span></span><br><span class="line">	<span class="comment">// as well as the method, which may be from an interface.</span></span><br><span class="line">	Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...</span></span><br><span class="line">	<span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="invokeWithinTransaction事务整体流程"><a href="#invokeWithinTransaction事务整体流程" class="headerlink" title="invokeWithinTransaction事务整体流程"></a>invokeWithinTransaction事务整体流程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,</span><br><span class="line">		final InvocationCallback invocation) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; If the transaction attribute is null, the method is non-transactional.</span><br><span class="line">	TransactionAttributeSource tas &#x3D; getTransactionAttributeSource();</span><br><span class="line">	&#x2F;&#x2F;获取@Transaction属性配置</span><br><span class="line">	final TransactionAttribute txAttr &#x3D; (tas !&#x3D; null ? tas.getTransactionAttribute(method, targetClass) : null);</span><br><span class="line">	&#x2F;&#x2F;获取事务管理器</span><br><span class="line">	final PlatformTransactionManager tm &#x3D; determineTransactionManager(txAttr);</span><br><span class="line">	final String joinpointIdentification &#x3D; methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">	if (txAttr &#x3D;&#x3D; null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">		&#x2F;&#x2F; Standard transaction demarcation with getTransaction and commit&#x2F;rollback calls.</span><br><span class="line">		&#x2F;&#x2F;创建事务</span><br><span class="line">		TransactionInfo txInfo &#x3D; createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">		Object retVal;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; This is an around advice: Invoke the next interceptor in the chain.</span><br><span class="line">			&#x2F;&#x2F; This will normally result in a target object being invoked.</span><br><span class="line">			retVal &#x3D; invocation.proceedWithInvocation();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			&#x2F;&#x2F; target invocation exception</span><br><span class="line">			&#x2F;&#x2F;回滚事务</span><br><span class="line">			completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			cleanupTransactionInfo(txInfo);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;提交事务</span><br><span class="line">		commitTransactionAfterReturning(txInfo);</span><br><span class="line">		return retVal;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F;...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出，这里使用的是环绕通知处理器，体现了事务创建-提交-回滚的整个轮廓。</p>
<h4 id="createTransactionIfNecessary创建事务"><a href="#createTransactionIfNecessary创建事务" class="headerlink" title="createTransactionIfNecessary创建事务"></a>createTransactionIfNecessary创建事务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="meta">@Nullable</span> TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If no name specified, apply method identification as transaction name.</span></span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">		txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//获取事务状态</span></span><br><span class="line">			status = tm.getTransaction(txAttr);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Skipping transactional joinpoint [&quot;</span> + joinpointIdentification +</span><br><span class="line">						<span class="string">&quot;] because no transaction manager has been configured&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="事务的传播机制"><a href="#事务的传播机制" class="headerlink" title="事务的传播机制"></a>事务的传播机制</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">	Object transaction = doGetTransaction();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cache debug flag to avoid repeated checks.</span></span><br><span class="line">	<span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (definition == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">		definition = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//是否存在当前事务</span></span><br><span class="line">	<span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">		<span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line">		<span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check definition settings for new transaction.</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">&quot;Invalid transaction timeout&quot;</span>, definition.getTimeout());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当前事务不存在，则根据事务传播行为做不同处理</span></span><br><span class="line">	<span class="comment">// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">				<span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">			definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">			definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">		<span class="comment">//挂起当前事务，当前事务为不存在，不需要挂起</span></span><br><span class="line">		SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + definition.getName() + <span class="string">&quot;]: &quot;</span> + definition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">			DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">					definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">			doBegin(transaction, definition);</span><br><span class="line">			prepareSynchronization(status, definition);</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">			resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line">		<span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">			logger.warn(<span class="string">&quot;Custom isolation level specified but no actual transaction initiated; &quot;</span> +</span><br><span class="line">					<span class="string">&quot;isolation level will effectively be ignored: &quot;</span> + definition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">		<span class="keyword">return</span> prepareTransactionStatus(definition, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从getTransaction代码处理上看，在不存在当前事务的情况下，事务传播行为：</p>
<ol>
<li>是<strong>MANDATORY</strong>类型时，则直接抛出异常，因为此时还没有事务</li>
<li>是<strong>REQUIRED</strong>、<strong>REQUIRES_NEW</strong>、<strong>NESTED</strong>类型时，则创建一个新的事务</li>
<li>其余情况，返回空事务</li>
</ol>
<p>而在存在当前事务的情况下，<strong>handleExistingTransaction</strong>方法将被执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">handleExistingTransaction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		TransactionDefinition definition, Object transaction, <span class="keyword">boolean</span> debugEnabled)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">	<span class="comment">//传播行为是NEVER，则不允许执行</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">				<span class="string">&quot;Existing transaction found for transaction marked with propagation &#x27;never&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//传播行为是NOT_SUPPORTED，挂起当前事务</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line">		<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Suspending current transaction&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Object suspendedResources = suspend(transaction);</span><br><span class="line">		<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">		<span class="keyword">return</span> prepareTransactionStatus(</span><br><span class="line">				definition, <span class="keyword">null</span>, <span class="keyword">false</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//传播行为是REQUIRED_NEW，挂起当前事务，并新建一个事务</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line">		<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Suspending current transaction, creating new transaction with name [&quot;</span> +</span><br><span class="line">					definition.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		SuspendedResourcesHolder suspendedResources = suspend(transaction);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">			DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">					definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">			doBegin(transaction, definition);</span><br><span class="line">			prepareSynchronization(status, definition);</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error beginEx) &#123;</span><br><span class="line">			resumeAfterBeginException(transaction, suspendedResources, beginEx);</span><br><span class="line">			<span class="keyword">throw</span> beginEx;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//传播行为是NESTED，创建一个保存点</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isNestedTransactionAllowed()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NestedTransactionNotSupportedException(</span><br><span class="line">					<span class="string">&quot;Transaction manager does not allow nested transactions by default - &quot;</span> +</span><br><span class="line">					<span class="string">&quot;specify &#x27;nestedTransactionAllowed&#x27; property with value &#x27;true&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Creating nested transaction with name [&quot;</span> + definition.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (useSavepointForNestedTransaction()) &#123;</span><br><span class="line">			<span class="comment">// Create savepoint within existing Spring-managed transaction,</span></span><br><span class="line">			<span class="comment">// through the SavepointManager API implemented by TransactionStatus.</span></span><br><span class="line">			<span class="comment">// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.</span></span><br><span class="line">			DefaultTransactionStatus status =</span><br><span class="line">					prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, <span class="keyword">false</span>, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">			status.createAndHoldSavepoint();</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Nested transaction through nested begin and commit/rollback calls.</span></span><br><span class="line">			<span class="comment">// Usually only for JTA: Spring synchronization might get activated here</span></span><br><span class="line">			<span class="comment">// in case of a pre-existing JTA transaction.</span></span><br><span class="line">			<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">			DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">					definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">			doBegin(transaction, definition);</span><br><span class="line">			prepareSynchronization(status, definition);</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.</span></span><br><span class="line">	<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Participating in existing transaction&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (isValidateExistingTransaction()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123;</span><br><span class="line">			Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">			<span class="keyword">if</span> (currentIsolationLevel == <span class="keyword">null</span> || currentIsolationLevel != definition.getIsolationLevel()) &#123;</span><br><span class="line">				Constants isoConstants = DefaultTransactionDefinition.constants;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(<span class="string">&quot;Participating transaction with definition [&quot;</span> +</span><br><span class="line">						definition + <span class="string">&quot;] specifies isolation level which is incompatible with existing transaction: &quot;</span> +</span><br><span class="line">						(currentIsolationLevel != <span class="keyword">null</span> ?</span><br><span class="line">								isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :</span><br><span class="line">								<span class="string">&quot;(unknown)&quot;</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!definition.isReadOnly()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(<span class="string">&quot;Participating transaction with definition [&quot;</span> +</span><br><span class="line">						definition + <span class="string">&quot;] is not marked as read-only but existing transaction is&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">	<span class="keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="事务的挂起和恢复"><a href="#事务的挂起和恢复" class="headerlink" title="事务的挂起和恢复"></a>事务的挂起和恢复</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SuspendedResourcesHolder <span class="title">suspend</span><span class="params">(<span class="meta">@Nullable</span> Object transaction)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">		<span class="comment">//记录当前的事务同步管理器信息</span></span><br><span class="line">		List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Object suspendedResources = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">//挂起当前事务</span></span><br><span class="line">				suspendedResources = doSuspend(transaction);</span><br><span class="line">			&#125;</span><br><span class="line">			String name = TransactionSynchronizationManager.getCurrentTransactionName();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionName(<span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">boolean</span> readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionReadOnly(<span class="keyword">false</span>);</span><br><span class="line">			Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(<span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">boolean</span> wasActive = TransactionSynchronizationManager.isActualTransactionActive();</span><br><span class="line">			TransactionSynchronizationManager.setActualTransactionActive(<span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> SuspendedResourcesHolder(</span><br><span class="line">					suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">			<span class="comment">// doSuspend failed - original transaction is still active...</span></span><br><span class="line">			doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Transaction active but no synchronization active.</span></span><br><span class="line">		Object suspendedResources = doSuspend(transaction);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SuspendedResourcesHolder(suspendedResources);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Neither transaction nor synchronization active.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doSuspend</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">	DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">	txObject.setConnectionHolder(<span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">return</span> TransactionSynchronizationManager.unbindResource(obtainDataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">unbindResource</span><span class="params">(Object key)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">	Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);</span><br><span class="line">	Object value = doUnbindResource(actualKey);</span><br><span class="line">	<span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">&quot;No value for key [&quot;</span> + actualKey + <span class="string">&quot;] bound to thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">doUnbindResource</span><span class="params">(Object actualKey)</span> </span>&#123;</span><br><span class="line">	Map&lt;Object, Object&gt; map = resources.get();</span><br><span class="line">	<span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Object value = map.remove(actualKey);</span><br><span class="line">	<span class="comment">// Remove entire ThreadLocal if empty...</span></span><br><span class="line">	<span class="keyword">if</span> (map.isEmpty()) &#123;</span><br><span class="line">		resources.remove();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Transparently suppress a ResourceHolder that was marked as void...</span></span><br><span class="line">	<span class="keyword">if</span> (value <span class="keyword">instanceof</span> ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123;</span><br><span class="line">		value = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Removed value [&quot;</span> + value + <span class="string">&quot;] for key [&quot;</span> + actualKey + <span class="string">&quot;] from thread [&quot;</span> +</span><br><span class="line">				Thread.currentThread().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，事务的挂起实际是对当前事务的状态信息和数据源连接对象封装到<strong>SuspendedResourcesHolder</strong>对象中，并将线程本地变量保存的事务状态清除。</p>
<p>那什么时候进行恢复呢？通过查看代码可以发现，在事务提交或者回滚后，org.springframework.transaction.support.AbstractPlatformTransactionManager#cleanupAfterCompletion，会进行挂起事务的恢复：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanupAfterCompletion</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">	status.setCompleted();</span><br><span class="line">	<span class="keyword">if</span> (status.isNewSynchronization()) &#123;</span><br><span class="line">		TransactionSynchronizationManager.clear();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">		doCleanupAfterCompletion(status.getTransaction());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (status.getSuspendedResources() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Resuming suspended transaction after completion of inner transaction&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Object transaction = (status.hasTransaction() ? status.getTransaction() : <span class="keyword">null</span>);</span><br><span class="line">		resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">(<span class="meta">@Nullable</span> Object transaction, <span class="meta">@Nullable</span> SuspendedResourcesHolder resourcesHolder)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (resourcesHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Object suspendedResources = resourcesHolder.suspendedResources;</span><br><span class="line">		<span class="keyword">if</span> (suspendedResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">			doResume(transaction, suspendedResources);</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;TransactionSynchronization&gt; suspendedSynchronizations = resourcesHolder.suspendedSynchronizations;</span><br><span class="line">		<span class="keyword">if</span> (suspendedSynchronizations != <span class="keyword">null</span>) &#123;</span><br><span class="line">			TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive);</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel);</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly);</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name);</span><br><span class="line">			doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>Spring事务也是通过AOP实现，相关逻辑由<strong>BeanFactoryTransactionAttributeSourceAdvisor</strong>、<strong>TransactionAttributeSource</strong>、<strong>TransactionInterceptor</strong>实现；</li>
<li>事务的挂起与恢复，实际是通过线程本地变量对当前事务信息的保存、清除和恢复；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>日志：每个软件工程师都应该知道的实时数据的统一抽象</title>
    <url>/2024/04/23/%E6%97%A5%E5%BF%97%EF%BC%9A%E6%AF%8F%E4%B8%AA%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%83%BD%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E4%B8%80%E6%8A%BD%E8%B1%A1/</url>
    <content><![CDATA[<blockquote>
<p>原文：<a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying">The Log: What every software engineer should know about real-time data’s unifying abstraction</a></p>
<p>作者：<strong>Jay Kreps</strong></p>
</blockquote>
<p>我大约在六年前加入了领英，那是一个特别有趣的时间点。那时我们正面临着单体集中式数据库极限的挑战，需要开始向专门的分布式系统转变。这真是一个有趣的经历：我们构建、部署和运行了分布式图数据库、分布式搜索后端、Hadoop套件、一代及二代键值数据库，并运行至今。</p>
<p>在这个过程中，我学到的最有用的一件事情是，我们在这里构建的大多数组件，其核心都有一个简单的概念：日志，有时也被称作先写日志、提交日志或者事务日志，日志几乎与计算机的历史一样悠久，它是许多分布式数据系统和实时应用架构里面的核心。</p>
<p>如果你不了解日志，你也就不可能完全了解数据库、NoSQL存储、键值存储、副本、paxos、hadoop、版本控制、甚至几乎任何软件系统，然而大多数软件工程师都不熟悉它，我希望改变这个现状。在这篇文章中，我将告诉你一切你需要知道的关于日志的事情，包括什么是日志、如何在数据集成、实时处理和系统构建中使用日志。</p>
<span id="more"></span>

<h3 id="第一部分：什么是日志"><a href="#第一部分：什么是日志" class="headerlink" title="第一部分：什么是日志"></a>第一部分：什么是日志</h3><p>日志可能是最简单的存储抽象，它是一个只能追加、按时间排序的完全有序的序列。</p>
<p><img src="http://storage.laixiaoming.space/blog/log.png" alt="img"></p>
<p>记录被追加到到日志的末尾，读取时从左到右进行。每条记录都按序分配了一个唯一数字。</p>
<p>记录的顺序包含了时间的概念，因为左边的条目在时间上是比右边的条目更加早的。日志记录的数字可以认为是这条记录的时间戳。将这种顺序描述为时间的概念，乍一看可能会有点奇怪，但有一个好处是，它可以从任何特定的物理时钟中脱离出来，这个好处在我们谈到分布式系统时显得更加至关重要。</p>
<p>记录的内容和形式不在这次讨论的重点。当然，我们不能一直往日志中追加记录，因为磁盘的空间是有限的，这一点稍后会谈到。</p>
<p>日志并不安全不同于文件或者数据库表。一个文件是一个字节数组，数据库表是一系列的记录，日志也是一种表或者文件，但它是时间上有序的。</p>
<p>你可能会有疑问，这么简单的东西，为什么会值得讨论？只能追加的记录序列和数据系统有什么关系？答案是，日志有一个很关键的点，它记录了发生了什么事情以及是什么时候发生的，在多数情况下，这点对于分布式系统而言，是问题的关键。</p>
<p>在我们深入之前，先让我说明一件可能让人有疑惑的事情。每个工程师都很熟悉另一种日志的定义，那就是一个应用通过syslog或者log4j向本地文件写入的非结构化的错误信息或者跟踪信息，为了避免歧义，我称这个为“应用日志”。相对于我在本文描述的日志，应用日志具有另一种形式。这两种日志最大的不同之处在于，应用日志主要是用于人进行阅读，而我所描述的日志或数据日志被用于程序化访问。</p>
<p>（事实上，如果你稍微思考下，就会发现，人在单台机器上阅读日志的想法有些不合时宜。当涉及到许多服务和服务器时，这种方法很快就变得一种难于管理。日志的目的很快就变成了查询和图表的输入，以理解机器的行为，因此用英文书写在文件的日志并不如在本文中描述的结构化日志合适。）</p>
<h4 id="数据库中的日志"><a href="#数据库中的日志" class="headerlink" title="数据库中的日志"></a>数据库中的日志</h4><p>我不知道日志的概念起源于哪里，或许是因为它太过简单以至于发明者不认为它是一种发明，就像十分查找算法。它早在IBM的Sytem R时就出现了。日志在数据库的使用是在崩溃的时候，必须保持数据结构和索引的同步。为了保证原子性、持久性，数据库系统在对它维护的所有数据结构应用修改之前，会通过日志写入将要修改的记录的信息。日志是对发生的事情的记录，每个数据库表或索引都是对有用的数据结构或索引的历史数据的投影。由于日志是即时持久化的，它也作为一种可靠数据来源，用于在崩溃时恢复其他持久化结构的。</p>
<p>随着时间的推进，日志的用法也从用于ACID的实现细节，演变为在数据库之前同步数据的一种方式。发生在主数据库上的变更序列也需要被应用于远程的从库上，以保持同步。Oracle、MySQL、PostgreSQL都包含了传输协议，将部分日志传输到扮演从库角色的副本数据库。Oracle还将日志产品化为一种通用通用的数据订阅机制，非Oracle数据订阅者可以使用它们的XStreams和GoldenGate进行订阅使用。在MySQL和PostgreSQL上，相似的组件也作为许多数据库构中的关键组件存在。</p>
<p>由于这个原因，机器可读的日志的概念也被局限于数据库的内部。日志作为数据订阅机制的使用似乎是偶然出现的。但这种抽象非常适用于消息、数据流和实时数据处理的所有类型。</p>
<h4 id="分布式系统中的日志"><a href="#分布式系统中的日志" class="headerlink" title="分布式系统中的日志"></a>分布式系统中的日志</h4><p>在分布式系统中，变更的序列和数据的分发是日志解决的两个尤为重要的问题。就更新的顺序达成一致（或达成不一致、应对副作用），是分布式系统设计的核心问题。</p>
<p>以日志为中心的分布式系统方法源于一个简单的观察，我称它为“状态机复制原理”：</p>
<blockquote>
<p>如果两个相同的、确定性的进程的起始状态是相同的，并且以同样的顺序获取了相同的输入，那么这两个进程将产生同样的输出，最终也拥有相同的状态。</p>
</blockquote>
<p>这听起来有点晦涩，让我们深入了解它的含义。</p>
<p>确定性意味着这个进程是不依赖于时钟的，也不会有其他“带外数据”影响它的输出。如果一个程序的输出受线程执行的特定顺序影响、调用了<strong>gettimeofday</strong>或其他不可重复调用的方法，就可以认为是非确定性的。</p>
<p>进程的状态是最终保留在机器上内存或者磁盘的数据。</p>
<p>以相同的数据获取相同的输入听起来很熟悉，这跟日志相同。这是一个非常直观的概念：如果你给两段确定性的代码提供相同的日志输入，它们将得到相同的输出。</p>
<p>应用在分布式计算上就非常明显，你可以将使多个机器做相同的事情的问题，简化为实现分布式的一致性日志，并作为这些进程的输入的问题。在这里，日志的目的就是将所有的非确定性排除在输入流之外，以确保所有副本处理这些输入时保持同步。</p>
<p>当你理解了这个，这个也就不再复杂和深奥了：这差不多说，确定性的处理就是确定性的。然而，我仍然认为它是分布式系统设计中更通用的工具。</p>
<p>一个关于这个方法的最奇妙的一个事情就是，作为日志索引的时间戳也扮演着副本状态的时钟角色，你可以通过每个副本当前处理的最大的记录的一个简单的数字或者时间戳来描述每个副本。这个时间戳对应的日志体现了副本的状态。</p>
<p>根据日志写入的内容，在系统中应用这个原理有多种方式。例如，我们可以在日志中记录服务的请求、在对请求响应时服务的状态变化、或者执行的变更指令。理论上，我们甚至可以记录每个副本上要执行的一系列机器指令，要调用的方法名和参数。只要这两个进程以同样的方式处理这些输入，这些进程将在副本中保持一致的状态。</p>
<p>不同的用户群体似乎用不一样的方式描述日志的使用。数据库使用群体通常会区分物理日志和逻辑日志，物理日志指的是记录每一行变更的内容的日志，而逻辑日志记录的不是行的变更，而是会引起行数据变更的SQL命令（insert、update、delete语句）。</p>
<p>分布式系统文献通常将处理和复制广泛的分为两种方式。“状态机模型”通常被称为“主-主模型”，在这个模型下，我们维护了请求的日志，每个副本都处理这些请求。对“主-主模型”作了轻微的修改后，出现了“主-从模型”，在这个模型下，会选出一个副本作为主副本，来顺序处理到来的请求，并在处理过程中，在日志记录下状态的变更，其他的副本则顺序应用主副本上的状态变更，保持同步，以便在主副本异常时接替成为主副本。</p>
<p><img src="http://storage.laixiaoming.space/blog/active_and_passive_arch.png" alt="img"></p>
<p>为了理解这两种方式之前的不同，我们先来看一个不太严谨的例子，假设有多个算术服务，这些服务里维护了一个数字（初始值为0）作为服务的状态，并对这个数字应用加法和乘法。“主-主模型”下，在日志会记录下对这个值作出的变更，如“+1”、“*2”等，每个副本都会应用这些变更并得到相同的数字集。在“主-从”模型下，将存在唯一一个主副本，用于对维护的数字作出变更，并将结果记录到日志，如“1”、”3“、“6”等。从这个例子中，我们也知道了，为什么顺序是副本中保持一致性的关键因素，因为对一个加法和乘法操作调整了执行顺序将得到不一样的结果。</p>
<p>分布式日志可以被视为共识问题模型的一种数据结构，毕竟日志代表了一系列要追加的下一个值的决定。你必须要认真一点才能在Paxos算法中看到日志的身影，尽管日志是它们最常见的应用。Paxos通常被作为”multi-paxos”协议的一个扩展存在，把日志作为一系列共识问题的建模，日志中的每个槽都有一个值。但日志在ZAB、RAFT和Viewstamped Replication这些其他的协议中更加显而易见，在这些协议里面，直接作为维护分布式、一致性的日志的模型存在。</p>
<p>我有点怀疑我们的对这个的看法一定程序上受到了历史进程的影响，也许是由于过去几十年里，分布式计算理论的发展领先于其实际的应用。实际上，共识问题被过于简单化了。计算机系统几乎不会需要决定单个值，而几乎总是处理一系列请求。所以日志不能认为是一个简单的单值寄存器，而是一个更自然的抽象。</p>
<p>此外，对算法的关注使得系统需要的底层日志抽象变得模糊。我个人认为，我们最终将更加关注于作为商品化模块存在的日志，而不是它的实现，正如我们经常讨论哈希表而不需要了解它是使用的线性探测的杂音哈希还是其他，这种细节。日志将成为商品化接口的存在，同时许多算法和实现竞争以提供最好的保证或者其他可选的特性。</p>
<h4 id="变更日志：表和事件的二象性"><a href="#变更日志：表和事件的二象性" class="headerlink" title="变更日志：表和事件的二象性"></a>变更日志：表和事件的二象性</h4><p>回到数据库的讨论，在变更日志和表之间，有着有趣的二象性。日志类似于借贷和银行处理的列表，数据库表则是当前所有账号的余额，如果你有变更日志，你可以应用这些变更日志，以创建拥有当前状态的表，这个表记录了每条记录某个特定时间的最新的状态。从某种意义上说，日志是更加基础的数据结构，除了创建原始表，你还可以将其转换并创建各种类型的派生表（是的，对于非关系数据库使用群体，数据库表也是关键的数据存储）。</p>
<p>这个过程也是可逆的，如果你有一张要更新的表，你可以记录这些变更，然后发布所有对这个表状态变更的日志。变更日志就是需要用于支持近实时副本的。在这个场景中，你可以看到表和事件的二象性：表支持的静态数据，而日志记录了变更。日志的魅力在于，它不仅拥有了数据库表最终版本的内容，也允许你通过它重建其他任何可能存在的版本，它就相当于数据库表中每个旧版本的备份集合。</p>
<p>这可能让你想起版本控制系统，版本控制系统和数据库系统有着非常密切的关系，版本控制解决了分布式系统必须解决的一个非常相似的问题：管理分布式的、并发的状态变更。一个版本控制系统建模的是补丁序列，而那实际上是日志。你检出了当前代码的一个快照，那其实类似于数据库表，你会注意到，在版本控制系统中，复制是通过日志完成的，就像是在其他有状态的分布式系统一样：当你更新时、也就是拉取补丁并将补丁应用到你当前的版本。</p>
<p>有些人最近从销售日志数据库的公司Datomic那里看到了这样一些想法，这个<a href = "https://www.youtube.com/watch?v=Cym4TZwTCNU">视频</a>比较好的看到了他们是如何应用这些想法的，这些想法并不是专属于这个系统的，在过去十年里，他们很好地贡献了一部分分布式系统和数据库的文献。</p>
<p>这节内容可能有一些理论化了，别沮丧，马上就会有实操了。</p>
<h4 id="接下来的内容"><a href="#接下来的内容" class="headerlink" title="接下来的内容"></a>接下来的内容</h4><p>在文章的剩余内容，我将尝试讲述日志在分布式内部实现和抽象分布式模型之外的好处。这包括了：</p>
<ol>
<li>数据集成。使一个组织中的数据更容易地用在所有存储和处理系统中。</li>
<li>实时灵气处理。计算派生数据流。</li>
<li>分布式系统设计。如何通过集中式日志设计来简化实际的应用系统。</li>
</ol>
<p>这些用法都围绕着日志作为一个单体服务来解决实现。</p>
<p>在每个场景中，日志的好处都来源于日志能提供的简单的功能：生成持久化的、可重放的历史记录。惊讶地是，让多台机器能够以确定的方式并按各自的速度重试历史数据的能力，是这些问题的核心。</p>
<h3 id="第二部分：数据集成"><a href="#第二部分：数据集成" class="headerlink" title="第二部分：数据集成"></a>第二部分：数据集成</h3><p>首先我将说明下“数据集成”指的是什么，以及它为什么重要，然后我们可以发现它是怎么跟日志联系在一起的。</p>
<blockquote>
<p>数据集成正使得一个组织的数据在所有系统和服务中变得可用。</p>
</blockquote>
<p>“数据集成”这个词语并不常见，但我找不到一个更好的词语。大家更熟知的ETL仅仅覆盖了数据集成的一个有限子集——主要在关系型数据仓库使用。但我正在描述的事物更多的可以认为是广泛用于实时系统和处理流的ETL。</p>
<p>在人们对专注于大数据，对大数据大肆宣扬中，你可能很少听到过数据集成，尽管如此，我仍认为“让数据变得可用”这个普通的问题，是一个组织可以关注的最有价值的一个问题之一。</p>
<p>对数据的有效使用遵循了马斯洛的需求层次理论，金字塔的底层部分是获取所有相关的数据，并将其放到一个适用的处理环境中（可以是华丽的实时查询系统，或者仅仅是文件文件和python脚本）。数据需要采用统一建模的方式，使得数据更易于获取和处理。一旦用统一的方式获取数据的基本需求被满足了，接着就可以在这基础上用不同的试进行数据的处理——MapReduce、实时查询系统等。</p>
<p>值得注意的是，在缺少一个可靠和完整的数据流时，Hadoop集群只不过是一个昂贵和难以安装的加热器。一旦数据和处理变得可用，人们就可以更多关注于好的数据模型和一致的易于理解的语义这种更精细的问题上。最后关注点可以转换到更高级的处理上，更好的可视化、报表、算法处理和预测上。</p>
<p>以我的经验，大多数组织在金字塔的底部都有巨大的漏洞，它们缺乏可靠的完整的数据流，而且想要直接跳到先进数据建模技术上。这是本末倒置的。</p>
<p>所以主要的问题是，我们怎么在组织中构建一个可靠的数据流，贯穿在所有的数据系统中。</p>
<h4 id="数据集成：两个难题"><a href="#数据集成：两个难题" class="headerlink" title="数据集成：两个难题"></a>数据集成：两个难题</h4><p>两个趋势使得数据集成变得困难。</p>
<p><strong>事件数据管道</strong></p>
<p>第一个趋势是事件数据的增长。事件数据记录了发生的事情，而不是事物是什么。在网页系统中，指的是用户的活动日志，以及需要可靠操作和监控一个数据中心机器价值的机器事件和统计数据。人们倾向于称它们为日志数据，因为它通常被写到应用日志，但这混淆了形式和功能。数据是现代网站的核心，毕竟谷歌的财富是由点击和展示构建的相关性管道产生的，而这正是事件。</p>
<p>但这并不仅限于网站公司，这仅仅是因为网站公司是完全数字化的，所以它们很容易完成。金融数据一直以来都是以事件为中心的。RFID能将这种根据应用到物理对象上。我们认为，随着传统业务和活动的数据化，这种趋势将继续下去。</p>
<p>这种类型的事件数据记录了发生的事情，并且往往比传统数据库的使用要大上好几个数量级。这对处理有着巨大的挑战。</p>
<p><strong>专用数据系统的兴起</strong></p>
<p>第二个趋势来自于专用数据系统的兴起，这些系统在过去5年变得非常受欢迎并且是可以免费获取的。专用的系统用于OLAP、搜索、简单的在线存储、批处理、图分析等等。</p>
<p>更加多样化的更多数据，以及希望将这些数据用于更多系统的需求，导致了巨大的数据集成问题。</p>
<h4 id="日志结构化的数据流"><a href="#日志结构化的数据流" class="headerlink" title="日志结构化的数据流"></a>日志结构化的数据流</h4><p>日志是在系统之间处理数据流的自然的数据结构。其中的秘诀非常简单，获取所有组织的数据，并将其放到一个用于实时订阅的日志中心。每一个逻辑数据源都可以用自己的日志作为模型。一个数据源可以是输出事件（比如点击、页面浏览）的应用，或者是可以修改的数据库表。每个订阅系统都尽可能快地从日志读取，应用每一条新记录到自己的存储系统中，并推进在日志中的位置。订阅者可以是任意一种数据系统——缓存、Hadoop、另一个站点的数据库、搜索系统等等。</p>
<p><img src="http://storage.laixiaoming.space/blog/log_subscription.png" alt="img"></p>
<p>例如，日志概念为每个变更提供了逻辑时钟，每个订阅者的状态都可以被探测到。这使得彼此间推断不同的订阅者状态变得简单，因为它们每个都有着自己的读取位置。</p>
<p>为了让讨论更具体，举个简单的例子，假使有一个数据库和几个缓存服务器，日志则提供了一种方式来同步更新到所有的系统，并且推断出每个系统所处的时间点。我们往日志写入了一条新记录，然后从缓存中读取，如果我们希望保证不读取到旧数据，我们需要确保不会从任何一个在复制上没跟上最新数据的缓存中读取。</p>
<p>日志也可以作为一种缓冲，使数据的产生和消费异步。有许多原因使得这点非常重要，尤其是当有多个订阅者以不同的消费速率进行消费的时候。这意味着订阅者可能崩溃或者停机维护时，并在恢复的时候赶上来：订阅者以自己控制的速度进行消费。一个批处理系统，如Hadoop或者是一个数据仓库，每小时或每天消费一次数据，但一个实时查询系统却可能是需要即时消费的。原始数据源和日志都不知道各种目标数据系统，因此消费系统可以在不做变更的情况下在管道中被添加进来或移除出去。</p>
<p>特别重要的是，目标系统仅仅知道日志的存在而不知道源系统的任何细节。消费系统也不需要去关注数据是来源于数据库管理系统、还是新型的键值存储系统，抑或是在没有任何实时查询系统的情况下生成的。这似乎是一个很小的知识点，实际上却非常重要。</p>
<p>在这里我使用了“日志”这个词而不是“消息系统”或者“发布订阅”，这里因为这在语义上是更加准确的，是对你在实现数据复制支持时所需要的事情的更加准备的描述。我发现“发布订阅”只是表达出了消息的间接寻址。如果你比较任意两个具有发布订阅功能的消息系统，你会发现它们承诺的是完全不同的事情，在这个领域里面，大多数模型都是没有用处的。你可以认为日志是一种有着持久化保证和强有序语义的消息系统。在分布式系统中，通信模型也叫原子广播。</p>
<p>值得强调的是，日志仍然是基础设施，它并不是掌握数据流故事的结束：故事剩余部分围绕着元数据、模式、兼容性和处理数据结构和深化的所有细节来展开。但是，除非有一种可靠的、通用的处理数据流的机制，否则语义的细节仍然是次要的。</p>
<h4 id="在领英"><a href="#在领英" class="headerlink" title="在领英"></a>在领英</h4><p>随着领英从中心化的关系型数据库过渡到分布式系统，我注意到数据集成的问题也在逐渐演变。</p>
<p>目前我们的数据系统主要包括：</p>
<p>搜索、社交图谱、Voldemort(键值存储)、Espreso(文档存储)、推荐引擎、OLAP查询引擎、Hadoop、Terradata、Ingraphs(监控图表和监控服务)</p>
<p>以上这些都是特定的分布式系统，在特定的领域提供了高级的功能特性。</p>
<p>使用日志作为数据流的想法在我来到这里之前就已经出现了。我们开发的最早的一个基础设施之一是一个被称为databus的服务，它在我们早期的Oracle表上提供了一种缓存抽象，以扩展数据库更改的订阅，给我们的社交图谱和搜索索引提供输入数据。</p>
<p>我将简单介绍一些历史以提供讨论的上下文。在我们发布了自己的键值存储系统之后，大约是2008年，我开始参与这个项目。我的下一个项目是尝试部署配置一个可用的Hadoop，并将我们的推荐处理迁移到那里。由于缺乏这方面的经验，我们很自然的花了几周时间来完成数据的导入导出，剩下的时间则用来实现复杂的预测算法，就这样我们开始了长途跋涉。</p>
<p>我们最初的计划是将数据从现有的Orcale数据仓库中删除。但是我们首先发现快速将数据从Oracle中取出是一门黑暗的艺术。更糟糕的是，数据仓库的处理过程并不适用于我们为Hadoop设计的生产批处理，大部分的处理都是不可逆的，并且与要生成的具体报表相关。我们最终避免了数据仓库，转而直接使用源数据库和日志文件。最后，我们实现了另一个管道，将数据加载到键值存储，以提供结果。</p>
<p>这种简单的数据复制最终成为了原始开发的主要项目之一。糟糕的是，只要在任意时候管道内如果有问题，Hadoop系统也变得毫无用处——在错误的数据上运行了华丽算法只会产生更多的错误数据。</p>
<p>虽然我们使用了一种很通用的构建方式，但每一个新的数据源都需要自定义的安装配置。它也被证明是大量错误和失败的根源。我们用Hadoop实现的网站功能开始流行起来，而我们发现有大量对此感觉兴趣的工程师，第个人都许多想要集成的一系列系统，并且想要导入许多新的数据。</p>
<p>有些东西渐渐地清晰了起来。</p>
<p>首先，我们构建的管道，虽然有一些杂乱，但实际上是极有价值的。在一个新处理系统（Hadoop）上让数据变得可用的过程解锁了大量的可能性。在这些数据上做新的计算变得可能，这在过去是很难实现的。许多新产品和分析都来自于将以前锁定在特定系统的多种数据放在一起。</p>
<p>第二，很明显，可靠的数据加载需要数据管道的尝试支持。如果我们获取到了所需要的所有结构，我们可以让Hadoop数据加载变得完全的自动化，因此添加新的数据源或者处理模式的变更不再需要人工的介入——数据会自动的出现在HDFS中，Hive表将会自动地为新的数据源生成合适的列。</p>
<p>第三，我们的数据覆盖率仍然很低。如果你看一下，领英在Hadoop中所有可用的数据的百分比，你会发现它非常不完整。考虑到需要在新数据源上付出大量的努力，让数据变得完整这项工作并不容易。</p>
<p>我们一起在进行的，为每个数据源和目标数据构建一个个性化的数据加载很显然是不切实际的。我们有几十个数据系统和数据仓库，连接这些系统将会导致，在第两个系统之间构建一个个个性化的管道，就像这样：</p>
<p><img src="http://storage.laixiaoming.space/blog/datapipeline_complex.png" alt="img"></p>
<p>需要注意的是，数据是双向流动的，就像许多系统一样（数据库、Hadoop），都需要在来源和目的地之前传输数据。这意味着我们最终在每个系统构建两条管道：一条用于获取数据，另一条用于流出数据。</p>
<p>很显然，这需要大批的人来做这个事情，而且是不可行的。当接近全连接时，我们将得到O(N2)条管道。</p>
<p>为了避免这个，我们需要像这样通用的东西：</p>
<p><img src="http://storage.laixiaoming.space/blog/datapipeline_simple.png" alt="img"></p>
<p>我们需要尽可能地，将每个消费者从数据源中隔离开来。他们应当和一个数据仓库集成，并且可以从中获取所有的数据。</p>
<p>在这种方式下，添加一个新的数据系统——数据源或者数据目的地——可以仅仅通过连接到这单个管道上实现集成，而不需要跟每个每个数据消费者连接。</p>
<p>这种经历让我专注于构建Kafka，以将我们在消息系统中看到的内容与流行在数据库和分布式系统内部的日志概念相结合起来。我们冼想要一个可以作为中心管道给所以活动数据服务的东西，并最终用于其他许多用途，包括Hadoop之外的数据、监控数据等等。</p>
<p>在很长一段时间，Kafka是基础设施中独一无二的存在（有人说它很特别）——它不是数据库，也不是日志文件收集系统，更不是传统的消息系统。但最近Amzon提供了一种类似于Kafka的服务——Kinesis。相似之处包括分区处理的方式，数据的持有方式，还有分为高级及初级的消费者API这种奇怪的地方。对此我感到很高兴，你创建了一个好的基础设施的抽象的标识就是，Amazon将其作为了一种服务提供出去。他们对此的看法跟我描述的很相似，它是连接所有分布式系统的管道——RdynamoDB、RedShift、S3等等——同时了作为分布式流处理EC2的基础。</p>
<h4 id="ETL和数据仓库的关系"><a href="#ETL和数据仓库的关系" class="headerlink" title="ETL和数据仓库的关系"></a>ETL和数据仓库的关系</h4><p>让我们来谈下数据仓库，数据仓库是用于支持分析的干净的、集成数据结构的仓库。这是一个非常好的理念。对于不了解数据仓库概念的人来说，数据仓库方法涉及周期性的从源数据库中提取数据，将其转换为可理解的形式，并将加载存入中央数据仓库。集中拥有所有干净的数据的副本，对于数据密集型分析和处理而言是一项非常有价值的资产。在更高层面上，无论你使用传统的数据仓库Oracle，或者是Terada和Hadoop，这个使用方式不会有太大的不同，虽然你可能需要换一下加载和转换的顺序。</p>
<p>包含了清洗、数据集成的数据仓库是一项非凡的资产，但实现这个的机制有一些过时了。</p>
<p>对于一个以数据为中心的组织而言，关键问题是将干净的集成数据联合到数据仓库。数据仓库是批处理查询的基础设施，它非常适用于多种报表和临时分析，特别是当查询涉及到计算、聚合和过滤的时候。但如果批处理系统是唯一一个包含完成数据的仓库，将意味着数据不可用于实时的系统——实时处理、搜索索引 、监控系统等等。</p>
<p>在我看来，ETL包括了两件事情。首先，它是数据提取和清洗的过程，本质上是释放被锁在组织中的各类系统中的数据，并去除特定系统的约束。第二，数据被异构用于数据仓库查询（例如适配关系型数据库系统，强制使用星形或雪花型，可能打破原有的高性能的列格式）。同时做好这两件事情不容易。这些规整的数据仓库可以用于实时的或低延时的处理，也可以用于其他实时的存储系统中的索引。</p>
<p>我认为这具有使数据仓库ETL更加可扩展的额外的好处。典型的问题是，数据仓库团队要收集和处理其他团队的所有的数据。两边的收益是不对称的，数据的生产者常常并不知晓数据仓库中数据的使用，最终创建了很难获取或者转换成有用格式的数据。当然，中心团队也无法扩充以匹配于其他组织的发展速度，以致于数据的覆盖率问题质量不一的，数据的流向也是脆弱的，改进也是缓慢的。</p>
<p>一个更好的方法是，拥有一个有着为额外数据定义的良好API的中心管道，日志。集成这个管道并提供规整的、良好结构的数据由数据的生产者负责。这意味着，作为系统设计和实现的一部分，他们必须考虑获取数据和生成用于传输到中心管道的良好结构格式的数据这种问题。新的存储系统的加入对于数据仓库团队而言没有任何影响，因为它们具有集成的中心点。数据仓库团队仅仅需要处理从中心日志加载结构化数据这种简单的问题，并将特定的转换格式传输到它们的系统。</p>
<p><img src="http://storage.laixiaoming.space/blog/pipeline_ownership.png" alt="img"></p>
<p>当一个人考虑采用传统数据仓库之外的其他数据系统时，组织上的可伸缩性变得尤为重要。例如，想在组织的完整数据上提供搜索的能力，或者想为实时趋势图的数据流提供监控和告警。在这些场景下，传统数据仓库的基础设施或者Hadoop都将变得不可用。更糟糕的是，被构建用于支持数据库加载的ETL处理管道也不再作用于其他系统，构建这些基础设施的工作量跟采用一个数据仓库一样大。这似乎是不可行的，这也解释了为什么大多数组织不具备他们在数据上的一些简单可用的能力。相反的，如果一个组织构建了统一的，良好结构的数据，那么让任意一个新系统完全获取所有的数据仅仅需要在管道上做一下集成的工作。</p>
<p>关于数据规整化和转换在哪里完成，这个架构了有着不同的观点：</p>
<ol>
<li>在添加数据到公司的全局日志之前，由数据的生产者完成。</li>
<li>由日志的实时转换器完成（产生一个新的格式化的日志）。</li>
<li>由加载到目标数据系统进程的一部分完成。</li>
</ol>
<p>最好的模型是数据发布到日志之前由数据的生产者完成数据的规整化。这意味着确保了数据处理标准形式，并且不需要包含任何由生成该数据的特定代码产生的或者存储系统维护的无意义的内容。这些细节可以很好地被生成数据的团队处理，因为他们是最了解他们数据的人。这个阶段所使用的任务逻辑都应该是无损的和可逆的。</p>
<p>任何可以实时完成的具有附加价值的转换都应该在原始日志上的后处理去执行。其中包括事件数据处理成会话，或者其他派生字段的添加。原始日志仍然是可用的，但实时处理将产生包含增强数据的派生日志。</p>
<p>最后，只有针对目标系统的聚合操作才应该被加到加载流程中。这些操作可能包括将数据转换为特定的星形或者雪花模式，用于在数据仓库中分析和报告。由于这个阶段，一般最自然的映射到传统的ETL流程，现在基于一种更规整和统一的数据流集去处理，因此也会更简单的。</p>
<h4 id="日志文件和事件"><a href="#日志文件和事件" class="headerlink" title="日志文件和事件"></a>日志文件和事件</h4><p>让我们再聊聊这种架构的附加好处，它支持解耦的事件驱动系统。</p>
<p>在Web行为，获取活动数据的典型方式是将其记录到文件文件，这些文本文件可以被放到数据仓库或者Hadoop，用于聚合和查询。这存在的问题跟所有批处理ETL一样，它耦合了数据仓库数据流的能力和处理调度。</p>
<p>在领英，我们是以日志中心的方式构建的事件数据处理。我们正使用Kafka伪中心的、多订阅者的事件日志。我们定义了数百种事件类型，每种事件类型都有着特定类型操作的特定属性，这涵盖了从页面浏览、展示、搜索、到服务调用和应用异常等各种情况。</p>
<p>为了进一步理解这一种优势，想象一下有这么一种简单事件，在工作职位页面上展示职位信息。职位页面应该仅仅包含展示职位信息的逻辑。然而，在一个相当动态的网站上，这很容易变成额外的与工作无关的逻辑的点缀。例如，假设我们需要集成以下系统：</p>
<ol>
<li>将数据发送到Hadoop和数据仓库，用于离线处理。</li>
<li>计算页面浏览量，确保浏览者不是内容爬虫的一种。</li>
<li>聚合浏览信息，并在职位发布者的分析页面展示 。</li>
<li>记录浏览信息，确保对用户的职位推荐合适进行展示（我们不希望一次又一次地展示相同的职位信息）。</li>
<li>推荐系统需要记录浏览，以便正确追踪职位的流行性。</li>
<li>等等</li>
</ol>
<p>用不了多久，展示一个职位这种简单的动作就会变得十分复杂。当我们的职位要支持在其他终端上展示——手机应用等——这样的逻辑必须要延续下来，复杂度也将上升。更糟糕的是，我们需要与之交互的系统是错综复杂的，负责展示职位工作的人也需要了解其他系统和特性，并确保正确的集成。这里只是简单的描述了该问题，实际的应用将会更加复杂。</p>
<p>事件驱动风格提供了一种简化的方法。职位展示页面只负责展示职位并记录职位的相关属性信息，浏览的人或者关于职位展示的其他有用的信息。每一个其他对这个感兴趣的系统——推荐系统、安全系统、职位发布者分析系统以及数据仓库，都只需要订阅这些信息并且自己处理。展示的代码并不需要关注其他的系统，如果一个新的数据消费者被添加进来也不需要作出改变。</p>
<h4 id="构建可伸缩的日志"><a href="#构建可伸缩的日志" class="headerlink" title="构建可伸缩的日志"></a>构建可伸缩的日志</h4><p>当然，将发布者和订阅者分离开来并不是什么新鲜事。但如果你想维护一个提交日志，该日志作为消费者规模网站上所有活动的多订阅者实时日志，那么可扩展性将是一个主要的挑战。如果我们不能构建一个快速的、低成本的，足够可扩展的日志，使其在大规模上可行，那么使用日志作为统一集成机制不过是一个更美好的幻想。</p>
<p>人们普遍认为日志是缓慢的、高度抽象的（并且通常只把它与元数据类的使用方式联系在一起（Zookeeper））。但有了一个记录大数据流的深思熟虑的实现，打破了这一看法。在领英，目前我们通过Kafka每天写入超过600亿的消息（如果算上数据中心之间镜像的消息，这个数将是数千亿）。</p>
<p>我们在Kafka中使用了一些技巧，以支持这种规模：</p>
<ol>
<li>日志分区</li>
<li>通过批量读写优化了吞叶率</li>
<li>避免了无意义的数据复制</li>
</ol>
<p>为了支持水平扩展，我们将日志进行了分区：</p>
<p><img src="http://storage.laixiaoming.space/blog/partitioned_log.png" alt="img"></p>
<p>每个分区都是一个完全有序的日志，但在分区之间没有全局的顺序（除非在你的消息中可能包含了墙上时钟时间）。消息被分配到一个特定的分区是由写入者决定的，大多数使用者会选择使用某种类型的值来分区（比如用户id）。分区允许日志追加，在分片之间无需协调即可发生，并且允许系统的吞吐量随着Kafka集群大小而线性扩展。</p>
<p>每个分区都可以通过配置副本数量进行复制，每个副本都有一个副本日志完全一样的拷贝。在任意时候，其中的一个副本将作为leader，如果leader发生故障，剩余的其中一个副本将接替成为leader。</p>
<p>在分区之间缺乏全局顺序确实是一个限制，但我们并未发现这是一个主要的限制。确实，与日志进行交互的通常是成百上千的独立线程，因为在这种情况下讨论它的全局顺序是没有意义的。代替的，我们保证了每个分区的顺序，并且Kafka保证了追加到特定分区的顺序将根据发送者发送的顺序进行传送。</p>
<p>日志，就像文件系统，对于顺序读写可以方便地优化。日志可以把小的读写合并成更大的、更高吞吐量的操作。Kafka致力于这种优化。这种批量操作存在于从客户端发送数据到服务端时，写磁盘时、服务间的复制、将数据传送给消费者时，以及确认提交的数据时。</p>
<p>最后，Kafka使用了简单的二进制格式维护内存日志、磁盘日志、网络中数据传输的日志。这允许我们可以使用包括“零拷贝”在内的大量优化机制。</p>
<p>这些优化的积累起来的效应就是，你通常可以以磁盘或网络支持的速率进行读和写，即使维护的数据集大大超出了内存的大小。</p>
<p>这篇文章并不是主要讨论Kafka的，在这里我不再讨论他们的细节。你可以通过领英的这篇文章和Kafka的设计这篇文章阅读更多的细节。</p>
<h3 id="第三部分：日志和实时流处理"><a href="#第三部分：日志和实时流处理" class="headerlink" title="第三部分：日志和实时流处理"></a>第三部分：日志和实时流处理</h3><p>到目前为止，我只讲述了在系统之间拷贝数据的一种奇特的方式。但在存储系统之间传输字节并不是故事的结束。事实证明，日志是流的另一个说法，日志是流处理的核心。</p>
<p>但等会，什么是流处理？</p>
<p>如果你是上世纪90年代或21世纪初数据库文献或者成功了一半的数据基础设施产品的粉丝，那么你可以会把流处理与创建SQL引擎或者事件处理驱动处理的“盒子和箭头”界面相关联起来。</p>
<p>如果你关注开源数据系统的爆炸性增长，你可能会将流处理与这个领域下的一些系统相关联起来——如Storm、Akka、S4、Samza。但很多人会认为这是一种异步消息处理系统，与集群感知的RPC层不同（事实上，这些领域的一些东西确实如此）。</p>
<p>这些观点都有些局限。流处理与SQL并无关联，也不局限于实时处理。本质上，并没有什么理由不能使你不能用多种语言来处理昨天或一个月前的数据流来表达计算。</p>
<p>我将流处理视为更广泛的东西：不断用于数据处理基础设施。我认为计算模型可以像MapReduce或其他分布式处理框架一样通用，但他同时具有生产低延迟数据的能力。</p>
<p>处理模型的真正驱动力是数据收集的方式。数据被批量收集，也自然被批量处理。当数据不断地被收集，也自然而然地被不断地处理。</p>
<p>美国的人口普查给批量数据收集提供了一个很好的例子。人口普查会定期开始，通过挨家挨户的蛮力调查和统计美国公民。这在1790年人口普查刚开始的时候很有用。当时的数据收集是面向批处理的，它涉及到骑马走访并在纸上记录，然后将这一批记录运输到中央地方，在那里人为进行汇总。现在，当你描述人口普查过程时，会好奇我们为什么不维护出生和死亡的记录，并借此连续地或以任何所需要的粒度得到人口的数量。</p>
<p>这是一个极端的例子，但许多数据传输过程仍然依赖于定期的数据下载、批量的数据传输和集成。处理批量转储的方式自然是批处理。随着这些过程被连续的数据流所取代，人们自然会开始转向连续处理，以平衡处理所需要的资源，并减小延迟。</p>
<p>例如，在领英，几乎没有批量数据收集。大多数数据都是活动数据或者数据库的变更，这两种数据都是连续发生的。事实上，你想到任何业务，潜在的页面几乎都是一个连续的过程——实时发生的事件，正如Jack Bauer说的那样。当数据被批量收集时，几乎总是因为人为的步骤、或缺乏数字化、或非数字化过程自动化遗留下的历史问题。数据传输并对数据作出回应依赖于邮件或者人工处理时，通常是非常慢的。自动化的初步尝试问题保留了原始流程的形式，因此这种方式通常持续很长时间。</p>
<p>每天运行的生产“批量”处理作为通常是在模仿一种以一天为窗口大小的连续计算。底层数据当然问题在不断变化的。在领英，这实际上很常见（并且在Hadoop中使他们工作的机制非常复杂），我们实现了一个完整的框架来管理增量的Hadoop工作流程。</p>
<p>从这个角度看，很容易对流处理产生不同的认识：它仅仅处理包含了时间概念的底层数据，而不需要静态的数据快照，因此它可以根据用户控制的频率输出数据，而不是等待数据集到达后再产生输出。从这个角度上看，流处理是广义上的批处理，并且鉴于实时数据的流行，这种批处理变得非常重要。</p>
<p>那么，为什么传统的流处理只在小范围流行呢？我们认为最大的原因是实时数据收集的缺乏，使得连续处理更多停留在学术研究的层面 。</p>
<p>我认为，是否缺乏实时数据的收集，决定了商业流处理系统的命运。他们的客户仍然在使用基于文件的每天的批处理来完成ETL和数据集成。建设流处理系统的公司专注于提供流处理引擎来连接实时数据流，但结果是实际上那个时候很少人拥有实时数据流。事实上，在领英的早期职业生涯中，有一家公司向我们推销一个非常酷炫的流处理系统，但由于那时我们所有的数据都是小时被收集到文件上，我们能做到的最好使用场景是在每小时的最后把这些文件输入到流处理系统中，他们意识到这是一个普遍问题。这个例子实际上已经证明这个规律：在金融领域，流处理已经取得了一些成功，实时数据流已经成为了常态，而处理成为了瓶颈。</p>
<p>即使在拥有完善的批处理生态系统的前提下，我仍然认为流处理作为一种基础设施的应用也相当广泛。我认为它填补了实时请求/响应服务和离线批处理之间的基础设施缺口，对于现代互联网公司来说，我认为25%的代码可以划分到这个范畴。</p>
<p>事实证明，日志解决了流处理中的一些棘手的技术问题，正如我所描述的，但它解决的最大的问题是，使数据在实时多订阅者中变得可用。对于那些对更多细节感兴趣的人，我们开源了Samza，一个目标明确基于这些思想构建的流处理系统。我们在相关文档中，描述了大量这些应用的细节。</p>
<h4 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h4><p><img src="http://storage.laixiaoming.space/blog/dag.png" alt="img"></p>
<p>流处理最有趣的方面与流处理系统的内部无关，而是与它如何扩展我们早期对输入数据的看法的有关。我们主要讨论了主数据的输入和日志——在多个应用的执行过程中产生的事件和数据行。但流处理也允许我们包含了由其它数据计算出的数据。对消费者而言，这些派生的数据与计算得到它们的原始数据没有什么不一样。这些派生的数据可以任意的封装组合。</p>
<p>让我们深入研究一下，出于我们的目的，一个数据流任务，是指从日志中读取数据，并将输出写到日志或其他系统。用于输入和输出的日志将这些处理流程连接成一个流程图。实际上，以这种方式使用中心化的日志，你可以将所有的组织数据图、转换和流向视为一系列写入它们的日志和流程。</p>
<p>流处理器根本不需要花哨的框架：它可以是读写日志的一个或一组处理过程，是可以用于帮助管理流程代码的额外的基础设施或支持。</p>
<p>在集成中，日志的目标是双重的。</p>
<p>首先，日志让每个数据集都支持多个订阅者，并且是有序的。回顾一下前端的“状态副本”，以便记住顺序的重要性。为了让这个更准确，假使有一个数据库的更新流——如果我们在我们的处理中对同一条记录的两条更新作重排序，我们可能会产生错误的最终结果。这种顺序比TCP等提供的更加持久，因为它不仅限于单点对点的链接，而且在处理失败和重新连接后仍然存在。</p>
<p>第二，日志为进程提供了缓冲。这一点非常基础。如果是以非同步的方式处理的，很有可能会发生上游数据生成作业的速度会下游作为消费的速度更快。当这种情况发生时，处理必须阻塞、缓冲或丢弃数据。丢弃数据可能不是一个可行的选择，阻塞可能会造成整个处理陷入停顿。日志充当了非常大的缓冲区，它允许进程重启或者失败，而不会造成其它处理流程中其他部分的处理缓慢。当将这种数据扩展到更大的组织时，这种隔离非常重要，处理是由许多不同的团队创建的作业进行的。我们不能让一个失败的作业造成背压，导致整个处理流的停止。</p>
<p>Storm和Samza都是以这种风格构建，并且可以使用Kafka或者其他同类型的系统作为他们的日志。</p>
<h4 id="有状态的实时流处理"><a href="#有状态的实时流处理" class="headerlink" title="有状态的实时流处理"></a>有状态的实时流处理</h4><p>一些实时流处理只是无状态的记录转换，但许多用法更多侧重于流中窗口内的计数、聚合衙连接操作。例如，有人想要通过用用户点击的信息来丰富事件流（比如点击流）——实际上是将用户的点击流添加到用户数据库。通常，这种处理最终需要处理器维护某种状态：例如，当计数的时候，你需要维护当前的数量，如果处理器本身出问题了，这种状态要怎么维护正确呢？</p>
<p>最简单的做法是在内存中维护状态，然而如果处理器崩溃了，将会丢失中间状态。如果状态仅在窗口内维护，处理可以回退到日志中窗口开始的位置。然而，如果要在一个小时内计数，这可能是不可行的。</p>
<p>将所有状态简单地存储在远程存储系统中，并通过网络连接到该存储系统是一种可行的方法。这种方式的问题是缺少了数据的局部性，以及网络往返次数多。</p>
<p>如何支持像数据库表这样的东西，它可以跟我们的处理一样被分区？</p>
<p>当我们回顾表和日志的对偶性时，这给我们提供了可以将流转换为可以与处理共存的表的工具，同时也是一种解决表容错的机制。</p>
<p>一个流处理器可以在本地表或者索引维护它的状态——bdb、leveldb甚至是一些更加罕见的组件，比如Lucene或者fastbit索引。存储的内容来自于其输入流（可能首先应用了一些转换）。流处理器可以将其本地索引的变更日志记录下来，以便可以在崩溃和重启时恢复其状态。这种机制允许一个通用的方法来保持与输入流数据本地共分区的任意索引类型的状态。</p>
<p>当处理失败的时候，可以从变更日志中恢复。日志是每次备份时，本地状态到增量数据集的转换。</p>
<p>这种状态管理的方式的优雅之处在于，处理器的状态也作为日志来维护。我们可以将这个日志视为数据库表的更改。事实上，处理器同时维护了类似于联合分区表的东西。由于状态本身就是日志，其他处理器也可以订阅它。当处理的目的是更新最终状态，并且状态是处理的自然输出时，这实际上是非常有用的。</p>
<p>当出于数据集成的目的，将源于各数据库的日志级合起来时，日志和表的二象性的强大就变得明显了。变更日志可能是从数据库中提取而来的，并被不同的处理器异构成不同格式的索引，以跟事件流进行连接。</p>
<p>我们将在Samza中详细介绍这种状态处理的管理方式，<a href="http://samza.incubator.apache.org/learn/documentation/0.7.0/container/state-management.html">这里</a>有一些实践的示例。</p>
<h4 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h4><p><img src="http://storage.laixiaoming.space/blog/log_compaction_0.png" alt="img"></p>
<p>当然，我们不可能保存所有时间段内所有状态变更的完整的日志。除非想要使用无限的空间，否则日志是必须要清理的。我将具体谈一些关于Kafka在这方面的实现。在Kafka中，清理有两种策略，这取决于数据是否包含键或者事件数据。对于事件数据，Kafka支持保留一个时间窗口的数据。通常，这个时间窗口被配置为几天，但这个窗口也可以基于时间或空间定义。对于有键值的数据，完整日志的一个很好的方面是你可以通过重放日志的方式来重建源系统的状态（可能在另一个系统中重建）。</p>
<p>然而，保留完整的日志会随着时间的推移，占用起来越多的空间，重放也将花费起来越多的时间。然而，在Kafka中，我们支持另一种保留方式。代替简单地丢弃老的日志，我们删除淘汰的记录——比如那些主键有了更新的记录。通过这种方式，我们仍然能保证日志包含源系统的完整的备份，虽然不再能重建源系统的所有旧的状态，而是保留了最新的状态。我们称这个特性为日志压缩。</p>
<h3 id="第四部分：系统构建"><a href="#第四部分：系统构建" class="headerlink" title="第四部分：系统构建"></a>第四部分：系统构建</h3><p>我最后想讨论的是日志在在线数据系统的数据系统设计中扮演的角色。</p>
<p>这里有一个类比，日志在分布式数据库的数据流中扮演的角色和和它在一个更多的组织的数据集成中扮演的角色。在这两种情况下，它都是负责数据流、一致性和恢复。毕竟，一个组织如果不是一个复杂的分布式数据系统，那它是什么呢？</p>
<h4 id="分解？"><a href="#分解？" class="headerlink" title="分解？"></a>分解？</h4><p>如果你换个角度，你可以将整个组织的系统和数据流看成是一个整体的分布式系统。你可以将所有的独立的面向查询的系统（Redis、SOLR、Hive表等等）看作是你的数据的专门的索引。你还可以将流处理系统看作是一个成熟的触发器和视图实现机制。我注意到传统的数据库人群非常喜欢这种观点，因为他们终于能解释通，所有的这些不同的数据系统到底是用来做什么的——他们仅仅是不同的索引类型。</p>
<p>不可否认的是，数据库类型正爆发式增长，但实际上，其复杂性一直存在。即便在关系型数据库的盛行的时期，组织也拥有大量的关系型数据库。因为大型机，所有的数据实际都存放在同一个位置，所有可能并不存在真正的数据集成。将数据独立拆分到多个系统有许多原因：数据伸缩性、地理位置、安全性以及性能隔离是最常见的。但这些都可以通过一个好系统来解决：组织通过单个Hadoop集群保存所有的数据，并服务于众多的多样化的用户群体是可能。</p>
<p>在转向分布式系统的过程中，已经有了一种可能的数据处理简化：将大量的各个系统的小实例聚合到一个大的集群里。许多系统不足以做到这些：它们缺乏安全性、或不能保证性能隔离、或不具备良好的伸缩性。但每个问题都是可以解决的。</p>
<p>在我看来，不同系统大量涌现的原因是构建分布式数据系统的困难性。通过将系统裁减到一个单一的查询类型或用例上，每个系统都可以回到自己范围内可以做到的事情上来。但运行所有这些系统还是太复杂了。</p>
<p>未来可能会有3种可能的方向。</p>
<p>第一种可能性是现状的延续：系统之间的隔离在往后很长的一段时间内都将保持不变。这可能是因为分布式系统构建难度太大，或者是因为这种专业化使得每个系统的便利性和功能水平达到一个新的高度。只要这种情况持续下去，数据集成问题将是数据成功使用中最重要的问题之一。在这种情况下，用于集成数据的外部日志将非常重要。</p>
<p>第二种可能性是统一合并一个具有足够通用性的系统，开始将所有不同的功能合并到一个单独的超级系统中。这个超级系统从表面上看可能像一个关系型数据库，但在组织中的使用将大大不同，因为你只需要一个大的系统而不是无数个小的系统。在这样的世界里，除了系统内部不存在真正的数据集成问题。我认为，构建这样的一个系统在实践上的困难性使得其不太可能发生。</p>
<p>还有另外一种可能的结果，作为一个工程师，我觉得它很有吸引力。新一代的数据系统最有趣的一方面是它几乎都是开源的。开源创建了一个可能性：数据设施可能被分解成一系列的服务和面向应用的系统api。你已经在Java的技术栈上看到了，正一定程序地出现这种情况：</p>
<ul>
<li>Zookeeper处理了系统协调的很多问题（或者有来自于像Helix或者Curator一些的高级抽象）。</li>
<li>Mesos和YARM处理了虚拟化和和资源管理。</li>
<li>像Lucene和LevelDB的嵌入式类库充当了索引。</li>
<li>Netty、Jetty和像Finagle和rest.li这种高级别的封装处理远程的通信。</li>
<li>Avro、Protocol Buffers、Thrift等等其他的类库处理了序列化。</li>
<li>Kafka和Bookepper提供了备份日志。</li>
</ul>
<p>如果你把上面的这些放一起，稍微观察一下，会发现它看起来就像是分布式数据工程中的“乐高”版本。你可以将这些零件放在一起，创造大量的可能的系统。这显然不是一个与终端用户相关的故事，他们可能更多关心api而不是实现，但在一个更加多样化和模块且持续演进的世界中，这可能是一条通往实现单个系统的简单性的一条路径。如果因为可靠的、灵活的构件出现，而使得分布式系统的实现时间从年缩减到周，聚合形成单一的整体的系统的压力将会消失。</p>
<h4 id="日志在系统架构中的地位"><a href="#日志在系统架构中的地位" class="headerlink" title="日志在系统架构中的地位"></a>日志在系统架构中的地位</h4><p>假使存在外部日志的系统允许每个系统抛弃自身的复杂性，转而依赖于共享日志。以下是我们认为日志可以做的事：</p>
<ul>
<li>通过对节点并发的更新进行排序，处理数据一致性（无论是最终的还是实时的）。</li>
<li>在节点之间提供节点的副本。</li>
<li>为写入者提供“提交”的语义（比如，只有在你的写入被保证不会丢失的情况下确认）。</li>
<li>提供给外部的本系统数据的订阅。</li>
<li>对于丢失数据的失败的副本或者新的副本，提供可恢复的能力。</li>
<li>在节点之间处理数据的重平衡。</li>
</ul>
<p>这实际上是分布式系统所做工作中的一个重要部分。实际上，剩余的大部分工作都与最终面向客户端的查询api和索引策略有关。这确实各个系统之间应该有所不同的部分：例如一个全文检索可能需要查询所有的分区，但通过主键的查询可能仅仅需要查询一个为该键服务的单个的节点。</p>
<p>这是它的工作原理。系统被分为两个逻辑部分：日志和服务层。日志顺序记录了状态的变更。服务节点存储了需要为查询服务的索引（比如，一个键-值存储系统可能有像btree或者sstable的事物、一个有着倒排索引的搜索系统）。写操作可能是直接写日志，虽然他们可能被服务层代理。写日志会产生一个逻辑时间戳（日志中的索引）。如果系统被分区了，日志服务节点将有相同的分区数量，虽然他们可能有不同的机器数量。</p>
<p><img src="http://storage.laixiaoming.space/blog/system.png" alt="img"></p>
<p>服务节点订阅日志，并且尽可能快地以存储的顺序应用更新到它的本地的索引。</p>
<p>客户端可以提供写入的时间戳作为查询的一部分，从任意节点获得“读取你写入的”的语义——接收到该查询请求的服务节点，将对所需的时间戳和本地的索引进行比较，必要时会延长请求，直到索引至少抵达该时间点，以避免提供了旧的数据。</p>
<p>服务节点可能会或可能不会感知master身份或leader选举。对于许多简单的用例，服务节点可以完全不需要leader，因为日志是事实之源。</p>
<p>分布式系统中必须要做的更棘手的事情之一是处理恢复失败的节点或者将分区从一个节点转移到另一个节点。一个典型的方案是，仅保留一个固定窗口的数据，并把这个数据和分片中存储的快照结合起来。同样地，也可以保留数据完整备份的日志，并自行进行垃圾回收。这把特定系统的服务层的大量的复杂性移到了通用的日志层。</p>
<p>有了日志系统，你将得到了一个针对数据存储内容的成熟的订阅api，通过通过ETL传输到其他系统。</p>
<p><img src="http://storage.laixiaoming.space/blog/full-stack.png" alt="img"></p>
<p>注意，这样一个以日志为中心的系统是怎么立即成为在其他系统中处理和加载的数据流的提供者呢？同样的，一个流处理器可以消费多个输入流，又通过索引其输出的另一个系统服务于他们。</p>
<p>我发现这种对系统分解为日志和查询api的观点非常具有启发性，因为它可以使查询特性从系统的可用性和一致性中脱离出来。我实际上认为，这是一种通过分解系统来理解它们的一种很有用的一种方式，虽然系统并不是以这种方式构建的。</p>
<p>值得一提的是，虽然Kafka和Bookeeper都是一致性日志，但不是必须的。你可以简单将一个Dynamo之类的数据库分解为一个最终一致性的AP日志和一个键-值服务层。这样的日志用起来很灵活，因为它会重传旧消息，并依赖于订阅者来处理（很像Dynamo做的）。</p>
<p>在日志中保留一个单独的副本（特别是完整的副本），在许多人看来是浪费的。事实上，有几个因素使得这个不是一个大问题。首先，日志可以是一种非常高效的存储机制。我们在我们生产的Kafka服务上的每个数据中心都存储了超过75TB的数据。同时有许多服务系统需要更多的内存来高效的服务数据（例如，文本搜索通常问题在内存中进行）。服务也使用优化过的硬件。例如，我们大多数运行中的数据系统基于内存提供服务，或使用固态硬盘。相反，日志系统只进行线性读写，因此它非常乐意使用大型多TB的硬盘。最后，正如上图描述，数据被服务于多个系统，日志的成本也在多个索引中分摊。上面几点使得外部日志的开销相当小。</p>
<p>这正是领英用来构建许多实时查询系统的模式。这些系统从数据库中获取数据（使用Databus作为日志抽象，或者从Kafka中真正的日志中获取），并且在数据流的基础上，提供特定的分区、索引和查询能力。</p>
<p>这是我们实现了搜索、社交图谱和在线分析查询系统的方式。实际上，将单一的数据流复制到多个服务系统用于在线服务是非常通用的做法。事实证明，这是一个极大的简化的假设。这些系统不再需要提供外部写入的api，Kafka和数据库被用于记录系统和通过日志流向恰当的系统的变更流。写入操作在本地被特定分片的节点处理。这些节点机械地将日志提供的数据流记录到自己的存储系统。失败的节点可以通过重放上游的日志来恢复。</p>
<p>这些系统依赖日志的程度各不相同。一个完全可靠的系统可以利用日志作为数据分区、重平衡、一致性的方方面面，以及数据传播。在这样的架构中，服务层保不过是一种缓存，以支持直接写入到日志的特定处理。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>如果你从头一起读到了这里，那么我对日志的理解，你大部分都知道了。</p>
<p>以下是一些你可以想要查阅的有趣的相关资料。</p>
<p>人们会用不同的术语来描述相同的事物，当你从数据库系统到分布式系统、从各企业级的应用软件到开源世界，会感到疑惑。无论如何，在大方向上是有一些共同之处的。</p>
<p>学术论文、系统、讨论和博客：</p>
<ul>
<li>关于<a href = "http://www.cs.cornell.edu/fbs/publications/smsurvey.pdf">状态机</a>和<a href = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.20.5896">主从备份</a>的概述。</li>
<li><a href = "http://research.microsoft.com/apps/pubs/default.aspx?id=66814">PacificA</a>是微信用于实现基于日志的存储系统的通用框架。</li>
<li><a href = "http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/spanner-osdi2012.pdf">Spanner</a>——并不是每个人都喜欢把逻辑时间用于他们的日志。谷歌的最新的数据库学工使用物理时间，并通过把时间戳直接作为区间来直接对时间漂移的不确定性进行建模。</li>
<li><a href = "http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/spanner-osdi2012.pdf">Datanomic</a>：<a href = "https://www.youtube.com/watch?v=Cym4TZwTCNU">解构数据库</a>是Rich Hicky（Clojure的创建者）在它的首个数据库产品的重要陈述。</li>
<li><a href = "http://www.cs.utexas.edu/~lorenzo/papers/SurveyFinal.pdf">在消息传递系统中对方回滚和恢复的调查</a>，我发现这是错误容忍的非常有帮忙的介绍，也是通过日志恢复外部数据库的实际应用的不错的介绍。</li>
<li><a href = "http://www.reactivemanifesto.org/">反应式宣言</a>。我其实并不清楚反应式编程的确切涵义，但是我想它和“事件驱动”指的是同一件事。 这个链接并没有太多的信息，但 Martin Odersky （Scala大拿）讲授的这个课程很精彩。</li>
<li>Paxos!<ul>
<li>原论文在<a href = "http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf">这里</a>。关于作者 Leslie Lamport 发表的这篇论文有个有趣的<a href = "http://research.microsoft.com/en-us/um/people/lamport/pubs/pubs.html#lamport-paxos">历史</a>：他在80年代就发明了这个算法，但直到1998年才发表出论文，原因是评审组不喜欢论文中的希腊寓言，而他又不愿修改。</li>
<li>甚至于论文发布以后，人们还是不怎么理解。Lamport <a href = "http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf">再次尝试</a>，这次甚至包含了一些关于如何在新型自动化计算机上使用的“无趣的细节”。 但算法仍然没有得到广泛的理解。</li>
<li><a hef = "http://www.cs.cornell.edu/fbs/publications/SMSurvey.pdf">Fred Schneider</a>和<a href = "http://research.microsoft.com/en-us/um/people/blampson/58-consensus/Abstract.html">Butler Lampson</a>分别给出了更多细节关于在实时系统中如何应用Paxos。</li>
<li>一些谷歌的工程师总结了他们在Chubby中实现Paxos的<a href = "http://www.cs.utexas.edu/users/lorenzo/corsi/cs380d/papers/paper2-1.pdf">经验</a>。</li>
<li>我发现所有关于Paxos的论文理解起来很痛苦，但是值得我们费大力气弄懂。你不必忍受这样的痛苦了，因为日志结构的文件系统的大师<a href = "http://www.stanford.edu/~ouster/cgi-bin/papers/lfs.pdf">John Ousterhout</a>的<a href = "https://www.youtube.com/watch?v=JEpsBg0AO6o">这个视频 </a>让这一切变得相当的容易。这些一致性算法用展开的通信图表述的更好，而不是在论文中通过静态的描述来说明。颇为讽刺的是，这个视频录制的初衷是告诉人们Paxos很难理解。</li>
<li><a href = "http://arxiv.org/pdf/1103.2408.pdf">使用Paxos来构造规模一致的数据存储</a>。这是一篇很棒的介绍使用日志来构造数据存储的文章，<em>Jun</em> 是文章的共同作者之一，他也是<code>Kafka</code>最早期的工程师之一。</li>
</ul>
</li>
<li>Paxos有很多的竞争者。以下可以更进一步的映射到日志的实施，更适合于实用性的实施。<ul>
<li>由 Barbara Liskov 提出的<a href = "http://pmg.csail.mit.edu/papers/vr-revisited.pdf">视图戳复制</a>是直接进行日志复制建模的较早的算法。</li>
<li><a href = "http://www.stanford.edu/class/cs347/reading/zab.pdf">Zab</a>是Zookeeper所使用的算法。</li>
<li><a href = "http://www.stanford.edu/class/cs347/reading/zab.pdf">RAFT</a>是易于理解的一致性算法之一。由John Ousterhout讲授的这个&lt;a href = “ <a href = "https://www.youtube.com/watch?v=YbZ3zDzDnrw">“&gt;视频</a>非常的棒。</li>
</ul>
</li>
<li>你可以的看到在不同的实时分布式数据库中动作日志角色：<ul>
<li><a href = "">PNUTS</a>是探索在大规模的传统的分布式数据库系统中实施以日志为中心设计理念的系统。</li>
<li><a href = "http://hbase.apache.org/">Hbase</a>和<a href = "http://research.google.com/archive/bigtable.html">Bigtable</a>都是在目前的数据库系统中使用日志的样例。</li>
<li>LinkedIn自己的分布式数据库<a href = "http://www.slideshare.net/amywtang/espresso-20952131">Espresso</a>和PNUTs一样，使用日志来复制，但有一个小的差异是它使用自己底层的表做为日志的来源。</li>
</ul>
</li>
<li>如果你正在做一致性算法选型，<a href = "http://arxiv.org/abs/1309.5671">这篇论文</a>会对你所有帮助。</li>
<li><a href = "http://www.amazon.com/Replication-Practice-Lecture-Computer-Theoretical/dp/3642112935">复制：理论与实践</a>，这是收录了分布式系统一致性的大量论文的一本巨著。网上有该书的诸多章节（<a href = "http://disi.unitn.it/~montreso/ds/papers/replication.pdf">1</a>，<a href = "http://research.microsoft.com/en-us/people/aguilera/stumbling-chapter.pdf">4</a>，<a href = "http://www.distributed-systems.net/papers/2010.verita.pdf">5</a>，<a href = "http://www.cs.cornell.edu/ken/history.pdf">6</a>，<a href = "http://www.pmg.csail.mit.edu/papers/vr-to-bft.pdf">7</a>，<a href = "http://engineering.linkedin.com/distributed-systems/www.cs.cornell.edu/fbs/publications/TrustSurveyTR.pdf">8</a>）。</li>
<li>流处理。这总结起来太广泛了，以下是一些我喜欢的：<ul>
<li><a href = "http://infolab.usc.edu/csci599/Fall2002/paper/DML2_streams-issues.pdf">在数据流系统中建模和相关事件</a>：它可能是研究这一领域的最佳概述之一。</li>
<li><a href = "http://cs.brown.edu/research/aurora/hwang.icde05.ha.pdf">分布式处理流的高可用算法</a></li>
<li>一些比较散的论文：<ul>
<li><a href = "http://db.cs.berkeley.edu/papers/cidr03-tcq.pdf">TelegraphCQ</a></li>
<li><a href = "http://cs.brown.edu/research/aurora/vldb03_journal.pdf">Aurora</a></li>
<li><a href = "http://research.cs.wisc.edu/niagara/papers/NiagaraCQ.pdf">NiagaraCQ</a></li>
<li><a href = "http://www.cs.berkeley.edu/~matei/papers/2012/hotcloud_spark_streaming.pdf">离散流</a>：这篇论文讨论了Spark的流系统。</li>
<li><a href = "http://research.google.com/pubs/pub41378.html">MillWheel</a>是谷歌的流处理系统之一。</li>
<li><a href = "http://research.microsoft.com/apps/pubs/?id=201100">Naiad</a>：一个时间数据流系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>企业级软件有着同样的问题除了名称不一样、更小的规模、XML。哈，开个玩笑：</p>
<ul>
<li><a href = "http://martinfowler.com/eaaDev/EventSourcing.html">事件溯源</a>：据我所知，这基本是企业软件工程师说“状态机复制“的方式。很有趣的一点是，同样的想法在不同的情景中被又一次发明出来。事件溯源似乎聚集于更小的、在内存中的用例。这种应用开发的方式似乎是将出现在事件日志中的流处理和应用结合起来。当处理足够大而需要数据分区进行扩容时，这变得相当复杂，我重点关注于流处理作为一个独立的原始的基础设施这一方面。</li>
<li><a href = "http://en.wikipedia.org/wiki/Change_data_capture">变更数据捕获</a>：这是围绕从数据库获取数据的一个小产品，这也是数据提取的最友好的日志风格。</li>
<li><a href = "http://en.wikipedia.org/wiki/Enterprise_application_integration">企业应用集成</a>似乎在解决数据集成问题，当你有像CRM或者供应链管理软件的企业软件时。</li>
<li><a href = "http://en.wikipedia.org/wiki/Complex_event_processing">复杂的事件处理</a>：相当肯定的是没有人知道这是什么，它是怎么区别于流处理的。不同之处似乎是关注点在于无序流、事件过滤和发现，而不是聚合上，但在我看来，区别并不明显。我认为任何系统都有其优秀的地方。</li>
<li><a href = "http://en.wikipedia.org/wiki/Enterprise_service_bus">企业服务总线</a>：我认为企业服务总线的概念跟我在数据集成描述的非常相似。这个理念似乎在企业软件社区中取得了一定的成功，但在Web开发人员或分布式数据基础设施人群中鲜为人知。</li>
</ul>
<p>有趣的开源组件：</p>
<ul>
<li><a href = "http://kafka.apache.org/">Kafka</a>是”日志即服务“的项目，是这篇文章的基础。</li>
<li><a href = "http://kafka.apache.org/">Bookeeper</a>和<a href = "https://cwiki.apache.org/confluence/display/BOOKKEEPER/HedWig">Hedwig</a>是”日志即服务“的另外的开源组件。它们似乎致力于数据系统内部，而不是事件数据。</li>
<li><a href = "https://github.com/linkedin/databus">数据总线</a>是为数据库表提供了类似日志层的系统。</li>
<li><a href = "http://akka.io/">Akka</a>是一个Scala的Actor框架，它有一个插件，事件溯源，提供了持久化和记录的功能。</li>
<li><a href = "http://samza.incubator.apache.org/">Samza</a>是一个我们在领英工作中使用的流处理框架。它使用了这篇文章中大量的理念，也集成了Kafka作为底层日志。</li>
<li><a href = "http://samza.incubator.apache.org/">Storm</a>是一个流处理框架，可以很好的跟Kafka集成。</li>
<li><a href = "http://spark.incubator.apache.org/docs/0.7.3/streaming-programming-guide.html">Spark Streaming</a>是Spark中的流处理框架。</li>
<li><a href = "http://spark.incubator.apache.org/docs/0.7.3/streaming-programming-guide.html">Summingbird</a>是在Storm和Hadoop上提供了方便的计算抽象。</li>
</ul>
<p>我们持续关注这一领域，如果我有一些遗漏的地方，请告知。</p>
<p>最后我给你留下的信息是：<a href = "https://youtu.be/2C7mNr5WMjA">视频</a></p>
]]></content>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo源码学习：服务调用过程</title>
    <url>/2024/10/26/Dubbo%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>在之前的文章中，我们了解到了 Dubbo 服务导出和服务引用的过程。本篇文章一起来看下服务远程调用的过程。</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Dubbo 2.7.12版本</p>
</blockquote>
<h3 id="服务消费端"><a href="#服务消费端" class="headerlink" title="服务消费端"></a>服务消费端</h3><p>在服务引用一篇中，我们了解到服务引用对象是通过动态代理对象生成的，而远程调用也通过该代理对象发起：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxy0</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ClassGenerator</span>.<span class="title">DC</span>,</span></span><br><span class="line"><span class="class"><span class="title">EchoService</span>,</span></span><br><span class="line"><span class="class"><span class="title">Destroyable</span>,</span></span><br><span class="line"><span class="class"><span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method[] methods;</span><br><span class="line">    <span class="keyword">private</span> InvocationHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object $echo(Object object) &#123;</span><br><span class="line">        Object[] objectArray = <span class="keyword">new</span> Object[]&#123;object&#125;;</span><br><span class="line">        Object object2 = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], objectArray);</span><br><span class="line">        <span class="keyword">return</span> object2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object[] objectArray = <span class="keyword">new</span> Object[]&#123;&#125;;</span><br><span class="line">        Object object = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">1</span>], objectArray);</span><br><span class="line">        <span class="keyword">return</span> (String)object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> $destroy() &#123;</span><br><span class="line">        Object[] objectArray = <span class="keyword">new</span> Object[]&#123;&#125;;</span><br><span class="line">        Object object = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">2</span>], objectArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">(InvocationHandler invocationHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = invocationHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代理类实现了服务提供接口的方法，并将请求都转发到了 <strong>InvocationHandler#invoke</strong> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//Object方法直接本地调用</span></span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(invoker, args);</span><br><span class="line">    &#125;</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">    <span class="comment">//toString、hashCode、equals方法直接本地调用</span></span><br><span class="line">    <span class="keyword">if</span> (parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.toString();</span><br><span class="line">            <span class="comment">//$destroy方法销毁当前invoker</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;$destroy&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">            invoker.destroy();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span> &amp;&amp; <span class="string">&quot;equals&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invoker.equals(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将方法及参数封装为RpcInvocation</span></span><br><span class="line">    RpcInvocation rpcInvocation = <span class="keyword">new</span> RpcInvocation(method, invoker.getInterface().getName(), protocolServiceKey, args);</span><br><span class="line">    String serviceKey = invoker.getUrl().getServiceKey();</span><br><span class="line">    rpcInvocation.setTargetServiceUniqueName(serviceKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoker.getUrl() returns consumer url.</span></span><br><span class="line">    RpcContext.setRpcContext(invoker.getUrl());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (consumerModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        rpcInvocation.put(Constants.CONSUMER_MODEL, consumerModel);</span><br><span class="line">        rpcInvocation.put(Constants.METHOD_MODEL, consumerModel.getMethodModel(method));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//调用invoker的invoker此处invoker类型为MigrationInvoker</span></span><br><span class="line">    <span class="keyword">return</span> invoker.invoke(rpcInvocation).recreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里针对一些不需要远程调用的一些方法，使用本地调用。继续来到 <strong>MigrationInvoker#invoke</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">	<span class="comment">//检查应用级服务invoker是否可用，不可用时使用接口级服务发现invoker</span></span><br><span class="line">    <span class="keyword">if</span> (!checkInvokerAvailable(serviceDiscoveryInvoker)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Using interface addresses to handle invocation, interface &quot;</span> + type.getName() + <span class="string">&quot;, total address size &quot;</span> + (invoker.getDirectory().getAllInvokers() == <span class="keyword">null</span> ? <span class="string">&quot;is null&quot;</span> : invoker.getDirectory().getAllInvokers().size()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//invoker类型为MockClusterInvoker</span></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (!checkInvokerAvailable(invoker)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Using instance addresses to handle invocation, interface &quot;</span> + type.getName() + <span class="string">&quot;, total address size &quot;</span> + (serviceDiscoveryInvoker.getDirectory().getAllInvokers() == <span class="keyword">null</span> ? <span class="string">&quot; is null &quot;</span> : serviceDiscoveryInvoker.getDirectory().getAllInvokers().size()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serviceDiscoveryInvoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentAvailableInvoker.invoke(invocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将优先使用应用级服务发现invoker，应用级服务发现invoker不可用时则使用接口级服务发现invoker。来到 <strong>MockClusterInvoker#invoke</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    Result result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取mock参数</span></span><br><span class="line">    String value = getUrl().getMethodParameter(invocation.getMethodName(), MOCK_KEY, Boolean.FALSE.toString()).trim();</span><br><span class="line">    <span class="keyword">if</span> (value.length() == <span class="number">0</span> || <span class="string">&quot;false&quot;</span>.equalsIgnoreCase(value)) &#123;</span><br><span class="line">        <span class="comment">//mock参数未配置或为false时，转发请求至内部 invoker，此时 invoker 类型为 InterceptorInvokerNode</span></span><br><span class="line">        result = <span class="keyword">this</span>.invoker.invoke(invocation);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.startsWith(<span class="string">&quot;force&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;force-mock: &quot;</span> + invocation.getMethodName() + <span class="string">&quot; force-mock enabled , url : &quot;</span> + getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//mock值为force，则强制走mock处理逻辑</span></span><br><span class="line">        result = doMockInvoke(invocation, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//fail-mock</span></span><br><span class="line">        <span class="comment">//mock值为fail时，则调用内部invoker，并在异常时进行mock处理</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = <span class="keyword">this</span>.invoker.invoke(invocation);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//fix:#4585</span></span><br><span class="line">            <span class="comment">//区分是业务异常，或者Rpc异常，业务异常则不走mock处理</span></span><br><span class="line">            <span class="keyword">if</span>(result.getException() != <span class="keyword">null</span> &amp;&amp; result.getException() <span class="keyword">instanceof</span> RpcException)&#123;</span><br><span class="line">                RpcException rpcException= (RpcException)result.getException();</span><br><span class="line">                <span class="keyword">if</span>(rpcException.isBiz())&#123;</span><br><span class="line">                    <span class="keyword">throw</span>  rpcException;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    result = doMockInvoke(invocation, rpcException);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.isBiz()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;fail-mock: &quot;</span> + invocation.getMethodName() + <span class="string">&quot; fail-mock enabled , url : &quot;</span> + getUrl(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            result = doMockInvoke(invocation, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里出现了mock参数的判断及处理，有3各取值情况（false、force、fail），这其实是Dubbo远程调用的mock机制，通过它我们可以实现服务降级，或者用于测试过程中的模拟调用。具体的doMockInvoke实现处理，不在这里具体展开。继续来到 <strong>AbstractCluster.InterceptorInvokerNode#invoke</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    Result asyncResult;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//cluster拦截器的前置处理，此处类型默认为ConsumerContextClusterInterceptor</span></span><br><span class="line">        interceptor.before(next, invocation);</span><br><span class="line">        <span class="comment">//拦截并执行目标方法</span></span><br><span class="line">        asyncResult = interceptor.intercept(next, invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// onError callback</span></span><br><span class="line">        <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> ClusterInterceptor.Listener) &#123;</span><br><span class="line">            ClusterInterceptor.Listener listener = (ClusterInterceptor.Listener) interceptor;</span><br><span class="line">            listener.onError(e, clusterInvoker, invocation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//拦截器的后置处理</span></span><br><span class="line">        interceptor.after(next, invocation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> asyncResult.whenCompleteWithContext((r, t) -&gt; &#123;</span><br><span class="line">        <span class="comment">// onResponse callback</span></span><br><span class="line">        <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> ClusterInterceptor.Listener) &#123;</span><br><span class="line">            ClusterInterceptor.Listener listener = (ClusterInterceptor.Listener) interceptor;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                listener.onMessage(r, clusterInvoker, invocation);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                listener.onError(t, clusterInvoker, invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是ClusterInterceptor的处理：</p>
<ol>
<li>调用 ClusterInterceptor 的前置处理；</li>
<li>调用 ClusterInterceptor 的 intercept 方法，该方法将调用 AbstractClusterInvoker 的 invoke 方法；</li>
<li>调用 ClusterInterceptor 的后置处理。</li>
</ol>
<p>来到 <strong>AbstractClusterInvoker#invoke</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    checkWhetherDestroyed();</span><br><span class="line">	<span class="comment">// 绑定attachments到 invocation</span></span><br><span class="line">    <span class="comment">// binding attachments into invocation.</span></span><br><span class="line">    Map&lt;String, Object&gt; contextAttachments = RpcContext.getContext().getObjectAttachments();</span><br><span class="line">    <span class="keyword">if</span> (contextAttachments != <span class="keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        ((RpcInvocation) invocation).addObjectAttachments(contextAttachments);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 获取invoker列表</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class="line">    <span class="comment">// 获取负载均衡器，默认为 RandomLoadBalance </span></span><br><span class="line">    LoadBalance loadbalance = initLoadBalance(invokers, invocation);</span><br><span class="line">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line">    <span class="comment">// doInvoke</span></span><br><span class="line">    <span class="keyword">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将attachments参数 添加到 invocation，并通过 Directory#list 方法获取 invoker 列表，以及加载并获取负载均衡器，最后调用 <strong>FailoverClusterInvoker#doInvoke</strong> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; copyInvokers = invokers;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    checkInvokers(copyInvokers, invocation);</span><br><span class="line">    String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">    <span class="comment">// 获取重试次数</span></span><br><span class="line">    <span class="keyword">int</span> len = calculateInvokeTimes(methodName);</span><br><span class="line">    <span class="comment">// retry loop.</span></span><br><span class="line">    RpcException le = <span class="keyword">null</span>; <span class="comment">// last exception.</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size()); <span class="comment">// invoked invokers.</span></span><br><span class="line">    Set&lt;String&gt; providers = <span class="keyword">new</span> HashSet&lt;String&gt;(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">//Reselect before retry to avoid a change of candidate `invokers`.</span></span><br><span class="line">        <span class="comment">//<span class="doctag">NOTE:</span> if `invokers` changed, then `invoked` also lose accuracy.</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 在重试时，重新获取一次最新的 invoker 列表，一定程度上确保可用</span></span><br><span class="line">            checkWhetherDestroyed();</span><br><span class="line">            copyInvokers = list(invocation);</span><br><span class="line">            <span class="comment">// check again</span></span><br><span class="line">            checkInvokers(copyInvokers, invocation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过负载均衡器选中 invoker</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked);</span><br><span class="line">        <span class="comment">// 记录调用过的invoker 列表</span></span><br><span class="line">        invoked.add(invoker);</span><br><span class="line">        RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用目标invoker</span></span><br><span class="line">            Result result = invoker.invoke(invocation);</span><br><span class="line">            <span class="keyword">if</span> (le != <span class="keyword">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            <span class="comment">// 业务异常不进行重试</span></span><br><span class="line">            <span class="keyword">if</span> (e.isBiz()) &#123; <span class="comment">// biz exception.</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            le = e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            le = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            providers.add(invoker.getUrl().getAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在该方法中，首先获取重试次数，以在调用 invoker 失败的时候进行重试操作，在选中具体的 invoker 实例时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(LoadBalance loadbalance, Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                            List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String methodName = invocation == <span class="keyword">null</span> ? StringUtils.EMPTY_STRING : invocation.getMethodName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否粘滞调用</span></span><br><span class="line">    <span class="keyword">boolean</span> sticky = invokers.get(<span class="number">0</span>).getUrl()</span><br><span class="line">            .getMethodParameter(methodName, CLUSTER_STICKY_KEY, DEFAULT_CLUSTER_STICKY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ignore overloaded method</span></span><br><span class="line">    <span class="comment">// stickyInvoker 不可用时置空</span></span><br><span class="line">    <span class="keyword">if</span> (stickyInvoker != <span class="keyword">null</span> &amp;&amp; !invokers.contains(stickyInvoker)) &#123;</span><br><span class="line">        stickyInvoker = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ignore concurrency problem</span></span><br><span class="line">    <span class="comment">// 开启了粘滞调用，并且 stickyInvoker 不为空时，如果之前没尝试调用过该 stickyInvoker，则检查是否可用，可用则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (sticky &amp;&amp; stickyInvoker != <span class="keyword">null</span> &amp;&amp; (selected == <span class="keyword">null</span> || !selected.contains(stickyInvoker))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (availablecheck &amp;&amp; stickyInvoker.isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">return</span> stickyInvoker;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Invoker&lt;T&gt; invoker = doSelect(loadbalance, invocation, invokers, selected);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将选中 invoker 赋值为 stickyInvoker</span></span><br><span class="line">    <span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">        stickyInvoker = invoker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里包含了粘滞调用的处理，粘滞调用是指消费端在确保 invoker 可用时，将尽可能使用同一个 invoker 进行调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(LoadBalance loadbalance, Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                            List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过 loadbalance 选择 invoker 实例</span></span><br><span class="line">    Invoker&lt;T&gt; invoker = loadbalance.select(invokers, getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//If the `invoker` is in the  `selected` or invoker is unavailable &amp;&amp; availablecheck is true, reselect.</span></span><br><span class="line">    <span class="keyword">if</span> ((selected != <span class="keyword">null</span> &amp;&amp; selected.contains(invoker))</span><br><span class="line">            || (!invoker.isAvailable() &amp;&amp; getUrl() != <span class="keyword">null</span> &amp;&amp; availablecheck)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果选中 invoker 实例不可用，则进行重选</span></span><br><span class="line">            Invoker&lt;T&gt; rInvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);</span><br><span class="line">            <span class="keyword">if</span> (rInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                invoker = rInvoker;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//Check the index of current selected invoker, if it&#x27;s not the last one, choose the one at index+1.</span></span><br><span class="line">                <span class="keyword">int</span> index = invokers.indexOf(invoker);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//Avoid collision</span></span><br><span class="line">                    invoker = invokers.get((index + <span class="number">1</span>) % invokers.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.warn(e.getMessage() + <span class="string">&quot; may because invokers list dynamic change, ignore.&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;cluster reselect fail reason is :&quot;</span> + t.getMessage() + <span class="string">&quot; if can not solve, you can set cluster.availablecheck=false in url&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要做了两件事：</p>
<ol>
<li><p>通过 LoadBalance 选择 invoker 实例；</p>
</li>
<li><p>如果选出来的 invoker 不可用，则使用 reselect 进行重选。</p>
</li>
</ol>
<p>在选中 invoker 实例后，回到 <strong>FailoverClusterInvoker#doInvoke</strong> ，将进行 invoker 的调用。在经过Dubbo Filter链的调用后，来到<strong>AsyncToSyncInvoker</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">    Result asyncResult &#x3D; invoker.invoke(invocation);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是同步调用，则阻塞等待结果</span><br><span class="line">        if (InvokeMode.SYNC &#x3D;&#x3D; ((RpcInvocation) invocation).getInvokeMode()) &#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * NOTICE!</span><br><span class="line">             * must call &#123;@link java.util.concurrent.CompletableFuture#get(long, TimeUnit)&#125; because</span><br><span class="line">             * &#123;@link java.util.concurrent.CompletableFuture#get()&#125; was proved to have serious performance drop.</span><br><span class="line">             *&#x2F;</span><br><span class="line">            asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RpcException(&quot;Interrupted unexpectedly while waiting for remote result to return!  method: &quot; +</span><br><span class="line">                invocation.getMethodName() + &quot;, provider: &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">    &#125; catch (ExecutionException e) &#123;</span><br><span class="line">       &#x2F;&#x2F;...</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        throw new RpcException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    return asyncResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个将异步调用转换为同步调用的 Invoker ，值得注意的是，在 Dubbo 中的远程调用都是以异步方式进行调用的。</p>
<p>来到 DubboInvoker ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation inv)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// if invoker is destroyed due to address refresh from registry, let&#x27;s allow the current invoke to proceed</span></span><br><span class="line">    <span class="keyword">if</span> (destroyed.get()) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    RpcInvocation invocation = (RpcInvocation) inv;</span><br><span class="line">    invocation.setInvoker(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmptyMap(attachment)) &#123;</span><br><span class="line">        invocation.addObjectAttachmentsIfAbsent(attachment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置attachment</span></span><br><span class="line">    Map&lt;String, Object&gt; contextAttachments = RpcContext.getContext().getObjectAttachments();</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmptyMap(contextAttachments)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * invocation.addAttachmentsIfAbsent(context)&#123;<span class="doctag">@link</span> RpcInvocation#addAttachmentsIfAbsent(Map)&#125;should not be used here,</span></span><br><span class="line"><span class="comment">         * because the &#123;<span class="doctag">@link</span> RpcContext#setAttachment(String, String)&#125; is passed in the Filter when the call is triggered</span></span><br><span class="line"><span class="comment">         * by the built-in retry mechanism of the Dubbo. The attachment to update RpcContext will no longer work, which is</span></span><br><span class="line"><span class="comment">         * a mistake in most cases (for example, through Filter to RpcContext output traceId and spanId and other information).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        invocation.addObjectAttachments(contextAttachments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation));</span><br><span class="line">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">    Byte serializationId = CodecSupport.getIDByName(getUrl().getParameter(SERIALIZATION_KEY, DEFAULT_REMOTING_SERIALIZATION));</span><br><span class="line">    <span class="keyword">if</span> (serializationId != <span class="keyword">null</span>) &#123;</span><br><span class="line">        invocation.put(SERIALIZATION_ID_KEY, serializationId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AsyncRpcResult asyncResult;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用Dubbo#doInvoke</span></span><br><span class="line">        asyncResult = (AsyncRpcResult) doInvoke(invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123; <span class="comment">// biz exception</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e, invocation);</span><br><span class="line">    &#125;</span><br><span class="line">    RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter(asyncResult.getResponseFuture()));</span><br><span class="line">    <span class="keyword">return</span> asyncResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是将 attachment 信息添加到 invocation ，然后来到 <strong>DubboInvoker#doInvoke</strong> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line">    <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">    <span class="comment">//设置path 和版本信息到attachment中</span></span><br><span class="line">    inv.setAttachment(PATH_KEY, getUrl().getPath());</span><br><span class="line">    inv.setAttachment(VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取客户端连接实例</span></span><br><span class="line">    ExchangeClient currentClient;</span><br><span class="line">    <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">        currentClient = clients[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//轮询获取一个客户端</span></span><br><span class="line">        currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//是否单向通信</span></span><br><span class="line">        <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">        <span class="keyword">int</span> timeout = calculateTimeout(invocation, methodName);</span><br><span class="line">        invocation.put(TIMEOUT_KEY, timeout);</span><br><span class="line">        <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 单身通信时忽略返回结果</span></span><br><span class="line">            currentClient.send(inv, isSent);</span><br><span class="line">            <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(invocation);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 默认异步调用，返回异步结果</span></span><br><span class="line">            ExecutorService executor = getCallbackExecutor(getUrl(), inv);</span><br><span class="line">            <span class="comment">// 发起请求</span></span><br><span class="line">            CompletableFuture&lt;AppResponse&gt; appResponseFuture =</span><br><span class="line">                    currentClient.request(inv, timeout, executor).thenApply(obj -&gt; (AppResponse) obj);</span><br><span class="line">            <span class="comment">// save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter</span></span><br><span class="line">            FutureContext.getContext().setCompatibleFuture(appResponseFuture);</span><br><span class="line">            AsyncRpcResult result = <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, inv);</span><br><span class="line">            result.setExecutor(executor);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先以轮询的方式获取到客户端，然后发起远程请求，结合 <strong>AsyncToSyncInvoker</strong> 的处理逻辑可以看出，在非单向调用的情况下，Dubbo 的调用返回结果都是异步结果，对于同步的调用，调用结果由内部 <strong>AsyncToSyncInvoker</strong>  阻塞并获取调用结果返回，而对于异步调用则返回 <strong>AsyncRpcResult</strong> ，最终结果的获取时机则交由用户决定。</p>
<p>来到请求的发起，<strong>HeaderExchangeChannel#request</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Object&gt; <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout, ExecutorService executor)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>,</span><br><span class="line">                <span class="string">&quot;Failed to send request &quot;</span> + request + <span class="string">&quot;, cause: The channel &quot;</span> + <span class="keyword">this</span> + <span class="string">&quot; is closed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// create request.</span></span><br><span class="line">    <span class="comment">// 构建Request对象</span></span><br><span class="line">    Request req = <span class="keyword">new</span> Request();</span><br><span class="line">    req.setVersion(Version.getProtocolVersion());</span><br><span class="line">    req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">    req.setData(request);</span><br><span class="line">    <span class="comment">// 构建DefaultFuture</span></span><br><span class="line">    DefaultFuture future = DefaultFuture.newFuture(channel, req, timeout, executor);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用 NettyClient 发送请求</span></span><br><span class="line">        channel.send(req);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        future.cancel();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是构建 <strong>Request</strong> 请求对象，然后通过 <strong>DefaultFuture#newFuture</strong>  构造一个 <strong>DefaultFuture</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DefaultFuture <span class="title">newFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout, ExecutorService executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, request, timeout);</span><br><span class="line">    future.setExecutor(executor);</span><br><span class="line">    <span class="comment">// ThreadlessExecutor needs to hold the waiting future in case of circuit return.</span></span><br><span class="line">    <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">        ((ThreadlessExecutor) executor).setWaitingFuture(future);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// timeout check</span></span><br><span class="line">    timeoutCheck(future);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DefaultFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    <span class="keyword">this</span>.request = request;</span><br><span class="line">    <span class="comment">//获取请求 id</span></span><br><span class="line">    <span class="keyword">this</span>.id = request.getId();</span><br><span class="line">    <span class="keyword">this</span>.timeout = timeout &gt; <span class="number">0</span> ? timeout : channel.getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);</span><br><span class="line">    <span class="comment">// put into waiting map.</span></span><br><span class="line">    <span class="comment">//存储 &lt;请求id, DefaultFuture&gt;的映射关系到 FUTURES 中</span></span><br><span class="line">    FUTURES.put(id, <span class="keyword">this</span>);</span><br><span class="line">    CHANNELS.put(id, channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <strong>DefaultFuture</strong> 的构造函数中，可以看到，在 DefaultFuture 中，维护了 <strong>请求id -&gt;DefaultFuture</strong> 的映射关系，而这个是 Dubbo 实现异步的关键。</p>
<p>当该次调用接收到结果时，通过这个映射关系可以直接找到 <strong>DefaultFuture</strong> 对象，然后将调用结果填充回去，整个异步调用的请和结果的关联在此处得以体现，<strong>DefaultFuture#received</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response, <span class="keyword">boolean</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DefaultFuture future = FUTURES.remove(response.getId());</span><br><span class="line">        <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Timeout t = future.timeoutCheckTask;</span><br><span class="line">            <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">                <span class="comment">// decrease Time</span></span><br><span class="line">                t.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">            future.doReceived(response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        CHANNELS.remove(response.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>拿到 Request 请求对象后，最后发送请求，Dubbo 默认使用 Netty作为底层通信框架，此时 channel 实例类型为 NettyClient ，即通过 <strong>NettyClient#send</strong> 方法发送请求，后续就是根据 Dubbo 协议对该请求对象进行编码然后将请求发送出去。</p>
<p>关于 Dubbo消费端请求的发起调用，本篇就简单看到这里，这里附上一个调用的关键路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InvokerInvocationHandler#invoke</span><br><span class="line">MigrationInvoker#invoke</span><br><span class="line">MockClusterInvoker#invoke</span><br><span class="line">AbstractCluster$InterceptorInvokerNode#invoke</span><br><span class="line">(ConsumerContextClusterInterceptor)ClusterInterceptor#intercept</span><br><span class="line">AbstractClusterInvoker#invoke -&gt; FailoverClusterInvoker#doInvoke</span><br><span class="line">FilterNode#invoke（Filter链执行）</span><br><span class="line">AsyncToSyncInvoker#invoke</span><br><span class="line">AbstractInvoker#invoke -&gt; DubboInvoker#invoke</span><br><span class="line">ReferenceCountExchangeClient#request</span><br><span class="line">HeaderExchangeClient#request</span><br><span class="line">HeaderExchangeChannel#request</span><br><span class="line">NettyClient#send</span><br></pre></td></tr></table></figure>



<h3 id="服务提供端"><a href="#服务提供端" class="headerlink" title="服务提供端"></a>服务提供端</h3><p>前面我们提到，Dubbo 使用 Netty 作为底层通信框架，当 Netty 接收到新请求后，首先会根据 Dubbo 协议通过解码器进行 <strong>Request</strong> 请求对象的解码，在得到 Request 请求对象后，接着便是调用服务了，我们直接看下 <strong>ChannelEventRunnable#run</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理接收事件，包括请求和响应事件</span></span><br><span class="line">    <span class="keyword">if</span> (state == ChannelState.RECEIVED) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler.received(channel, message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;ChannelEventRunnable handle &quot;</span> + state + <span class="string">&quot; operation error, channel is &quot;</span> + channel</span><br><span class="line">                    + <span class="string">&quot;, message is &quot;</span> + message, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="comment">//处理建立连接事件</span></span><br><span class="line">        <span class="keyword">case</span> CONNECTED:</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                handler.connected(channel);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;ChannelEventRunnable handle &quot;</span> + state + <span class="string">&quot; operation error, channel is &quot;</span> + channel, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//处理断开连接事件</span></span><br><span class="line">        <span class="keyword">case</span> DISCONNECTED:</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                handler.disconnected(channel);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;ChannelEventRunnable handle &quot;</span> + state + <span class="string">&quot; operation error, channel is &quot;</span> + channel, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//处理发送事件</span></span><br><span class="line">        <span class="keyword">case</span> SENT:</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                handler.sent(channel, message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;ChannelEventRunnable handle &quot;</span> + state + <span class="string">&quot; operation error, channel is &quot;</span> + channel</span><br><span class="line">                        + <span class="string">&quot;, message is &quot;</span> + message, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//异常捕获</span></span><br><span class="line">        <span class="keyword">case</span> CAUGHT:</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                handler.caught(channel, exception);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;ChannelEventRunnable handle &quot;</span> + state + <span class="string">&quot; operation error, channel is &quot;</span> + channel</span><br><span class="line">                        + <span class="string">&quot;, message is: &quot;</span> + message + <span class="string">&quot;, exception is &quot;</span> + exception, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            logger.warn(<span class="string">&quot;unknown state: &quot;</span> + state + <span class="string">&quot;, message is &quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里针对不同类型的事件，调用 <strong>DecodeHandler</strong> 的不同方法，对于接收请求，则来到 <strong>DecodeHandler#received</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Decodeable) &#123;</span><br><span class="line">        <span class="comment">// 对 Decodeable 对象进行解码</span></span><br><span class="line">        decode(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">        <span class="comment">// 对 Request 对象的 data 进行解码</span></span><br><span class="line">        decode(((Request) message).getData());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">        <span class="comment">// 对 Response 的 result 进行解码</span></span><br><span class="line">        decode(((Response) message).getResult());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handler.received(channel, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解码后， Request 对象传递到 <strong>HeaderExchangeHandler#received</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">        <span class="comment">// 处理请求对象</span></span><br><span class="line">        Request request = (Request) message;</span><br><span class="line">        <span class="keyword">if</span> (request.isEvent()) &#123;</span><br><span class="line">            <span class="comment">// 处理事件</span></span><br><span class="line">            handlerEvent(channel, request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 双向通信</span></span><br><span class="line">            <span class="keyword">if</span> (request.isTwoWay()) &#123;</span><br><span class="line">                handleRequest(exchangeChannel, request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 单向通信时，直接调用 handler 处理，忽略响应</span></span><br><span class="line">                handler.received(exchangeChannel, request.getData());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 处理响应请求</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">        handleResponse(channel, (Response) message);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isClientSide(channel)) &#123;</span><br><span class="line">            Exception e = <span class="keyword">new</span> Exception(<span class="string">&quot;Dubbo client can not supported string message: &quot;</span> + message + <span class="string">&quot; in channel: &quot;</span> + channel + <span class="string">&quot;, url: &quot;</span> + channel.getUrl());</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String echo = handler.telnet(channel, (String) message);</span><br><span class="line">            <span class="keyword">if</span> (echo != <span class="keyword">null</span> &amp;&amp; echo.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                channel.send(echo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler.received(exchangeChannel, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里区分了双向通信和单向通信，对于双向通信，则先来到 <strong>HeaderExchangeHandler#handleRequest</strong> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> ExchangeChannel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">    <span class="comment">//检测请求是否合法，非法则返回 BAD_REQUEST</span></span><br><span class="line">    <span class="keyword">if</span> (req.isBroken()) &#123;</span><br><span class="line">        Object data = req.getData();</span><br><span class="line"></span><br><span class="line">        String msg;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            msg = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data <span class="keyword">instanceof</span> Throwable) &#123;</span><br><span class="line">            msg = StringUtils.toString((Throwable) data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg = data.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        res.setErrorMessage(<span class="string">&quot;Fail to decode request due to: &quot;</span> + msg);</span><br><span class="line">        res.setStatus(Response.BAD_REQUEST);</span><br><span class="line"></span><br><span class="line">        channel.send(res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 data 信息，也就是 RpcInvocation 对象</span></span><br><span class="line">    Object msg = req.getData();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 继续传递，ExchangeHandlerAdapter#reply ，该实现类为 DubboProtocol 内部匿名实现类对象</span></span><br><span class="line">        CompletionStage&lt;Object&gt; future = handler.reply(channel, msg);</span><br><span class="line">        future.whenComplete((appResult, t) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 设置响应状态码 </span></span><br><span class="line">                <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    res.setStatus(Response.OK);</span><br><span class="line">                    res.setResult(appResult);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">                    res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 往客户端回写响应结果</span></span><br><span class="line">                channel.send(res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Send result to consumer failed, channel is &quot;</span> + channel + <span class="string">&quot;, msg is &quot;</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">        res.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">        channel.send(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到 <strong>DubboProtocol$ExchangeHandlerAdapter#reply</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;Object&gt; <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(message <span class="keyword">instanceof</span> Invocation)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">&quot;Unsupported request: &quot;</span></span><br><span class="line">                    + (message == <span class="keyword">null</span> ? <span class="keyword">null</span> : (message.getClass().getName() + <span class="string">&quot;: &quot;</span> + message))</span><br><span class="line">                    + <span class="string">&quot;, channel: consumer: &quot;</span> + channel.getRemoteAddress() + <span class="string">&quot; --&gt; provider: &quot;</span> + channel.getLocalAddress());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Invocation inv = (Invocation) message;</span><br><span class="line">        <span class="comment">// 获取 invoker 实例</span></span><br><span class="line">        Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">        <span class="comment">// need to consider backward-compatibility if it&#x27;s a callback</span></span><br><span class="line">        <span class="keyword">if</span> (Boolean.TRUE.toString().equals(inv.getObjectAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class="line">            String methodsStr = invoker.getUrl().getParameters().get(<span class="string">&quot;methods&quot;</span>);</span><br><span class="line">            <span class="keyword">boolean</span> hasMethod = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (methodsStr == <span class="keyword">null</span> || !methodsStr.contains(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">                hasMethod = inv.getMethodName().equals(methodsStr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String[] methods = methodsStr.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (String method : methods) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (inv.getMethodName().equals(method)) &#123;</span><br><span class="line">                        hasMethod = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!hasMethod) &#123;</span><br><span class="line">                logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The methodName &quot;</span> + inv.getMethodName()</span><br><span class="line">                        + <span class="string">&quot; not found in callback service interface ,invoke will be ignored.&quot;</span></span><br><span class="line">                        + <span class="string">&quot; please update the api interface. url is:&quot;</span></span><br><span class="line">                        + invoker.getUrl()) + <span class="string">&quot; ,invocation is :&quot;</span> + inv);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line">        <span class="comment">// 通过 invoker 调用服务</span></span><br><span class="line">        Result result = invoker.invoke(inv);</span><br><span class="line">        <span class="keyword">return</span> result.thenApply(Function.identity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先通过 <strong>DubboProtocol#getInvoker</strong> 是获取对应的 invoker 实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) <span class="keyword">throws</span> RemotingException &#123;</span><br><span class="line">    <span class="keyword">boolean</span> isCallBackServiceInvoke = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isStubServiceInvoke = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> port = channel.getLocalAddress().getPort();</span><br><span class="line">    String path = (String) inv.getObjectAttachments().get(PATH_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if it&#x27;s callback service on client side</span></span><br><span class="line">    isStubServiceInvoke = Boolean.TRUE.toString().equals(inv.getObjectAttachments().get(STUB_EVENT_KEY));</span><br><span class="line">    <span class="keyword">if</span> (isStubServiceInvoke) &#123;</span><br><span class="line">        port = channel.getRemoteAddress().getPort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//callback</span></span><br><span class="line">    isCallBackServiceInvoke = isClientSide(channel) &amp;&amp; !isStubServiceInvoke;</span><br><span class="line">    <span class="keyword">if</span> (isCallBackServiceInvoke) &#123;</span><br><span class="line">        path += <span class="string">&quot;.&quot;</span> + inv.getObjectAttachments().get(CALLBACK_SERVICE_KEY);</span><br><span class="line">        inv.getObjectAttachments().put(IS_CALLBACK_SERVICE_INVOKE, Boolean.TRUE.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务 serviceKey ，通过 serviceKey 获取 DubboProtocol 中维护的 exporter 实例</span></span><br><span class="line">    String serviceKey = serviceKey(</span><br><span class="line">            port,</span><br><span class="line">            path,</span><br><span class="line">            (String) inv.getObjectAttachments().get(VERSION_KEY),</span><br><span class="line">            (String) inv.getObjectAttachments().get(GROUP_KEY)</span><br><span class="line">    );</span><br><span class="line">    DubboExporter&lt;?&gt; exporter = (DubboExporter&lt;?&gt;) exporterMap.get(serviceKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel,</span><br><span class="line">                <span class="string">&quot;Not found exported service: &quot;</span> + serviceKey + <span class="string">&quot; in &quot;</span> + exporterMap.keySet() + <span class="string">&quot;, may be version or group mismatch &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;, channel: consumer: &quot;</span> + channel.getRemoteAddress() + <span class="string">&quot; --&gt; provider: &quot;</span> + channel.getLocalAddress() +</span><br><span class="line">                        <span class="string">&quot;, message:&quot;</span> + getInvocationWithoutData(inv));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 invoker 实例</span></span><br><span class="line">    <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用 <strong>Invoker#invoke</strong> 方法，我们在服务导出中了解到，服务导出生成的 invoker 实例实际是动态代理对象，在经过服务提供端拦截器链的处理后，会调用该代理对象的 invoke 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistProxyFactory</span> <span class="keyword">extends</span> <span class="title">AbstractProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Wrapper类实例</span></span><br><span class="line">        <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">&#x27;$&#x27;</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">        <span class="comment">//覆写doInvoke方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 invoke 方法又通过 Wrapper 对象，使用反射调用具体的业务实现方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper1</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Wrapper</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ClassGenerator</span>.<span class="title">DC</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invokeMethod</span><span class="params">(Object object, String string, Class[] classArray, Object[] objectArray)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</span><br><span class="line">        HelloServiceImpl helloServiceImpl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            helloServiceImpl = (HelloServiceImpl)object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;sayHello&quot;</span>.equals(string) &amp;&amp; classArray.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> helloServiceImpl.sayHello();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvocationTargetException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(<span class="keyword">new</span> StringBuffer().append(<span class="string">&quot;Not found method \&quot;&quot;</span>).append(string).append(<span class="string">&quot;\&quot; in class laixiaoming.service.HelloServiceImpl.&quot;</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在拿到服务调用返回后，将其封装为 Response 对象，最后通过 <strong>HeaderExchangeChannel#send</strong> 回写 Response 对象到调用方。 </p>
<p>关于服务提供端的处理链路，这里附上一个调用中的关键的路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ChannelEventRunnable#run</span><br><span class="line">DecodeHandler#received</span><br><span class="line">HeaderExchangeHandler#received</span><br><span class="line">HeaderExchangeHandler#handleRequest</span><br><span class="line">DubboProtocol$ExchangeHandlerAdapter#reply</span><br><span class="line">AbstractProxyInvoker#invoke</span><br><span class="line">Wrapper1#invokeMethod</span><br><span class="line">HelloServiceImpl#sayHello</span><br></pre></td></tr></table></figure>



<h3 id="调用结果的处理"><a href="#调用结果的处理" class="headerlink" title="调用结果的处理"></a>调用结果的处理</h3><p>在服务提供方将 Response 对象返回时，同样有一个编码的过程，在服务消费方接收到响应数据后，也有一个解码的过程，最终得到 Response 对象。过程我们直接看下 <strong>HeaderExchangeHandler#received</strong> 中的处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">        handleResponse(channel, (Response) message);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler.received(exchangeChannel, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>HeaderExchangeHandler#handleResponse</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(Channel channel, Response response)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (response != <span class="keyword">null</span> &amp;&amp; !response.isHeartbeat()) &#123;</span><br><span class="line">        DefaultFuture.received(channel, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到 <strong>DefaultFuture#received</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response)</span> </span>&#123;</span><br><span class="line">    received(channel, response, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response, <span class="keyword">boolean</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//根据请求id 获取到关联的 DefaultFuture对象</span></span><br><span class="line">        DefaultFuture future = FUTURES.remove(response.getId());</span><br><span class="line">        <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Timeout t = future.timeoutCheckTask;</span><br><span class="line">            <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">                <span class="comment">// decrease Time</span></span><br><span class="line">                t.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">            future.doReceived(response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;The timeout response finally returned at &quot;</span></span><br><span class="line">                    + (<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>).format(<span class="keyword">new</span> Date()))</span><br><span class="line">                    + <span class="string">&quot;, response status is &quot;</span> + response.getStatus()</span><br><span class="line">                    + (channel == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, channel: &quot;</span> + channel.getLocalAddress()</span><br><span class="line">                    + <span class="string">&quot; -&gt; &quot;</span> + channel.getRemoteAddress()) + <span class="string">&quot;, please check provider side for detailed result.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        CHANNELS.remove(response.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过请求 id 获取到对应的 DefaultFuture 对象后，<strong>DefaultFuture#doReceived</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Response res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;response cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.getStatus() == Response.OK) &#123;</span><br><span class="line">        <span class="keyword">this</span>.complete(res.getResult());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123;</span><br><span class="line">        <span class="keyword">this</span>.completeExceptionally(<span class="keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.completeExceptionally(<span class="keyword">new</span> RemotingException(channel, res.getErrorMessage()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the result is returning, but the caller thread may still waiting</span></span><br><span class="line">    <span class="comment">// to avoid endless waiting for whatever reason, notify caller thread to return.</span></span><br><span class="line">    <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">        ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">        <span class="keyword">if</span> (threadlessExecutor.isWaiting()) &#123;</span><br><span class="line">            threadlessExecutor.notifyReturn(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The result has returned, but the biz thread is still waiting&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; which is not an expected state, interrupt the thread manually by returning an exception.&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将响应结果设置到 Future 中，消费端用户线程被唤起，Future#get 就可以获取到调用结果了。至此，一次 dubbo 调用就大致结束了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文主要就 Dubbo 调用的整个过程，从源码的角度作了简单分析，包括：服务消费端的请求发起、服务提供端处理请求的处理、服务提供端响应的返回、以及服务消费端响应的处理。</p>
]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud源码学习：@RefreshScope的实现原理</title>
    <url>/2024/11/03/Spring%20Cloud%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A@RefreshScope%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>在 Spring Cloud 微服务开发中，我们都知道，要想在不重启应用的前提下，修改的配置能动态刷新并且生效，我们只需要在对应的类上加上 <strong>@RefreshScope</strong> 注解即可。</p>
<p>但最近一次项目开发过程中，我们却遇到了一个动态刷新不生效的问题</p>
<span id="more"></span>

<p>使用的场景如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String myKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mykey&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMyKey</span><span class="params">(String myKey)</span> </span>&#123;</span><br><span class="line">        ConfigUtil.myKey = myKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMyKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> myKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 ConfigUtil#getMyKey 方法获取配置值，会发现修改配置后动态刷新并不生效。</p>
<p>本着“知根知底”的原则，我们决定先探究下 @RefreshScope 的实现原理。</p>
<h3 id="从-Scope说起"><a href="#从-Scope说起" class="headerlink" title="从@Scope说起"></a>从@Scope说起</h3><p> @Scope 是 Spring 中 Bean 的作用域，它主要有以下几种类型：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>默认类型，单例，表示 Spring 容器中只会创建该 bean 的一个实例</td>
</tr>
<tr>
<td>prototype</td>
<td>每次调用都会创建一个新的 bean 实例</td>
</tr>
<tr>
<td>request</td>
<td>在 web 应用中使用，每个 http 请求都有一个 bean 实例</td>
</tr>
<tr>
<td>session</td>
<td>在 web 应用中使用，每个 http 会话都有一个 bean 实例</td>
</tr>
<tr>
<td>application</td>
<td>在 web 应用中使用，全局共享</td>
</tr>
</tbody></table>
<p>而 Spring Cloud 则在此基础上增加了 <strong>refresh</strong> 的作用域，包装为 <strong>@RefreshScope</strong> 注解 ，用于实现配置的动态刷新。</p>
<h3 id="RefreshScope-做了什么"><a href="#RefreshScope-做了什么" class="headerlink" title="@RefreshScope 做了什么"></a>@RefreshScope 做了什么</h3><p>在 <strong>@RefreshScope</strong> 注解定义中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Scope(&quot;refresh&quot;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RefreshScope &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> Scope#proxyMode()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> proxy mode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">ScopedProxyMode <span class="title">proxyMode</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.TARGET_CLASS</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到有个 proxyMode 属性，默认为 ScopedProxyMode.TARGET_CLASS ，这其实表明了 Spring 将对该类创建代理对象。</p>
<h4 id="RefreshScope-的解析"><a href="#RefreshScope-的解析" class="headerlink" title="@RefreshScope 的解析"></a>@RefreshScope 的解析</h4><p>在 Spring Boot 对配置类进行扫描并生成 BeanDefinition 的过程中，首先会通过 <strong>ScopedProxyUtils#createScopedProxy</strong> 生成代理类的 BeanDefinition：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinitionHolder <span class="title">createScopedProxy</span><span class="params">(BeanDefinitionHolder definition,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry, <span class="keyword">boolean</span> proxyTargetClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//定义代理 bean 的名称为 bean 原名，并将目标 bean 的名称定义为 scopedTarget.$&#123;bean原名&#125;</span></span><br><span class="line">   String originalBeanName = definition.getBeanName();</span><br><span class="line">   BeanDefinition targetDefinition = definition.getBeanDefinition();</span><br><span class="line">   String targetBeanName = getTargetBeanName(originalBeanName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//定义代理 bean 的BeanDefinition 类型为 ScopedProxyFactoryBean</span></span><br><span class="line">   <span class="comment">// Create a scoped proxy definition for the original bean name,</span></span><br><span class="line">   <span class="comment">// &quot;hiding&quot; the target bean in an internal target definition.</span></span><br><span class="line">   RootBeanDefinition proxyDefinition = <span class="keyword">new</span> RootBeanDefinition(ScopedProxyFactoryBean.class);</span><br><span class="line">   proxyDefinition.setDecoratedDefinition(<span class="keyword">new</span> BeanDefinitionHolder(targetDefinition, targetBeanName));</span><br><span class="line">   proxyDefinition.setOriginatingBeanDefinition(targetDefinition);</span><br><span class="line">   proxyDefinition.setSource(definition.getSource());</span><br><span class="line">   proxyDefinition.setRole(targetDefinition.getRole());</span><br><span class="line"></span><br><span class="line">   <span class="comment">//设置目标 bean 名称属性</span></span><br><span class="line">   proxyDefinition.getPropertyValues().add(<span class="string">&quot;targetBeanName&quot;</span>, targetBeanName);</span><br><span class="line">   <span class="keyword">if</span> (proxyTargetClass) &#123;</span><br><span class="line">      targetDefinition.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">      <span class="comment">// ScopedProxyFactoryBean&#x27;s &quot;proxyTargetClass&quot; default is TRUE, so we don&#x27;t need to set it explicitly here.</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      proxyDefinition.getPropertyValues().add(<span class="string">&quot;proxyTargetClass&quot;</span>, Boolean.FALSE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将目标 bean 属性复制到代理 bean 定义</span></span><br><span class="line">   <span class="comment">// Copy autowire settings from original bean definition.</span></span><br><span class="line">   proxyDefinition.setAutowireCandidate(targetDefinition.isAutowireCandidate());</span><br><span class="line">   proxyDefinition.setPrimary(targetDefinition.isPrimary());</span><br><span class="line">   <span class="keyword">if</span> (targetDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">      proxyDefinition.copyQualifiersFrom((AbstractBeanDefinition) targetDefinition);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 目标 bean 定义为非首选 bean，并隐藏起来，不作为候选 bean 注入</span></span><br><span class="line">   <span class="comment">// The target bean should be ignored in favor of the scoped proxy.</span></span><br><span class="line">   targetDefinition.setAutowireCandidate(<span class="keyword">false</span>);</span><br><span class="line">   targetDefinition.setPrimary(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册 目标 bean 定义，同时返回 代理 bean 定义 </span></span><br><span class="line">   <span class="comment">// Register the target bean as separate bean in the factory.</span></span><br><span class="line">   registry.registerBeanDefinition(targetBeanName, targetDefinition);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Return the scoped proxy definition as primary bean definition</span></span><br><span class="line">   <span class="comment">// (potentially an inner bean).</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(proxyDefinition, originalBeanName, definition.getAliases());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里针对被 @Scope 修饰的 bean ，另外生成了一个类型为 <strong>ScopedProxyFactoryBean</strong> 的代理类 bean 定义，并注册到 Spring 容器，同时隐藏了对原 bean 修改为不参与注入，该代理 bean 定义保留了原 bean 的基本定义，可以看出，依赖原 bean 的地方在被注入依赖时使用的是该代理 bean 。</p>
<h4 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h4><p>在得到代理 bean 的定义后，将首先经过 <strong>RefreshScope</strong> 的处理：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20241103205114718.png" alt="image-20241103205114718"></p>
<p>RefreshScope 继承了 BeanDefinitionRegistryPostProcessor 和 BeanFactoryPostProcessor ,在 Spring Boot 实例化 bean 前，会先后经过这两种类型的处理器的扩展点处理。</p>
<p><strong>RefreshScope#postProcessBeanDefinitionRegistry</strong> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.registry = registry;</span><br><span class="line">   <span class="keyword">super</span>.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GenericScope#postProcessBeanDefinitionRegistry</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (String name : registry.getBeanDefinitionNames()) &#123;</span><br><span class="line">      BeanDefinition definition = registry.getBeanDefinition(name);</span><br><span class="line">      <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> RootBeanDefinition) &#123;</span><br><span class="line">         RootBeanDefinition root = (RootBeanDefinition) definition;</span><br><span class="line">         <span class="keyword">if</span> (root.getDecoratedDefinition() != <span class="keyword">null</span> &amp;&amp; root.hasBeanClass()</span><br><span class="line">               &amp;&amp; root.getBeanClass() == ScopedProxyFactoryBean.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getName().equals(root.getDecoratedDefinition().getBeanDefinition()</span><br><span class="line">                  .getScope())) &#123;</span><br><span class="line">                <span class="comment">//将代理对象类型设置为 LockedScopedProxyFactoryBean</span></span><br><span class="line">               root.setBeanClass(LockedScopedProxyFactoryBean.class);</span><br><span class="line">               root.getConstructorArgumentValues().addGenericArgumentValue(<span class="keyword">this</span>);</span><br><span class="line">               <span class="comment">// surprising that a scoped proxy bean definition is not already</span></span><br><span class="line">               <span class="comment">// marked as synthetic?</span></span><br><span class="line">               root.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GenericScope#postProcessBeanFactory</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">   <span class="comment">//注册 RefreshScope 实现</span></span><br><span class="line">   beanFactory.registerScope(<span class="keyword">this</span>.name, <span class="keyword">this</span>);</span><br><span class="line">   setSerializationId(beanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postProcessBeanDefinitionRegistry 主要将代理 bean 的类型设置为 <strong>LockedScopedProxyFactoryBean</strong> , postProcessBeanFactory 则将 RefreshScope 实现注册到 Spring 容器。</p>
<p>LockedScopedProxyFactoryBean 继承了 ScopedProxyFactoryBean ，其本质是一个 FactoryBean ：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20241103213436547.png" alt="image-20241103213436547"></p>
<p>在 ScopedProxyFactoryBean 实例化后，setBeanFactory 将被执行，<strong>GenericScope.LockedScopedProxyFactoryBean#setBeanFactory</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.setBeanFactory(beanFactory);</span><br><span class="line">   <span class="comment">//获取代理对象</span></span><br><span class="line">   Object proxy = getObject();</span><br><span class="line">   <span class="keyword">if</span> (proxy <span class="keyword">instanceof</span> Advised) &#123;</span><br><span class="line">      Advised advised = (Advised) proxy;</span><br><span class="line">      <span class="comment">//将自身作为切面通知</span></span><br><span class="line">      advised.addAdvice(<span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ScopedProxyFactoryBean#setBeanFactory</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!(beanFactory <span class="keyword">instanceof</span> ConfigurableBeanFactory)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Not running in a ConfigurableBeanFactory: &quot;</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   ConfigurableBeanFactory cbf = (ConfigurableBeanFactory) beanFactory;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.scopedTargetSource.setBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建代理对象</span></span><br><span class="line">   ProxyFactory pf = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">   pf.copyFrom(<span class="keyword">this</span>);</span><br><span class="line">   pf.setTargetSource(<span class="keyword">this</span>.scopedTargetSource);</span><br><span class="line"></span><br><span class="line">   Assert.notNull(<span class="keyword">this</span>.targetBeanName, <span class="string">&quot;Property &#x27;targetBeanName&#x27; is required&quot;</span>);</span><br><span class="line">   Class&lt;?&gt; beanType = beanFactory.getType(<span class="keyword">this</span>.targetBeanName);</span><br><span class="line">   <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot create scoped proxy for bean &#x27;&quot;</span> + <span class="keyword">this</span>.targetBeanName +</span><br><span class="line">            <span class="string">&quot;&#x27;: Target type could not be determined at the time of proxy creation.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!isProxyTargetClass() || beanType.isInterface() || Modifier.isPrivate(beanType.getModifiers())) &#123;</span><br><span class="line">      pf.setInterfaces(ClassUtils.getAllInterfacesForClass(beanType, cbf.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Add an introduction that implements only the methods on ScopedObject.</span></span><br><span class="line">   ScopedObject scopedObject = <span class="keyword">new</span> DefaultScopedObject(cbf, <span class="keyword">this</span>.scopedTargetSource.getTargetBeanName());</span><br><span class="line">   pf.addAdvice(<span class="keyword">new</span> DelegatingIntroductionInterceptor(scopedObject));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Add the AopInfrastructureBean marker to indicate that the scoped proxy</span></span><br><span class="line">   <span class="comment">// itself is not subject to auto-proxying! Only its target bean is.</span></span><br><span class="line">   pf.addInterface(AopInfrastructureBean.class);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.proxy = pf.getProxy(cbf.getBeanClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过 setBeanFactory 处理后，代理对象被创建完成，同时 LockedScopedProxyFactoryBean 作为一个 FactoryBean ，在 getObject 方法中，也会返回该代理对象。</p>
<p>另外， LockedScopedProxyFactoryBean 自身也被作为切面通知添加到通知列表，在调用目标对象的方法时，将执行自身定义的 <strong>GenericScope.LockedScopedProxyFactoryBean#invoke</strong> 方法。</p>
<h4 id="目标对象的实例化"><a href="#目标对象的实例化" class="headerlink" title="目标对象的实例化"></a>目标对象的实例化</h4><p>在 Spring Boot 启动后，会触发一次 目标对象的实例化，<strong>RefreshScope#onApplicationEvent</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">    start(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (event.getApplicationContext() == <span class="keyword">this</span>.context &amp;&amp; <span class="keyword">this</span>.eager</span><br><span class="line">         &amp;&amp; <span class="keyword">this</span>.registry != <span class="keyword">null</span>) &#123;</span><br><span class="line">      eagerlyInitialize();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eagerlyInitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (String name : <span class="keyword">this</span>.context.getBeanDefinitionNames()) &#123;</span><br><span class="line">      BeanDefinition definition = <span class="keyword">this</span>.registry.getBeanDefinition(name);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.getName().equals(definition.getScope())</span><br><span class="line">            &amp;&amp; !definition.isLazyInit()) &#123;</span><br><span class="line">         <span class="comment">// 目标对象实例化</span></span><br><span class="line">         Object bean = <span class="keyword">this</span>.context.getBean(name);</span><br><span class="line">         <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bean.getClass();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，如果代理对象方法被调用时，也会触发目标对象的实例化，<strong>GenericScope.LockedScopedProxyFactoryBean#invoke</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   Method method = invocation.getMethod();</span><br><span class="line">   <span class="keyword">if</span> (AopUtils.isEqualsMethod(method) || AopUtils.isToStringMethod(method)</span><br><span class="line">         || AopUtils.isHashCodeMethod(method)</span><br><span class="line">         || isScopedObjectGetTargetObject(method)) &#123;</span><br><span class="line">      <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//获取代理对象</span></span><br><span class="line">   Object proxy = getObject();</span><br><span class="line">   ReadWriteLock readWriteLock = <span class="keyword">this</span>.scope.getLock(<span class="keyword">this</span>.targetBeanName);</span><br><span class="line">   <span class="keyword">if</span> (readWriteLock == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;For bean with name [&quot;</span> + <span class="keyword">this</span>.targetBeanName</span><br><span class="line">               + <span class="string">&quot;] there is no read write lock. Will create a new one to avoid NPE&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">   &#125;</span><br><span class="line">   Lock lock = readWriteLock.readLock();</span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (proxy <span class="keyword">instanceof</span> Advised) &#123;</span><br><span class="line">         Advised advised = (Advised) proxy;</span><br><span class="line">         ReflectionUtils.makeAccessible(method);</span><br><span class="line">         <span class="comment">//目标对象实例化，同时调用目标对象方法</span></span><br><span class="line">         <span class="keyword">return</span> ReflectionUtils.invokeMethod(method,</span><br><span class="line">               advised.getTargetSource().getTarget(),</span><br><span class="line">               invocation.getArguments());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// see gh-349. Throw the original exception rather than the</span></span><br><span class="line">   <span class="comment">// UndeclaredThrowableException</span></span><br><span class="line">   <span class="keyword">catch</span> (UndeclaredThrowableException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> e.getUndeclaredThrowable();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SimpleBeanTargetSource#getTarget</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> getBeanFactory().getBean(getTargetBeanName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟悉的 getBean 方法，最终来到 <strong>AbstractBeanFactory#doGetBean</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      <span class="comment">//忽略....</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">      <span class="comment">//忽略...</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      String scopeName = mbd.getScope();</span><br><span class="line">      <span class="comment">//获取 RefreshScope 实例</span></span><br><span class="line">      <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">      <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">               afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">         <span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到 RefreshScope ，<strong>GenericScope#get</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//放入 cache</span></span><br><span class="line">   BeanLifecycleWrapper value = <span class="keyword">this</span>.cache.put(name,</span><br><span class="line">         <span class="keyword">new</span> BeanLifecycleWrapper(name, objectFactory));</span><br><span class="line">   <span class="keyword">this</span>.locks.putIfAbsent(name, <span class="keyword">new</span> ReentrantReadWriteLock());</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value.getBean();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.errors.put(name, e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将创建 bean 的流程作为 objectFactory ，然后封装为 BeanLifecycleWrapper 类型，将放入维护的 cache 缓存，最终调用的是 <strong>GenericScope.BeanLifecycleWrapper#getBean</strong> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.bean == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.name) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.bean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.bean = <span class="keyword">this</span>.objectFactory.getObject();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 bean 不为空的情况下，调用 objectFactory 创建一个新的对象，那什么情况下 bean 会为空呢？</p>
<h3 id="配置的刷新过程"><a href="#配置的刷新过程" class="headerlink" title="配置的刷新过程"></a>配置的刷新过程</h3><p>在配置变更时， RefreshEventListener 会接收到配置变更通知，同时调用 <strong>ContextRefresher#refresh</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Set&lt;String&gt; <span class="title">refresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//刷新Environment对象，并获取变更的key值</span></span><br><span class="line">   Set&lt;String&gt; keys = refreshEnvironment();</span><br><span class="line">   <span class="keyword">this</span>.scope.refreshAll();</span><br><span class="line">   <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RefreshScope#refreshAll</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//销毁已创建的bean</span></span><br><span class="line">   <span class="keyword">super</span>.destroy();</span><br><span class="line">   <span class="keyword">this</span>.context.publishEvent(<span class="keyword">new</span> RefreshScopeRefreshedEvent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GenericScope#destroy()</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   List&lt;Throwable&gt; errors = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">   <span class="comment">// 获取所有的 BeanLifecycleWrapper 并清空 cache</span></span><br><span class="line">   Collection&lt;BeanLifecycleWrapper&gt; wrappers = <span class="keyword">this</span>.cache.clear();</span><br><span class="line">   <span class="keyword">for</span> (BeanLifecycleWrapper wrapper : wrappers) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Lock lock = <span class="keyword">this</span>.locks.get(wrapper.getName()).writeLock();</span><br><span class="line">         lock.lock();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//逐个销毁</span></span><br><span class="line">            wrapper.destroy();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">         errors.add(e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!errors.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> wrapIfNecessary(errors.get(<span class="number">0</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">this</span>.errors.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GenericScope.BeanLifecycleWrapper#destroy</strong> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.callback == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.name) &#123;</span><br><span class="line">      Runnable callback = <span class="keyword">this</span>.callback;</span><br><span class="line">      <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">         callback.run();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将bean 实例置空</span></span><br><span class="line">      <span class="keyword">this</span>.callback = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.bean = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，刷新实则是对缓存中的实例列表进行清空，当通过代理对象调用目标对象方法时，目标对象如果为空，将触发目标对象的重新实例化，从而实现了配置的动态刷新。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回到文章开头的问题，原因就是被 @RefreshScope 修饰的类会动态生成代理对象，而静态方法的调用不会经过代理对象的处理，所以也不会触发 bean 的重新实例化。</p>
]]></content>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud源码学习：配置加载流程</title>
    <url>/2024/11/16/Spring%20Cloud%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>在 Spring Boot/Cloud 中，配置是应用环境的一部分，而环境有一个专属的类 —— “Environment”。</p>
<p>Environment 是 Spring 对环境的抽象，它封装了应用运行时的所有配置属性，这些属性可以来自不同的来源，如本地配置文件、系统属性、环境变量、命令行参数、配置中心等，而 Environment 则提供了一个统一的接口来访问这些属性。</p>
<p>那这些不同来源的配置文件是如何加载并生效的呢？本文一起来看看。</p>
<span id="more"></span>



<h3 id="创建-Environment"><a href="#创建-Environment" class="headerlink" title="创建 Environment"></a>创建 Environment</h3><p>进入 SpringApplication.run 方法，来到 <strong>org.springframework.boot.SpringApplication#prepareEnvironment</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">prepareEnvironment</span><span class="params">(SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">      ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 根据当前应用环境类型，创建对应的 Environment 实例，此处实例类型为 StandardServletEnvironment</span></span><br><span class="line">   ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">   <span class="comment">// 将启动参数绑定到 environment 中</span></span><br><span class="line">   configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">   ConfigurationPropertySources.attach(environment);</span><br><span class="line">   <span class="comment">// 发布环境准备完毕事件</span></span><br><span class="line">   listeners.environmentPrepared(environment);</span><br><span class="line">   bindToSpringApplication(environment);</span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>.isCustomEnvironment) &#123;</span><br><span class="line">      environment = <span class="keyword">new</span> EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,</span><br><span class="line">            deduceEnvironmentClass());</span><br><span class="line">   &#125;</span><br><span class="line">   ConfigurationPropertySources.attach(environment);</span><br><span class="line">   <span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里在创建好 Environment 实例后，使用 SpringApplicationRunListener 发布了一个广播事件，此时只有一个 EventPublishingRunListener 实例，直接来到其 environmentPrepared 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.initialMulticaster</span><br><span class="line">         .multicastEvent(<span class="keyword">new</span> ApplicationEnvironmentPreparedEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args, environment));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://storage.laixiaoming.space/blog/image-20241116160613820.png" alt="image-20241116160613820"></p>
<h3 id="加载bootstrap本地配置文件"><a href="#加载bootstrap本地配置文件" class="headerlink" title="加载bootstrap本地配置文件"></a>加载bootstrap本地配置文件</h3><p>广播事件会回调所有适配的 ApplicationListener 监听器，调用其 onApplicationEvent 方法，这里第一个被调用的是 <strong>BootstrapApplicationListener#onApplicationEvent</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent event)</span> </span>&#123;</span><br><span class="line">   ConfigurableEnvironment environment = event.getEnvironment();</span><br><span class="line">   <span class="comment">// 默认执行，除非显示关闭</span></span><br><span class="line">   <span class="keyword">if</span> (!environment.getProperty(<span class="string">&quot;spring.cloud.bootstrap.enabled&quot;</span>, Boolean.class,</span><br><span class="line">         <span class="keyword">true</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// don&#x27;t listen to events in a bootstrap context</span></span><br><span class="line">   <span class="comment">// 如果当前配置源已经包含了 &quot;bootstrap&quot; ，则忽略不重复处理</span></span><br><span class="line">   <span class="keyword">if</span> (environment.getPropertySources().contains(BOOTSTRAP_PROPERTY_SOURCE_NAME)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">   String configName = environment</span><br><span class="line">         .resolvePlaceholders(<span class="string">&quot;$&#123;spring.cloud.bootstrap.name:bootstrap&#125;&quot;</span>);</span><br><span class="line">   <span class="comment">// 是否存在父容器上下文的初始化器，通过 debug 发现没有</span></span><br><span class="line">   <span class="keyword">for</span> (ApplicationContextInitializer&lt;?&gt; initializer : event.getSpringApplication()</span><br><span class="line">         .getInitializers()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (initializer <span class="keyword">instanceof</span> ParentContextApplicationContextInitializer) &#123;</span><br><span class="line">         context = findBootstrapContext(</span><br><span class="line">               (ParentContextApplicationContextInitializer) initializer,</span><br><span class="line">               configName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建 bootstrap 级别的应用上下文</span></span><br><span class="line">      context = bootstrapServiceContext(environment, event.getSpringApplication(),</span><br><span class="line">            configName);</span><br><span class="line">      event.getSpringApplication()</span><br><span class="line">            .addListeners(<span class="keyword">new</span> CloseContextOnFailureApplicationListener(context));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   apply(context, event.getSpringApplication(), environment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构建新的内置-SpringApplication"><a href="#构建新的内置-SpringApplication" class="headerlink" title="构建新的内置 SpringApplication"></a>构建新的内置 SpringApplication</h4><p>来到 <strong>BootstrapApplicationListener#bootstrapServiceContext</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableApplicationContext <span class="title">bootstrapServiceContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ConfigurableEnvironment environment, <span class="keyword">final</span> SpringApplication application,</span></span></span><br><span class="line"><span class="function"><span class="params">      String configName)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 创建 bootstrap 级别的 environment</span></span><br><span class="line">   StandardEnvironment bootstrapEnvironment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">   <span class="comment">// 将初始化生成的一些 PropertySource 移除，包括 systemProperties(JVM级的环境变量) 和 systemEnvironment(操作系统级的环境变量)</span></span><br><span class="line">   MutablePropertySources bootstrapProperties = bootstrapEnvironment</span><br><span class="line">         .getPropertySources();</span><br><span class="line">   <span class="keyword">for</span> (PropertySource&lt;?&gt; source : bootstrapProperties) &#123;</span><br><span class="line">      bootstrapProperties.remove(source.getName());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 是否存在外部配置文件</span></span><br><span class="line">   String configLocation = environment</span><br><span class="line">         .resolvePlaceholders(<span class="string">&quot;$&#123;spring.cloud.bootstrap.location:&#125;&quot;</span>);</span><br><span class="line">   String configAdditionalLocation = environment</span><br><span class="line">         .resolvePlaceholders(<span class="string">&quot;$&#123;spring.cloud.bootstrap.additional-location:&#125;&quot;</span>);</span><br><span class="line">   <span class="comment">// 初始化容器参数</span></span><br><span class="line">   Map&lt;String, Object&gt; bootstrapMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   bootstrapMap.put(<span class="string">&quot;spring.config.name&quot;</span>, configName);</span><br><span class="line">   <span class="comment">// if an app (or test) uses spring.main.web-application-type=reactive, bootstrap</span></span><br><span class="line">   <span class="comment">// will fail</span></span><br><span class="line">   <span class="comment">// force the environment to use none, because if though it is set below in the</span></span><br><span class="line">   <span class="comment">// builder</span></span><br><span class="line">   <span class="comment">// the environment overrides it</span></span><br><span class="line">   bootstrapMap.put(<span class="string">&quot;spring.main.web-application-type&quot;</span>, <span class="string">&quot;none&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(configLocation)) &#123;</span><br><span class="line">      bootstrapMap.put(<span class="string">&quot;spring.config.location&quot;</span>, configLocation);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(configAdditionalLocation)) &#123;</span><br><span class="line">      bootstrapMap.put(<span class="string">&quot;spring.config.additional-location&quot;</span>,</span><br><span class="line">            configAdditionalLocation);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将 environment 的配置添加到新增的 bootstrapEnvironment</span></span><br><span class="line">   bootstrapProperties.addFirst(</span><br><span class="line">         <span class="keyword">new</span> MapPropertySource(BOOTSTRAP_PROPERTY_SOURCE_NAME, bootstrapMap));</span><br><span class="line">   <span class="keyword">for</span> (PropertySource&lt;?&gt; source : environment.getPropertySources()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (source <span class="keyword">instanceof</span> StubPropertySource) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      bootstrapProperties.addLast(source);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 构建了一个新的 SpringApplication</span></span><br><span class="line">   SpringApplicationBuilder builder = <span class="keyword">new</span> SpringApplicationBuilder()</span><br><span class="line">         .profiles(environment.getActiveProfiles()).bannerMode(Mode.OFF)</span><br><span class="line">         .environment(bootstrapEnvironment)</span><br><span class="line">         <span class="comment">// Don&#x27;t use the default properties in this builder</span></span><br><span class="line">         .registerShutdownHook(<span class="keyword">false</span>).logStartupInfo(<span class="keyword">false</span>)</span><br><span class="line">         .web(WebApplicationType.NONE);</span><br><span class="line">   <span class="keyword">final</span> SpringApplication builderApplication = builder.application();</span><br><span class="line">   <span class="keyword">if</span> (builderApplication.getMainApplicationClass() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// gh_425:</span></span><br><span class="line">      <span class="comment">// SpringApplication cannot deduce the MainApplicationClass here</span></span><br><span class="line">      <span class="comment">// if it is booted from SpringBootServletInitializer due to the</span></span><br><span class="line">      <span class="comment">// absense of the &quot;main&quot; method in stackTraces.</span></span><br><span class="line">      <span class="comment">// But luckily this method&#x27;s second parameter &quot;application&quot; here</span></span><br><span class="line">      <span class="comment">// carries the real MainApplicationClass which has been explicitly</span></span><br><span class="line">      <span class="comment">// set by SpringBootServletInitializer itself already.</span></span><br><span class="line">      builder.main(application.getMainApplicationClass());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (environment.getPropertySources().contains(<span class="string">&quot;refreshArgs&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">// If we are doing a context refresh, really we only want to refresh the</span></span><br><span class="line">      <span class="comment">// Environment, and there are some toxic listeners (like the</span></span><br><span class="line">      <span class="comment">// LoggingApplicationListener) that affect global static state, so we need a</span></span><br><span class="line">      <span class="comment">// way to switch those off.</span></span><br><span class="line">      builderApplication</span><br><span class="line">            .setListeners(filterListeners(builderApplication.getListeners()));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 添加 BootstrapImportSelectorConfiguration 配置类</span></span><br><span class="line">   builder.sources(BootstrapImportSelectorConfiguration.class);</span><br><span class="line">   <span class="comment">// 调用 SpringApplication 的run方法</span></span><br><span class="line">   <span class="keyword">final</span> ConfigurableApplicationContext context = builder.run();</span><br><span class="line">   <span class="comment">// gh-214 using spring.application.name=bootstrap to set the context id via</span></span><br><span class="line">   <span class="comment">// `ContextIdApplicationContextInitializer` prevents apps from getting the actual</span></span><br><span class="line">   <span class="comment">// spring.application.name</span></span><br><span class="line">   <span class="comment">// during the bootstrap phase.</span></span><br><span class="line">   context.setId(<span class="string">&quot;bootstrap&quot;</span>);</span><br><span class="line">   <span class="comment">// Make the bootstrap context a parent of the app context</span></span><br><span class="line">   <span class="comment">// 配置 bootstrap 作为 application 的父容器</span></span><br><span class="line">   addAncestorInitializer(application, context);</span><br><span class="line">   <span class="comment">// It only has properties in it now that we don&#x27;t want in the parent so remove</span></span><br><span class="line">   <span class="comment">// it (and it will be added back later)</span></span><br><span class="line">   bootstrapProperties.remove(BOOTSTRAP_PROPERTY_SOURCE_NAME);</span><br><span class="line">   <span class="comment">// 配置合并</span></span><br><span class="line">   mergeDefaultProperties(environment.getPropertySources(), bootstrapProperties);</span><br><span class="line">   <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里面构造了一个新的 SpringApplication，新的 SpringApplication 有几点值得关注：</p>
<ol>
<li>激活的 profile 与原 SpringApplication 保持一致；</li>
<li>使用了新构建的 environment ，并添加了一个 “bootstrap” 属性源；</li>
<li>WebApplicationType 设置为了 NONE ，说明该 SpringApplication 不会创建 Web 容器；</li>
<li>添加了一个 BootstrapImportSelectorConfiguration 配置类；</li>
</ol>
<h4 id="BootstrapImportSelectorConfiguration-配置类"><a href="#BootstrapImportSelectorConfiguration-配置类" class="headerlink" title="BootstrapImportSelectorConfiguration 配置类"></a>BootstrapImportSelectorConfiguration 配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">   ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">   <span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">   <span class="comment">// 加载 BootstrapConfiguration 配置项类</span></span><br><span class="line">   List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;(SpringFactoriesLoader</span><br><span class="line">         .loadFactoryNames(BootstrapConfiguration.class, classLoader));</span><br><span class="line">   names.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(</span><br><span class="line">         <span class="keyword">this</span>.environment.getProperty(<span class="string">&quot;spring.cloud.bootstrap.sources&quot;</span>, <span class="string">&quot;&quot;</span>))));</span><br><span class="line"></span><br><span class="line">   List&lt;OrderedAnnotatedElement&gt; elements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         elements.add(</span><br><span class="line">               <span class="keyword">new</span> OrderedAnnotatedElement(<span class="keyword">this</span>.metadataReaderFactory, name));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   AnnotationAwareOrderComparator.sort(elements);</span><br><span class="line"></span><br><span class="line">   String[] classNames = elements.stream().map(e -&gt; e.name).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> classNames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该配置类使用 Spring 中的 SPI ，加载了 <strong>BootstrapConfiguration.class</strong> 配置的组件，通过 debug 发现，这里加载的类（使用 Nacos 配置中心）有：</p>
<ul>
<li>com.alibaba.cloud.nacos.NacosConfigBootstrapConfiguration</li>
<li>org.springframework.cloud.bootstrap.config.PropertySourceBootstrapConfiguration</li>
<li>org.springframework.cloud.bootstrap.encrypt.EncryptionBootstrapConfiguration</li>
<li>org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration</li>
<li>org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration</li>
</ul>
<p>这些配置都与配置中心有关，值得关注的一点是，<strong>NacosConfigBootstrapConfiguration</strong> 也是在 bootstrap SpringApplication 中创建的，也说明了 Nacos 配置中心的地址的配置需要配置在 bootstrap 配置文件，而不能在 application 配置文件。</p>
<h4 id="启动内置-SpringApplication"><a href="#启动内置-SpringApplication" class="headerlink" title="启动内置 SpringApplication"></a>启动内置 SpringApplication</h4><p>新启动的 SpringApplication 与原 SpringApplication 的流程基本一致。</p>
<p>首先是又一次来到 <strong>BootstrapApplicationListener#onApplicationEvent</strong> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent event)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//省略...</span></span><br><span class="line">   <span class="comment">// don&#x27;t listen to events in a bootstrap context</span></span><br><span class="line">   <span class="keyword">if</span> (environment.getPropertySources().contains(BOOTSTRAP_PROPERTY_SOURCE_NAME)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的是，由于当前已存在 “bootstrap” 属性源，该监听器的后续操作也不会继续执行。</p>
<p>我们直接看 <strong>ConfigFileApplicationListener#onApplicationEvent</strong> 。</p>
<h4 id="ConfigFileApplicationListener-的监听动作"><a href="#ConfigFileApplicationListener-的监听动作" class="headerlink" title="ConfigFileApplicationListener 的监听动作"></a>ConfigFileApplicationListener 的监听动作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEnvironmentPreparedEvent) &#123;</span><br><span class="line">      onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationPreparedEvent) &#123;</span><br><span class="line">      onApplicationPreparedEvent(event);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前是 ApplicationEnvironmentPreparedEvent 事件，来到 onApplicationEnvironmentPreparedEvent ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onApplicationEnvironmentPreparedEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent event)</span> </span>&#123;</span><br><span class="line">   List&lt;EnvironmentPostProcessor&gt; postProcessors = loadPostProcessors();</span><br><span class="line">   postProcessors.add(<span class="keyword">this</span>);</span><br><span class="line">   AnnotationAwareOrderComparator.sort(postProcessors);</span><br><span class="line">   <span class="keyword">for</span> (EnvironmentPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">      postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里出现了一个 EnvironmentPostProcessor ，它是运行环境的后置处理器，而 ConfigFileApplicationListener 本身也是一个 EnvironmentPostProcessor ,来到 <strong>ConfigFileApplicationListener#postProcessEnvironment</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessEnvironment</span><span class="params">(ConfigurableEnvironment environment, SpringApplication application)</span> </span>&#123;</span><br><span class="line">   addPropertySources(environment, application.getResourceLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addPropertySources</span><span class="params">(ConfigurableEnvironment environment, ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">   RandomValuePropertySource.addToEnvironment(environment);</span><br><span class="line">   <span class="keyword">new</span> Loader(environment, resourceLoader).load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动了一个 Loader 加载器，用于加载配置源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.profiles = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">   <span class="keyword">this</span>.processedProfiles = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">   <span class="keyword">this</span>.activatedProfiles = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">this</span>.loaded = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">   <span class="comment">// 初始化 profiles 集合，通过debug 发现有两个元素，一个是 null，另一个当前激活的比如 dev</span></span><br><span class="line">   initializeProfiles();</span><br><span class="line">   <span class="keyword">while</span> (!<span class="keyword">this</span>.profiles.isEmpty()) &#123;</span><br><span class="line">      Profile profile = <span class="keyword">this</span>.profiles.poll();</span><br><span class="line">      <span class="keyword">if</span> (profile != <span class="keyword">null</span> &amp;&amp; !profile.isDefaultProfile()) &#123;</span><br><span class="line">         addProfileToEnvironment(profile.getName());</span><br><span class="line">      &#125;</span><br><span class="line">      load(profile, <span class="keyword">this</span>::getPositiveProfileFilter, addToLoaded(MutablePropertySources::addLast, <span class="keyword">false</span>));</span><br><span class="line">      <span class="keyword">this</span>.processedProfiles.add(profile);</span><br><span class="line">   &#125;</span><br><span class="line">   resetEnvironmentProfiles(<span class="keyword">this</span>.processedProfiles);</span><br><span class="line">   load(<span class="keyword">null</span>, <span class="keyword">this</span>::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, <span class="keyword">true</span>));</span><br><span class="line">   addLoadedPropertySources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确定要加载的 profile 后，继续深入来到 load 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(Profile profile, DocumentFilterFactory filterFactory, DocumentConsumer consumer)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//从配置文件所在目录中逐个扫描</span></span><br><span class="line">    getSearchLocations().forEach((location) -&gt; &#123;</span><br><span class="line">      <span class="keyword">boolean</span> isFolder = location.endsWith(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">      Set&lt;String&gt; names = isFolder ? getSearchNames() : NO_SEARCH_NAMES;</span><br><span class="line">      names.forEach((name) -&gt; load(location, name, profile, filterFactory, consumer));</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;String&gt; <span class="title">getSearchNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//是否有 spring.config.name 属性，有则返回，通过 debug 发现此时值为 bootstrap</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.environment.containsProperty(CONFIG_NAME_PROPERTY)) &#123;</span><br><span class="line">      String property = <span class="keyword">this</span>.environment.getProperty(CONFIG_NAME_PROPERTY);</span><br><span class="line">      <span class="keyword">return</span> asResolvedSet(property, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> asResolvedSet(ConfigFileApplicationListener.<span class="keyword">this</span>.names, DEFAULT_NAMES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取配置文件所在位置，逐个扫描该位置下的配置文件，扫描的目录包括 file:./config/、file:./、classpath:/config/、classpath:/，这里有一个点需要注意的是，这里会按顺序进行扫描，获取到的配置将追加到 MutablePropertySources 的末尾，也直接影响了配置获取的优先级：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20241116173530035.png" alt="image-20241116173530035"></p>
<p>结合 getSearchNames 方法可知，该内置 SpringApplication 的作用之一便是加载 bootstrap 级别的配置文件到 Environment。</p>
<h4 id="合并配置"><a href="#合并配置" class="headerlink" title="合并配置"></a>合并配置</h4><p>在加载完 bootstrap 配置文件后， 再通过 <strong>mergeDefaultProperties</strong> 将 bootstrap 的配置合并到原 application 的 environment 中。</p>
<p>回到 <strong>BootstrapApplicationListener#onApplicationEvent</strong> ，临到创建好的 bootstrap 的 ApplicationContext 后，同时也将 bootstrap 中的创建的 ApplicationContextInitializer 注册到原 application 的上下文，其中也包括 <strong>PropertySourceBootstrapConfiguration</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">      SpringApplication application, ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">   List&lt;ApplicationContextInitializer&gt; initializers = getOrderedBeansOfType(context,</span><br><span class="line">         ApplicationContextInitializer.class);</span><br><span class="line">   application.addInitializers(initializers</span><br><span class="line">         .toArray(<span class="keyword">new</span> ApplicationContextInitializer[initializers.size()]));</span><br><span class="line">   addBootstrapDecryptInitializer(application);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，该 bootstrap 内置 SpringApplication 也执行完成了。</p>
<h3 id="加载-application-本地配置文件"><a href="#加载-application-本地配置文件" class="headerlink" title="加载 application 本地配置文件"></a>加载 application 本地配置文件</h3><p>回到外层 application 的创建流程中，在BootstrapApplicationListener 监听器执行完成后，将再一次执行 <strong>ConfigFileApplicationListener#onApplicationEvent</strong> ，但此时不同的是，加载的配置文件名称不再是 “bootstrap” 了，而是 “application” ：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20241116194509525.png" alt="image-20241116194509525"></p>
<h3 id="Nacos配置文件的加载"><a href="#Nacos配置文件的加载" class="headerlink" title="Nacos配置文件的加载"></a>Nacos配置文件的加载</h3><p>在前面我们了解到，在创建运行 bootstrap 内置 SpringApplication 后，会注册一系列 ApplicationContextInitializer ，其中就包括 <strong>PropertySourceBootstrapConfiguration</strong> ，那它是什么时候被调用的呢</p>
<p>通过 debug ，来到 <strong>SpringApplication#prepareContext</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="function"><span class="params">      SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   applyInitializers(context);</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyInitializers</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;</span><br><span class="line">        Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),</span><br><span class="line">                                                                        ApplicationContextInitializer.class);</span><br><span class="line">        Assert.isInstanceOf(requiredType, context, <span class="string">&quot;Unable to call initializer.&quot;</span>);</span><br><span class="line">        initializer.initialize(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PropertySourceBootstrapConfiguration#initialize</strong> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">   List&lt;PropertySource&lt;?&gt;&gt; composite = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.propertySourceLocators);</span><br><span class="line">   <span class="keyword">boolean</span> empty = <span class="keyword">true</span>;</span><br><span class="line">   ConfigurableEnvironment environment = applicationContext.getEnvironment();</span><br><span class="line">   <span class="comment">// 使用 PropertySourceLocator 拉取远程配置</span></span><br><span class="line">   <span class="keyword">for</span> (PropertySourceLocator locator : <span class="keyword">this</span>.propertySourceLocators) &#123;</span><br><span class="line">      Collection&lt;PropertySource&lt;?&gt;&gt; source = locator.locateCollection(environment);</span><br><span class="line">      <span class="keyword">if</span> (source == <span class="keyword">null</span> || source.size() == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;PropertySource&lt;?&gt;&gt; sourceList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (PropertySource&lt;?&gt; p : source) &#123;</span><br><span class="line">         sourceList.add(<span class="keyword">new</span> BootstrapPropertySource&lt;&gt;(p));</span><br><span class="line">      &#125;</span><br><span class="line">      logger.info(<span class="string">&quot;Located property source: &quot;</span> + sourceList);</span><br><span class="line">      composite.addAll(sourceList);</span><br><span class="line">      empty = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!empty) &#123;</span><br><span class="line">      <span class="comment">// 合并远程配置</span></span><br><span class="line">      MutablePropertySources propertySources = environment.getPropertySources();</span><br><span class="line">      String logConfig = environment.resolvePlaceholders(<span class="string">&quot;$&#123;logging.config:&#125;&quot;</span>);</span><br><span class="line">      LogFile logFile = LogFile.get(environment);</span><br><span class="line">      <span class="keyword">for</span> (PropertySource&lt;?&gt; p : environment.getPropertySources()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (p.getName().startsWith(BOOTSTRAP_PROPERTY_SOURCE_NAME)) &#123;</span><br><span class="line">            propertySources.remove(p.getName());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      insertPropertySources(propertySources, composite);</span><br><span class="line">      reinitializeLoggingSystem(environment, logConfig, logFile);</span><br><span class="line">      setLogLevels(applicationContext, environment);</span><br><span class="line">      handleIncludedProfiles(environment);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用 Nacos 配置中心时，将使用 <strong>NacosPropertySourceLocator#locate</strong> 进行配置的拉取，这里不深入了解。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文从源码的角度简单的分析了 Spring Boot/Cloud 下的配置加载流程：</p>
<ol>
<li>Spring Boot 在启动时，通过 <strong>ApplicationEnvironmentPreparedEvent</strong> 事件触发 <strong>BootstrapApplicationListener</strong> 监听器的执行，该监听器：<ol>
<li> 构建一个新的内置 SpringApplication 并且启动；</li>
<li> 该bootstrap 级 SpringApplication 通过 **ConfigFileApplicationListener ** 加载 bootstrap 配置文件，加载完成后合并到外部的 SpringApplication 的 Environment；</li>
<li> 同时也将 <strong>PropertySourceBootstrapConfiguration</strong> 初始化器注册到外部 SpringApplication 中；</li>
</ol>
</li>
<li> 加载 application 配置文件，同样也是由 **ConfigFileApplicationListener ** 完成；</li>
<li>通过 <strong>PropertySourceBootstrapConfiguration</strong> 加载远程配置；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo源码学习：集群容错</title>
    <url>/2024/12/04/Dubbo%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在微服务架构中，为了避免单点故障，一个服务通常会部署多个实例，而对于服务消费者而言，则需要考虑如何选择一个可用的实例，以及调用失败的情况如何处理。在 Dubbo 中，针对这些问题，Dubbo 也提供了多种集群容错策略。</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Dubbo 2.7.12版本</p>
</blockquote>
<h3 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h3><p>Cluster 接口是 Dubbo 对一组服务提供者进行抽象的结果，该接口定义了如何从多个服务提供者中选择一个或多个提供者进行调用，并处理调用过程中可能出现的异常。Dubbo 内置了几种常见的集群容错策略，包括：</p>
<ul>
<li>Failover Cluster：失败自动切换</li>
<li>Failfast Cluster：快速失败</li>
<li>Failsafe Cluster：失败安全</li>
<li>Failback Cluster：失败自动恢复</li>
<li>Forking Cluster：并行调用</li>
<li>Broadcast Cluster：广播调用</li>
</ul>
<h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><p>在每个 Cluster 接口实现中，都会创建对应的 Cluster Invoker 对象，而调用的逻辑实现由 Cluster Invoker 提供，这些 Cluster Invoker 者继承了 AbstractClusterInvoker ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    checkWhetherDestroyed();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binding attachments into invocation.</span></span><br><span class="line">    Map&lt;String, Object&gt; contextAttachments = RpcContext.getContext().getObjectAttachments();</span><br><span class="line">    <span class="keyword">if</span> (contextAttachments != <span class="keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        ((RpcInvocation) invocation).addObjectAttachments(contextAttachments);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 获取服务提供者列表</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class="line">    <span class="comment">// 获取负载均衡器</span></span><br><span class="line">    LoadBalance loadbalance = initLoadBalance(invokers, invocation);</span><br><span class="line">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line">    <span class="comment">// 调用，由子类实现</span></span><br><span class="line">    <span class="keyword">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们直接看一下其子类 doInvoke 方法的实现。</p>
<h4 id="FailoverClusterInvoker"><a href="#FailoverClusterInvoker" class="headerlink" title="FailoverClusterInvoker"></a>FailoverClusterInvoker</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; copyInvokers = invokers;</span><br><span class="line">    checkInvokers(copyInvokers, invocation);</span><br><span class="line">    String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">    <span class="comment">//获取重试次数</span></span><br><span class="line">    <span class="keyword">int</span> len = calculateInvokeTimes(methodName);</span><br><span class="line">    <span class="comment">// retry loop.</span></span><br><span class="line">    RpcException le = <span class="keyword">null</span>; <span class="comment">// last exception.</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size()); <span class="comment">// invoked invokers.</span></span><br><span class="line">    Set&lt;String&gt; providers = <span class="keyword">new</span> HashSet&lt;String&gt;(len);</span><br><span class="line">    <span class="comment">// 循环调用，失败时则进行重试</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">//Reselect before retry to avoid a change of candidate `invokers`.</span></span><br><span class="line">        <span class="comment">//<span class="doctag">NOTE:</span> if `invokers` changed, then `invoked` also lose accuracy.</span></span><br><span class="line">        <span class="comment">// 重试时重新获取最新的服务提供者列表</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            checkWhetherDestroyed();</span><br><span class="line">            copyInvokers = list(invocation);</span><br><span class="line">            <span class="comment">// check again</span></span><br><span class="line">            checkInvokers(copyInvokers, invocation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过负载均衡器选中其中一个服务提供者</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked);</span><br><span class="line">        <span class="comment">// 添加到调用过的服务列表</span></span><br><span class="line">        invoked.add(invoker);</span><br><span class="line">        RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Result result = invoker.invoke(invocation);</span><br><span class="line">            <span class="keyword">if</span> (le != <span class="keyword">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                <span class="comment">//省略...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.isBiz()) &#123; <span class="comment">// biz exception.</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            le = e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            le = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            providers.add(invoker.getUrl().getAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重试失败则抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(le.getCode(), <span class="string">&quot;Failed to invoke the method &quot;</span></span><br><span class="line">            + methodName + <span class="string">&quot; in the service &quot;</span> + getInterface().getName()</span><br><span class="line">            + <span class="string">&quot;. Tried &quot;</span> + len + <span class="string">&quot; times of the providers &quot;</span> + providers</span><br><span class="line">            + <span class="string">&quot; (&quot;</span> + providers.size() + <span class="string">&quot;/&quot;</span> + copyInvokers.size()</span><br><span class="line">            + <span class="string">&quot;) from the registry &quot;</span> + directory.getUrl().getAddress()</span><br><span class="line">            + <span class="string">&quot; on the consumer &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot; using the dubbo version &quot;</span></span><br><span class="line">            + Version.getVersion() + <span class="string">&quot;. Last error is: &quot;</span></span><br><span class="line">            + le.getMessage(), le.getCause() != <span class="keyword">null</span> ? le.getCause() : le);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculateInvokeTimes</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认重试次数为2次，可以通过配置retries参数调整。</span></span><br><span class="line">    <span class="keyword">int</span> len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + <span class="number">1</span>;</span><br><span class="line">    RpcContext rpcContext = RpcContext.getContext();</span><br><span class="line">    Object retry = rpcContext.getObjectAttachment(RETRIES_KEY);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != retry &amp;&amp; retry <span class="keyword">instanceof</span> Number) &#123;</span><br><span class="line">        len = ((Number) retry).intValue() + <span class="number">1</span>;</span><br><span class="line">        rpcContext.removeAttachment(RETRIES_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        len = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>FailoverClusterInvoker 在调用失败时，会自动切换到另一个服务提供者进行重试；</p>
</li>
<li><p>默认重试次数为2次，可以通过配置retries参数调整。</p>
</li>
</ul>
<p>适用场景：适用于对请求响应时间要求不高，但对成功率有较高要求的场景。</p>
<h4 id="FailfastClusterInvoker"><a href="#FailfastClusterInvoker" class="headerlink" title="FailfastClusterInvoker"></a>FailfastClusterInvoker</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    checkInvokers(invokers, invocation);</span><br><span class="line">    Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RpcException &amp;&amp; ((RpcException) e).isBiz()) &#123; <span class="comment">// biz exception.</span></span><br><span class="line">            <span class="keyword">throw</span> (RpcException) e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e <span class="keyword">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class="number">0</span>,</span><br><span class="line">                <span class="string">&quot;Failfast invoke providers &quot;</span> + invoker.getUrl() + <span class="string">&quot; &quot;</span> + loadbalance.getClass().getSimpleName()</span><br><span class="line">                        + <span class="string">&quot; select from all providers &quot;</span> + invokers + <span class="string">&quot; for service &quot;</span> + getInterface().getName()</span><br><span class="line">                        + <span class="string">&quot; method &quot;</span> + invocation.getMethodName() + <span class="string">&quot; on consumer &quot;</span> + NetUtils.getLocalHost()</span><br><span class="line">                        + <span class="string">&quot; use dubbo version &quot;</span> + Version.getVersion()</span><br><span class="line">                        + <span class="string">&quot;, but no luck to perform the invocation. Last error is: &quot;</span> + e.getMessage(),</span><br><span class="line">                e.getCause() != <span class="keyword">null</span> ? e.getCause() : e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FailfastClusterInvoker 只会发起一次调用，如果调用失败则立即抛出异常，不再重试。</p>
<p>适用场景：适用于对响应时间有一定要求的场景。</p>
<h4 id="FailsafeClusterInvoker"><a href="#FailsafeClusterInvoker" class="headerlink" title="FailsafeClusterInvoker"></a>FailsafeClusterInvoker</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkInvokers(invokers, invocation);</span><br><span class="line">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Failsafe ignore exception: &quot;</span> + e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, <span class="keyword">null</span>, invocation); <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FailsafeClusterInvoker 同样也只会发起一次调用，它跟 FailfastClusterInvoker 的区别在于，如果调用失败了，只会记录日志，而不会抛出异常。</p>
<p>适用场景：适用于对调用结果一致性要求不高场景。</p>
<h4 id="FailbackClusterInvoker"><a href="#FailbackClusterInvoker" class="headerlink" title="FailbackClusterInvoker"></a>FailbackClusterInvoker</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    Invoker&lt;T&gt; invoker = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkInvokers(invokers, invocation);</span><br><span class="line">        invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Failback to invoke method &quot;</span> + invocation.getMethodName() + <span class="string">&quot;, wait for retry in background. Ignored exception: &quot;</span></span><br><span class="line">                + e.getMessage() + <span class="string">&quot;, &quot;</span>, e);</span><br><span class="line">        <span class="comment">// 调用失败时，添加到失败队列</span></span><br><span class="line">        addFailed(loadbalance, invocation, invokers, invoker);</span><br><span class="line">        <span class="comment">// 返回空结果</span></span><br><span class="line">        <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, <span class="keyword">null</span>, invocation); <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFailed</span><span class="params">(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, Invoker&lt;T&gt; lastInvoker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (failTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                failTimer = <span class="keyword">new</span> HashedWheelTimer(</span><br><span class="line">                    <span class="keyword">new</span> NamedThreadFactory(<span class="string">&quot;failback-cluster-timer&quot;</span>, <span class="keyword">true</span>),</span><br><span class="line">                    <span class="number">1</span>,</span><br><span class="line">                    TimeUnit.SECONDS, <span class="number">32</span>, failbackTasks);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建延迟执行任务</span></span><br><span class="line">    RetryTimerTask retryTimerTask = <span class="keyword">new</span> RetryTimerTask(loadbalance, invocation, invokers, lastInvoker, retries, RETRY_FAILED_PERIOD);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 5 秒后执行</span></span><br><span class="line">        failTimer.newTimeout(retryTimerTask, RETRY_FAILED_PERIOD, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Failback background works error,invocation-&gt;&quot;</span> + invocation + <span class="string">&quot;, exception: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FailbackClusterInvoker 在调用失败时，会立即返回空结果，同时将此次调用添加到失败列表，并在 5 秒后进行重试，重试次数可以通过 retries 指定。</p>
<p>适用场景：适用于对调用结果一致性要求比较高的，且对响应时间要求不高的场景。</p>
<h4 id="ForkingClusterInvoker"><a href="#ForkingClusterInvoker" class="headerlink" title="ForkingClusterInvoker"></a>ForkingClusterInvoker</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkInvokers(invokers, invocation);</span><br><span class="line">        <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; selected;</span><br><span class="line">        <span class="comment">// 并行调用的服务数，通过forks参数配置，默认为2</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> forks = getUrl().getParameter(FORKS_KEY, DEFAULT_FORKS);</span><br><span class="line">        <span class="comment">// 超时</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> timeout = getUrl().getParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);</span><br><span class="line">        <span class="comment">// 并行调用数大于服务提供者数量时，调用所有服务提供者</span></span><br><span class="line">        <span class="keyword">if</span> (forks &lt;= <span class="number">0</span> || forks &gt;= invokers.size()) &#123;</span><br><span class="line">            selected = invokers;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 通过负载均衡器选中并行调用的服务提供者</span></span><br><span class="line">            selected = <span class="keyword">new</span> ArrayList&lt;&gt;(forks);</span><br><span class="line">            <span class="keyword">while</span> (selected.size() &lt; forks) &#123;</span><br><span class="line">                Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, selected);</span><br><span class="line">                <span class="keyword">if</span> (!selected.contains(invoker)) &#123;</span><br><span class="line">                    <span class="comment">//Avoid add the same invoker several times.</span></span><br><span class="line">                    selected.add(invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RpcContext.getContext().setInvokers((List) selected);</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">final</span> BlockingQueue&lt;Object&gt; ref = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Invoker&lt;T&gt; invoker : selected) &#123;</span><br><span class="line">            <span class="comment">// 通过线程池异步发起调用</span></span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Result result = invoker.invoke(invocation);</span><br><span class="line">                    <span class="comment">// 调用结果放入结果队列</span></span><br><span class="line">                    ref.offer(result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="keyword">int</span> value = count.incrementAndGet();</span><br><span class="line">                    <span class="comment">// 如果全都失败了，将异常放入结果队列</span></span><br><span class="line">                    <span class="keyword">if</span> (value &gt;= selected.size()) &#123;</span><br><span class="line">                        ref.offer(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 阻塞等待结果</span></span><br><span class="line">            Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> Throwable) &#123;</span><br><span class="line">                Throwable e = (Throwable) ret;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e <span class="keyword">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class="number">0</span>, <span class="string">&quot;Failed to forking invoke provider &quot;</span> + selected + <span class="string">&quot;, but no luck to perform the invocation. Last error is: &quot;</span> + e.getMessage(), e.getCause() != <span class="keyword">null</span> ? e.getCause() : e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (Result) ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Failed to forking invoke provider &quot;</span> + selected + <span class="string">&quot;, but no luck to perform the invocation. Last error is: &quot;</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// clear attachments which is binding to current thread.</span></span><br><span class="line">        RpcContext.getContext().clearAttachments();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ForkingClusterInvoker 会通过线程池异步同时调用多个服务提供者，返回第一个调用成功的结果，如果全部失败，则返回失败。</p>
<p>适用场景：适用于对响应时间要求比较高，且服务提供者数量比较多的场景。</p>
<h4 id="BroadcastClusterInvoker"><a href="#BroadcastClusterInvoker" class="headerlink" title="BroadcastClusterInvoker"></a>BroadcastClusterInvoker</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    checkInvokers(invokers, invocation);</span><br><span class="line">    RpcContext.getContext().setInvokers((List) invokers);</span><br><span class="line">    RpcException exception = <span class="keyword">null</span>;</span><br><span class="line">    Result result = <span class="keyword">null</span>;</span><br><span class="line">    URL url = getUrl();</span><br><span class="line">    <span class="comment">// The value range of broadcast.fail.threshold must be 0～100.</span></span><br><span class="line">    <span class="comment">// 100 means that an exception will be thrown last, and 0 means that as long as an exception occurs, it will be thrown.</span></span><br><span class="line">    <span class="comment">// see https://github.com/apache/dubbo/pull/7174</span></span><br><span class="line">    <span class="comment">// 失败的阈值，如果失败次数达到阈值，将停止继续调用并直接返回失败</span></span><br><span class="line">    <span class="keyword">int</span> broadcastFailPercent = url.getParameter(BROADCAST_FAIL_PERCENT_KEY, MAX_BROADCAST_FAIL_PERCENT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (broadcastFailPercent &lt; MIN_BROADCAST_FAIL_PERCENT || broadcastFailPercent &gt; MAX_BROADCAST_FAIL_PERCENT) &#123;</span><br><span class="line">        logger.info(String.format(<span class="string">&quot;The value corresponding to the broadcast.fail.percent parameter must be between 0 and 100. &quot;</span> +</span><br><span class="line">                <span class="string">&quot;The current setting is %s, which is reset to 100.&quot;</span>, broadcastFailPercent));</span><br><span class="line">        broadcastFailPercent = MAX_BROADCAST_FAIL_PERCENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> failThresholdIndex = invokers.size() * broadcastFailPercent / MAX_BROADCAST_FAIL_PERCENT;</span><br><span class="line">    <span class="comment">// 记录调用失败的次数</span></span><br><span class="line">    <span class="keyword">int</span> failIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 向所有的服务提供者发起调用</span></span><br><span class="line">    <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = invoker.invoke(invocation);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != result &amp;&amp; result.hasException()) &#123;</span><br><span class="line">                Throwable resultException = result.getException();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != resultException) &#123;</span><br><span class="line">                    exception = getRpcException(result.getException());</span><br><span class="line">                    logger.warn(exception.getMessage(), exception);</span><br><span class="line">                    <span class="keyword">if</span> (failIndex == failThresholdIndex) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        failIndex++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            exception = getRpcException(e);</span><br><span class="line">            logger.warn(exception.getMessage(), exception);</span><br><span class="line">            <span class="keyword">if</span> (failIndex == failThresholdIndex) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                failIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (failIndex == failThresholdIndex) &#123;</span><br><span class="line">            logger.debug(</span><br><span class="line">                    String.format(<span class="string">&quot;The number of BroadcastCluster call failures has reached the threshold %s&quot;</span>, failThresholdIndex));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(String.format(<span class="string">&quot;The number of BroadcastCluster call failures has not reached the threshold %s, fail size is %s&quot;</span>,</span><br><span class="line">                    failIndex));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BroadcastClusterInvoker 会调用所有的服务提供者，如果有其中一个调用失败，便返回失败。</p>
<p>适用场景：适用于发布/订阅的场景。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文通过源码简单介绍了Dubbo提供的多种集群容错策略及其适用场景，在实际使用中，合理选择和配置这些策略可以有效提高系统的稳定性和可用性。</p>
]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka源码学习：时间轮</title>
    <url>/2024/12/15/Kafka%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%97%B6%E9%97%B4%E8%BD%AE/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 Kafka 中，有许多地方都需要用到延时操作，如延时生产、延时拉取等。Kafka 作为一个高性能的消息队列，并没有使用 JDK 中自带的 DelayQueue 来实现延时的功能，而是基于时间轮的概念实现了一个更高效的数据结构。</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Kafka 2.5.1版本</p>
</blockquote>
<h3 id="时间轮简介"><a href="#时间轮简介" class="headerlink" title="时间轮简介"></a>时间轮简介</h3><p>时间轮将时间抽象为一个环形结构，底层由数组实现，数组中的每个元素都存放了一个定时任务列表（TimerTaskList），TimerTaskList 是一个环形的双向链表，链表中的每一个节点（TimerTaskEntry）都存放着一个定时任务（TimerTask）。</p>
<p>时间轮有多个时间格，数组中的每个元素对应着一个时间格（bucket），每个时间格代表当前时间轮的基本时间跨度（tickMs），时间轮的时间格个数是固定的，可用 wheelSize 表示，那么可以算出每个时间轮的总时间跨度则为 interval = wheelSize * tickMs。时间轮还有一个表盘指针（currentTime），用来表示时间轮当前所处的时间，同时也表示指向的时间格任务到期需要执行，随着时间的推移，这个指针也会不断推进。</p>
<p><img src="http://storage.laixiaoming.space/blog/kafka%E6%97%B6%E9%97%B4%E8%BD%AE%E7%BB%93%E6%9E%84.png" alt="kafka时间轮结构"></p>
<p>如图中所示，假设时间格为 1 ms，一个时间轮为 8 格，则整个时间轮的最大延时时间为 8ms，那如果延时时间大于该时间轮所能表示的最大时间跨度怎么办呢？</p>
<p>实际上 Kafka 中的时间轮为多层级时间轮，当任务的延时时间超过当前时间轮的最大时间跨度时，会尝试将该任务添加到上层时间轮，与当前时间轮不同的是，上层时间轮的基本时间跨度（tickMs）为当前时间轮的最大时间跨度，即 8ms，此时上层的总时间跨度为 8ms * 8 = 64 ms。</p>
<h3 id="时间轮的实现"><a href="#时间轮的实现" class="headerlink" title="时间轮的实现"></a>时间轮的实现</h3><h4 id="TimerTask"><a href="#TimerTask" class="headerlink" title="TimerTask"></a>TimerTask</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TimerTask</span> <span class="keyword">extends</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定时任务超时时间</span></span><br><span class="line">  <span class="keyword">val</span> delayMs: <span class="type">Long</span> <span class="comment">// timestamp in millisecond</span></span><br><span class="line">  <span class="comment">// 关联TimerTaskEntry</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> timerTaskEntry: <span class="type">TimerTaskEntry</span> = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 取消定时任务</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    synchronized &#123;</span><br><span class="line">      <span class="keyword">if</span> (timerTaskEntry != <span class="literal">null</span>) timerTaskEntry.remove()</span><br><span class="line">      timerTaskEntry = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 关联TimerTaskEntry</span></span><br><span class="line">  <span class="keyword">private</span>[timer] <span class="function"><span class="keyword">def</span> <span class="title">setTimerTaskEntry</span></span>(entry: <span class="type">TimerTaskEntry</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    synchronized &#123;</span><br><span class="line">      <span class="comment">// if this timerTask is already held by an existing timer task entry,</span></span><br><span class="line">      <span class="comment">// we will remove such an entry first.</span></span><br><span class="line">      <span class="keyword">if</span> (timerTaskEntry != <span class="literal">null</span> &amp;&amp; timerTaskEntry != entry)</span><br><span class="line">        timerTaskEntry.remove()</span><br><span class="line"></span><br><span class="line">      timerTaskEntry = entry</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取关联的TimerTaskEntry</span></span><br><span class="line">  <span class="keyword">private</span>[timer] <span class="function"><span class="keyword">def</span> <span class="title">getTimerTaskEntry</span></span>(): <span class="type">TimerTaskEntry</span> = &#123;</span><br><span class="line">    timerTaskEntry</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 TimerTask 都关联了一个 TimerTaskEntry，通过 TimerTask 也可以知道当前任务在 TimerTaskList 中存放的位置。</p>
<h4 id="TimerTaskEntry"><a href="#TimerTaskEntry" class="headerlink" title="TimerTaskEntry"></a>TimerTaskEntry</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private[timer] class TimerTaskEntry(val timerTask: TimerTask, val expirationMs: Long) extends Ordered[TimerTaskEntry] &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当前 bucket 对应的链表</span><br><span class="line">  @volatile</span><br><span class="line">  var list: TimerTaskList &#x3D; null</span><br><span class="line">  &#x2F;&#x2F; 后指针</span><br><span class="line">  var next: TimerTaskEntry &#x3D; null</span><br><span class="line">  &#x2F;&#x2F; 前指针</span><br><span class="line">  var prev: TimerTaskEntry &#x3D; null</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; if this timerTask is already held by an existing timer task entry,</span><br><span class="line">  &#x2F;&#x2F; setTimerTaskEntry will remove it.</span><br><span class="line">  if (timerTask !&#x3D; null) timerTask.setTimerTaskEntry(this)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当前任务是不被取消</span><br><span class="line">  def cancelled: Boolean &#x3D; &#123;</span><br><span class="line">    timerTask.getTimerTaskEntry !&#x3D; this</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 从链表中移除</span><br><span class="line">  def remove(): Unit &#x3D; &#123;</span><br><span class="line">    var currentList &#x3D; list</span><br><span class="line">    &#x2F;&#x2F; If remove is called when another thread is moving the entry from a task entry list to another,</span><br><span class="line">    &#x2F;&#x2F; this may fail to remove the entry due to the change of value of list. Thus, we retry until the list becomes null.</span><br><span class="line">    &#x2F;&#x2F; In a rare case, this thread sees null and exits the loop, but the other thread insert the entry to another list later.</span><br><span class="line">    while (currentList !&#x3D; null) &#123;</span><br><span class="line">      currentList.remove(this)</span><br><span class="line">      currentList &#x3D; list</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是 TimerTaskList 被 volatile 修饰，因为在 Kafka 中，当上层时间轮剩余时间小于基本时间跨度（tickMs），又没到执行时间时，就会将该任务重新添加到下层时间轮中，最终由下层时间轮推进执行，因此，这里才有需要保证线程之间的内在可见性。</p>
<h4 id="TimerTaskList"><a href="#TimerTaskList" class="headerlink" title="TimerTaskList"></a>TimerTaskList</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>[timer] <span class="class"><span class="keyword">class</span> <span class="title">TimerTaskList</span>(<span class="params">taskCounter: <span class="type">AtomicInteger</span></span>) <span class="keyword">extends</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TimerTaskList forms a doubly linked cyclic list using a dummy root entry</span></span><br><span class="line">  <span class="comment">// root.next points to the head</span></span><br><span class="line">  <span class="comment">// root.prev points to the tail</span></span><br><span class="line">  <span class="comment">// dummyNode ，简化边界条件</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> root = <span class="keyword">new</span> <span class="type">TimerTaskEntry</span>(<span class="literal">null</span>, <span class="number">-1</span>)</span><br><span class="line">  root.next = root</span><br><span class="line">  root.prev = root</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TimerTaskList 的过期时间</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> expiration = <span class="keyword">new</span> <span class="type">AtomicLong</span>(<span class="number">-1</span>L)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Set the bucket&#x27;s expiration time</span></span><br><span class="line">  <span class="comment">// Returns true if the expiration time is changed</span></span><br><span class="line">  <span class="comment">// 设置过期时间</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setExpiration</span></span>(expirationMs: <span class="type">Long</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    expiration.getAndSet(expirationMs) != expirationMs</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the bucket&#x27;s expiration time</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getExpiration</span></span>(): <span class="type">Long</span> = &#123;</span><br><span class="line">    expiration.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getDelay</span></span>(unit: <span class="type">TimeUnit</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">    unit.convert(max(getExpiration - <span class="type">Time</span>.<span class="type">SYSTEM</span>.hiResClockMs, <span class="number">0</span>), <span class="type">TimeUnit</span>.<span class="type">MILLISECONDS</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compareTo</span></span>(d: <span class="type">Delayed</span>): <span class="type">Int</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> other = d.asInstanceOf[<span class="type">TimerTaskList</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getExpiration &lt; other.getExpiration) <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(getExpiration &gt; other.getExpiration) <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TimerTaskList 实现了 Delayed 接口，这里因为在 Kafka 中，时间轮的推进是通过 DelayQueue 进行的，每个 TimerTaskList 都会添加到 DelayQueue 。在设置过期时间时，会对新旧值进行判断，因为 bucket 是可以重用的，只有更新过期时间成功后，才会将该 bucket 重新添加到 DelayQueue。</p>
<h4 id="TimingWheel"><a href="#TimingWheel" class="headerlink" title="TimingWheel"></a>TimingWheel</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="meta">@nonthreadsafe</span></span><br><span class="line"><span class="keyword">private</span>[timer] <span class="class"><span class="keyword">class</span> <span class="title">TimingWheel</span>(<span class="params">tickMs: <span class="type">Long</span>, wheelSize: <span class="type">Int</span>, startMs: <span class="type">Long</span>, taskCounter: <span class="type">AtomicInteger</span>, queue: <span class="type">DelayQueue</span>[<span class="type">TimerTaskList</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 时间轮的总时间跨度</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> interval = tickMs * wheelSize</span><br><span class="line">  <span class="comment">// 时间格</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> buckets = <span class="type">Array</span>.tabulate[<span class="type">TimerTaskList</span>](wheelSize) &#123; _ =&gt; <span class="keyword">new</span> <span class="type">TimerTaskList</span>(taskCounter) &#125;</span><br><span class="line">  <span class="comment">// 当前时间，取小于当前时间的，最大基本时间跨度的整数倍</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> currentTime = startMs - (startMs % tickMs) <span class="comment">// rounding down to multiple of tickMs</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上层时间轮</span></span><br><span class="line">  <span class="comment">// overflowWheel can potentially be updated and read by two concurrent threads through add().</span></span><br><span class="line">  <span class="comment">// Therefore, it needs to be volatile due to the issue of Double-Checked Locking pattern with JVM</span></span><br><span class="line">  <span class="meta">@volatile</span> <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> overflowWheel: <span class="type">TimingWheel</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="添加延时任务"><a href="#添加延时任务" class="headerlink" title="添加延时任务"></a>添加延时任务</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加延时任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(timerTaskEntry: <span class="type">TimerTaskEntry</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> expiration = timerTaskEntry.expirationMs</span><br><span class="line">  <span class="comment">// 任务是否取消</span></span><br><span class="line">  <span class="keyword">if</span> (timerTaskEntry.cancelled) &#123;</span><br><span class="line">    <span class="comment">// Cancelled</span></span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expiration &lt; currentTime + tickMs) &#123;</span><br><span class="line">    <span class="comment">// 任务过期</span></span><br><span class="line">    <span class="comment">// Already expired</span></span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expiration &lt; currentTime + interval) &#123;</span><br><span class="line">    <span class="comment">// Put in its own bucket</span></span><br><span class="line">    <span class="comment">// 添加任务到当前时间轮</span></span><br><span class="line">    <span class="keyword">val</span> virtualId = expiration / tickMs</span><br><span class="line">    <span class="comment">// 定位存放的 bucket</span></span><br><span class="line">    <span class="keyword">val</span> bucket = buckets((virtualId % wheelSize.toLong).toInt)</span><br><span class="line">    bucket.add(timerTaskEntry)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置过期时间，此时的过期时间也设置为 tickMs 时间格的整数倍</span></span><br><span class="line">    <span class="comment">// Set the bucket expiration time</span></span><br><span class="line">    <span class="keyword">if</span> (bucket.setExpiration(virtualId * tickMs)) &#123;</span><br><span class="line">      <span class="comment">// The bucket needs to be enqueued because it was an expired bucket</span></span><br><span class="line">      <span class="comment">// We only need to enqueue the bucket when its expiration time has changed, i.e. the wheel has advanced</span></span><br><span class="line">      <span class="comment">// and the previous buckets gets reused; further calls to set the expiration within the same wheel cycle</span></span><br><span class="line">      <span class="comment">// will pass in the same value and hence return false, thus the bucket with the same expiration will not</span></span><br><span class="line">      <span class="comment">// be enqueued multiple times.</span></span><br><span class="line">      <span class="comment">// 添加到 DelayQueue</span></span><br><span class="line">      queue.offer(bucket)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Out of the interval. Put it into the parent timer</span></span><br><span class="line">    <span class="keyword">if</span> (overflowWheel == <span class="literal">null</span>) addOverflowWheel()</span><br><span class="line">    <span class="comment">// 添加任务到上层时间轮</span></span><br><span class="line">    overflowWheel.add(timerTaskEntry)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建上层时间轮，上层时间轮的基本时间跨度为当前时间轮的总时间跨度</span></span><br><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">addOverflowWheel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  synchronized &#123;</span><br><span class="line">    <span class="keyword">if</span> (overflowWheel == <span class="literal">null</span>) &#123;</span><br><span class="line">      overflowWheel = <span class="keyword">new</span> <span class="type">TimingWheel</span>(</span><br><span class="line">        tickMs = interval,</span><br><span class="line">        wheelSize = wheelSize,</span><br><span class="line">        startMs = currentTime,</span><br><span class="line">        taskCounter = taskCounter,</span><br><span class="line">        queue</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="当前时间的推进"><a href="#当前时间的推进" class="headerlink" title="当前时间的推进"></a>当前时间的推进</h5><p>前面我们提到，时间轮的推进是通过 DelayQueue 协助完成的，每一个 TimerTaskList 都会被添加到 DelayQueue ，并根据过期时间进行排序，Kafka 会用一个后台线程来获取 DelayQueue 中到期的任务列表，这个线程为 ExpiredOperationReaper：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A background reaper to expire delayed operations that have timed out</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpiredOperationReaper</span> <span class="keyword">extends</span> <span class="title">ShutdownableThread</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">  &quot;<span class="type">ExpirationReaper</span>-%d-%s&quot;.format(brokerId, purgatoryName</span>),</span></span><br><span class="line"><span class="class">  <span class="title">false</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">doWork</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    advanceClock(<span class="number">200</span>L)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SystemTimer#advanceClock：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">advanceClock</span></span>(timeoutMs: <span class="type">Long</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  <span class="comment">// 获取到期的任务</span></span><br><span class="line">  <span class="keyword">var</span> bucket = delayQueue.poll(timeoutMs, <span class="type">TimeUnit</span>.<span class="type">MILLISECONDS</span>)</span><br><span class="line">  <span class="keyword">if</span> (bucket != <span class="literal">null</span>) &#123;</span><br><span class="line">    writeLock.lock()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (bucket != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 驱动时间轮</span></span><br><span class="line">        timingWheel.advanceClock(bucket.getExpiration())</span><br><span class="line">        <span class="comment">// 执行到期任务</span></span><br><span class="line">        bucket.flush(reinsert)</span><br><span class="line">        <span class="comment">// 继续获取到期任务，直到为空</span></span><br><span class="line">        bucket = delayQueue.poll()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      writeLock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TimerTaskList#flush：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flush</span></span>(f: (<span class="type">TimerTaskEntry</span>)=&gt;<span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  synchronized &#123;</span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">var</span> head = root.next</span><br><span class="line">    <span class="keyword">while</span> (head ne root) &#123;</span><br><span class="line">      <span class="comment">// 移除</span></span><br><span class="line">      remove(head)</span><br><span class="line">      <span class="comment">// 到期任务执行或降级时间轮</span></span><br><span class="line">      f(head)</span><br><span class="line">      <span class="comment">// 处理下一个节点</span></span><br><span class="line">      head = root.next</span><br><span class="line">    &#125;</span><br><span class="line">    expiration.set(<span class="number">-1</span>L)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SystemTimer#addTimerTaskEntry：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">addTimerTaskEntry</span></span>(timerTaskEntry: <span class="type">TimerTaskEntry</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">// 将任务重新添加到时间轮</span></span><br><span class="line">  <span class="keyword">if</span> (!timingWheel.add(timerTaskEntry)) &#123;</span><br><span class="line">    <span class="comment">// Already expired or cancelled</span></span><br><span class="line">    <span class="keyword">if</span> (!timerTaskEntry.cancelled)</span><br><span class="line">      <span class="comment">// 执行到期任务</span></span><br><span class="line">      taskExecutor.submit(timerTaskEntry.timerTask)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> reinsert = (timerTaskEntry: <span class="type">TimerTaskEntry</span>) =&gt; addTimerTaskEntry(timerTaskEntry)</span><br></pre></td></tr></table></figure>

<p>随着时间的推进，到期任务将尝试重新添加到时间轮，此时有两种情况：</p>
<ul>
<li>任务到期，或任务被取消，如果任务未取消，则执行到期任务；</li>
<li>任务未到期，任务被重新添加到下级时间轮（时间轮降级）；</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Kafka 的延时任务实现实际上没有完全抛弃 DelayQueue ，一方面采用了 环形数组 + 双向链接的数据结构，使得延时任务的插入和删除操作能达到 O(1) 的时间复杂度；另一方面，由 DelayQueue 负表时间的推进，只有 bucket 任务到期才会返回任务结果，有效减少了“空推进”的问题，并且同一个 bucket 的多个任务在 DelayQueue 也只会入队一次，避免了 DelayQueue 的开销占用过高。时间轮与 DelayQueue 两者相铺相成，能高效地管理延时任务。</p>
]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>问题记录：ConcurrentHashMap 死循环</title>
    <url>/2024/12/21/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9AConcurrentHashMap%20%E6%AD%BB%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h3 id="问题的出现和定位"><a href="#问题的出现和定位" class="headerlink" title="问题的出现和定位"></a>问题的出现和定位</h3><p>测试环境中，有测试同学反馈说接口请求慢，超时了也没有数据返回。</p>
<p>首先从测试同学那里了解到具体慢的接口，排查了对应的服务的状态，确定了服务的状态是正常在线的。</p>
<p>进入该服务对应的容器内，用 <strong>jstat -gctil</strong> 命令查看了服务进程的 GC 情况，发现不管是内存占用，或是 GC 的频率和时间占比，都不高。</p>
<p>然后又通过 <strong>top</strong> 看了下 CPU 的使用率，发现服务的进程整体使用率到了 90% 以上，随即通过 <strong>top -Hp 1</strong> 指定进程，定位到了占用的的具体线程id是 <strong>196</strong>：</p>
<span id="more"></span>



<p><img src="http://storage.laixiaoming.space/blog/image-20241221162635379.png" alt="image-20241221162635379"></p>
<p>有了线程 id 后，又通过 <strong>jstack 1 jstack.log</strong> 导出了该服务的线程堆栈信息，通过转换后的 16 进制的线程 id （c4）定位到了占用高的这个线程的堆栈信息：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20241221163133550.png" alt="image-20241221163133550"></p>
<p>发现了该线程此时正在执行 <strong>java.util.concurrent.ConcurrentHashMap.computeIfAbsent</strong> 方法。难不成陷入了死循环？</p>
<p>带着疑惑翻开 computeIfAbsent 对应的源码，该方法的逻辑是如果指定的 key 在 map 中不存在，则通过 mappingFunction 方法计算出一个新值，并将其放入 map 中。该方法代码行数不多，逻辑清晰：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null || mappingFunction &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#x2F;&#x2F; 计算 key 的 hash 值</span><br><span class="line">    int h &#x3D; spread(key.hashCode());</span><br><span class="line">    V val &#x3D; null;</span><br><span class="line">    int binCount &#x3D; 0;</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        &#x2F;&#x2F; 初始化 </span><br><span class="line">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">            tab &#x3D; initTable();</span><br><span class="line">        &#x2F;&#x2F; 定位到桶</span><br><span class="line">        else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; h)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">        	&#x2F;&#x2F;占位节点</span><br><span class="line">            Node&lt;K,V&gt; r &#x3D; new ReservationNode&lt;K,V&gt;();</span><br><span class="line">            synchronized (r) &#123;</span><br><span class="line">                if (casTabAt(tab, i, null, r)) &#123;</span><br><span class="line">                    binCount &#x3D; 1;</span><br><span class="line">                    Node&lt;K,V&gt; node &#x3D; null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        if ((val &#x3D; mappingFunction.apply(key)) !&#x3D; null)</span><br><span class="line">                            node &#x3D; new Node&lt;K,V&gt;(h, key, val, null);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        setTabAt(tab, i, node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (binCount !&#x3D; 0)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 正在护容</span><br><span class="line">        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)</span><br><span class="line">            tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">        else &#123;</span><br><span class="line">            boolean added &#x3D; false;</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class="line">                	&#x2F;&#x2F; 链表节点</span><br><span class="line">                    if (fh &gt;&#x3D; 0) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 省略...</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 红黑树节点</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 省略...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (binCount !&#x3D; 0) &#123;</span><br><span class="line">                if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (!added)</span><br><span class="line">                    return val;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (val !&#x3D; null)</span><br><span class="line">        addCount(1L, binCount);</span><br><span class="line">    return val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回看导出的线程堆栈信息，发现这个线程进入了两次 computeIfAbsent 方法，而且此时该线程第一次进入到 computeIfAbsent 后停留在了 mappingFunction 的执行，合理猜测是因为 mappingFunction 中包含了对同一个 map 的 computeIfAbsent ，而正是对同一个 map 进行 computeIfAbsent 递归操作导致了问题的产生。</p>
<p>结合现有信息，到网上（<a href="https://juejin.cn/post/6844904191077384200">原文</a>）查了下，发现 ConcurrentHashMap 的 computeIfAbsent 方法果然有死循环这个问题！</p>
<p>好了，现在我们来看下ConcurrentHashMap 是怎么让自己陷入死循环的：</p>
<ol>
<li>第一次执行 computeIfAbsent 方法：此时 key 值不存在，会先往对应位放入一个预留节点 ReservationNode ，接着执行 mappingFunction 方法：</li>
</ol>
<p><img src="http://storage.laixiaoming.space/blog/image-20241221174003993.png" alt="image-20241221174003993"></p>
<ol start="2">
<li> 当此时 mappingFunction 包含了对同一个 map 的 computeIfAbsent 操作时，会第二次进入 computeIfAbsent 方法，而且当该 computeIfAbsent 操作的 key 与第一次进来时的 key 的 hash 值冲突时，此时两次操作定位到的槽会是同一个，再次进入 for 循环，进入之后一路执行，但发现所有的条件均不满足，也就只能无奈陷入了死循环了：</li>
</ol>
<p><img src="http://storage.laixiaoming.space/blog/image-20241221175332687.png" alt="image-20241221175332687"></p>
<h3 id="问题的源头"><a href="#问题的源头" class="headerlink" title="问题的源头"></a>问题的源头</h3><p>那哪里会存在 computeIfAbsent 的递归调用呢？</p>
<p>通过线程的堆栈可以发现，两次的调用都是由 DataSource#getConnection 发起的，原来是因为该服务引入了 Seata ，而 Seata 默认会对所有数据源进行代理，并将代理后的对象存入 ConcurrentHashMap ，而存入的方式就是通过 computeIfAbsent 完成的，而且巧的是该服务同时也引入了 DynamicDataSource 动态数据源，动态数据源内部会维护多个真实的数据源，所以对动态数据源的操作都会转发到真实的数据源：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20241221180132904.png" alt="image-20241221180132904"></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>定位到问题的原因就简单了，既然是因为 Seata 对多个数据源的代理导致，那么只针对真实数据源进行代理理论上就可以解决该问题了，而 Seata 也恰好支持通过配置不代理指定的数据源，对应的配置是 <strong>seata.excludes-for-auto-proxying</strong> 。</p>
<p>而在 JDK9 中，作者实际上也修复了该问题，修复的方式也很简单粗暴，就是只要发现了递归调用的情况，直接抛异常：</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20241221181724042.png" alt="image-20241221181724042"></p>
<p>另外，在 JDK 8 中，computeIfAbsent 方法实际上也通过注释说明了 mappingFunction 不能包含对同一个 map 的递归操作，所以这个好像严格意义上也不算 bug ？只是使用姿势不对？</p>
<p><img src="http://storage.laixiaoming.space/blog/image-20241221182622468.png" alt="image-20241221182622468"></p>
]]></content>
      <tags>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo源码学习：对于异常的处理</title>
    <url>/2024/12/22/Dubbo%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%AF%B9%E4%BA%8E%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在使用 Dubbo 进行服务间的调用时，如果 Provider 服务端抛出了特定异常，但在 Consumer 调用端可能拿到的并不是我们预期的异常类型，那Dubbo 对于服务端的异常是如何处理的呢？如果我们希望在调用端也能获取到对应的异常信息，可以怎么做呢？本文一起来看下。</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Dubbo 2.7.12版本</p>
</blockquote>
<h3 id="异常的包装"><a href="#异常的包装" class="headerlink" title="异常的包装"></a>异常的包装</h3><p>在服务端，Dubbo 是通过 <strong>org.apache.dubbo.rpc.filter.ExceptionFilter</strong> 进行处理的，当拿到调用结果后，会通过 <strong>ExceptionFilter#onResponse</strong> 对异常进行二次包装：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Result appResponse, Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有异常的情况下执行</span></span><br><span class="line">    <span class="keyword">if</span> (appResponse.hasException() &amp;&amp; GenericService.class != invoker.getInterface()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Throwable exception = appResponse.getException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是受检异常，不处理</span></span><br><span class="line">            <span class="comment">// directly throw if it&#x27;s checked exception</span></span><br><span class="line">            <span class="keyword">if</span> (!(exception <span class="keyword">instanceof</span> RuntimeException) &amp;&amp; (exception <span class="keyword">instanceof</span> Exception)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// directly throw if the exception appears in the signature</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取服务接口上的异常声明</span></span><br><span class="line">                Method method = invoker.getInterface().getMethod(invocation.getMethodName(), invocation.getParameterTypes());</span><br><span class="line">                Class&lt;?&gt;[] exceptionClasses = method.getExceptionTypes();</span><br><span class="line">                <span class="keyword">for</span> (Class&lt;?&gt; exceptionClass : exceptionClasses) &#123;</span><br><span class="line">                    <span class="comment">// 如果是声明的异常，不处理</span></span><br><span class="line">                    <span class="keyword">if</span> (exception.getClass().equals(exceptionClass)) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// for the exception not found in method&#x27;s signature, print ERROR message in server&#x27;s log.</span></span><br><span class="line">            logger.error(<span class="string">&quot;Got unchecked and undeclared exception which called by &quot;</span> + RpcContext.getContext().getRemoteHost() + <span class="string">&quot;. service: &quot;</span> + invoker.getInterface().getName() + <span class="string">&quot;, method: &quot;</span> + invocation.getMethodName() + <span class="string">&quot;, exception: &quot;</span> + exception.getClass().getName() + <span class="string">&quot;: &quot;</span> + exception.getMessage(), exception);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异常和接口是不在同一个包下，如果是的话，不处理</span></span><br><span class="line">            <span class="comment">// directly throw if exception class and interface class are in the same jar file.</span></span><br><span class="line">            String serviceFile = ReflectUtils.getCodeBase(invoker.getInterface());</span><br><span class="line">            String exceptionFile = ReflectUtils.getCodeBase(exception.getClass());</span><br><span class="line">            <span class="keyword">if</span> (serviceFile == <span class="keyword">null</span> || exceptionFile == <span class="keyword">null</span> || serviceFile.equals(exceptionFile)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是 JDK 内置异常类型，不处理</span></span><br><span class="line">            <span class="comment">// directly throw if it&#x27;s JDK exception</span></span><br><span class="line">            String className = exception.getClass().getName();</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(<span class="string">&quot;java.&quot;</span>) || className.startsWith(<span class="string">&quot;javax.&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是 RpcException，不处理</span></span><br><span class="line">            <span class="comment">// directly throw if it&#x27;s dubbo exception</span></span><br><span class="line">            <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RpcException) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// otherwise, wrap with RuntimeException and throw back to the client</span></span><br><span class="line">            <span class="comment">// 其他异常，将其包装为 RunctionException 并返回</span></span><br><span class="line">            appResponse.setException(<span class="keyword">new</span> RuntimeException(StringUtils.toString(exception)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Fail to ExceptionFilter when called by &quot;</span> + RpcContext.getContext().getRemoteHost() + <span class="string">&quot;. service: &quot;</span> + invoker.getInterface().getName() + <span class="string">&quot;, method: &quot;</span> + invocation.getMethodName() + <span class="string">&quot;, exception: &quot;</span> + e.getClass().getName() + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中，我们可以看到，Dubbo 对象异常的处理，主要分为几种情况：</p>
<ol>
<li>如果是受检异常，不处理，直接抛出；</li>
<li>如果如果该异常在接口中声明了，不处理，直接抛出；</li>
<li>如果异常和接口在同一个包下，不处理，直接抛出；</li>
<li>如果是 JDK 内置的异常，不处理，直接抛出；</li>
<li>如果是 RpcException，不处理，直接抛出；</li>
<li>其他情况会将异常封装为 RuntimeException 。</li>
</ol>
<p>总的来说，Dubbo 对于异常的处理，遵循了一个原则，如果该异常类在服务提供端和消费端都能够找到，那么该服务提供端异常会被原样抛出到消费端，否则，异常将封装为 RuntimeExcetion 后抛出。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>回到开头的问题，如果我们希望在服务消费端能够接收到提供端的异常，我们可以在接口上显式声明该异常，那么 Dubbo 就不会对该异常进行二次包装了。</p>
]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka源码学习：生产者发送消息的流程</title>
    <url>/2024/12/30/Kafka%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>我们都知道，在使用 Kakfa 客户端发送消息时，只需要指定主题和消息的内容，再调用发送方法即可。那发送方法中包含了哪些逻辑呢，本文结合源码一起来看下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建消息</span></span><br><span class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="comment">// 发送</span></span><br><span class="line">producer.send(record);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<blockquote>
<p>以下内容基于Kafka 2.5.1版本</p>
</blockquote>
<h3 id="构建消息对象"><a href="#构建消息对象" class="headerlink" title="构建消息对象"></a>构建消息对象</h3><p>实际上，Kafka 中的消息对象并不只有主题和消息内容两个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerRecord</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">// 主题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</span><br><span class="line">    <span class="comment">// 分区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer partition;</span><br><span class="line">    <span class="comment">// 消息头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</span><br><span class="line">    <span class="comment">// 消息 key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// 消息内容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V value;</span><br><span class="line">    <span class="comment">// 消息的时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long timestamp;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 key 用来指定消息的键，可以用于计算分区号并且让消息发往特定的分区，同一个 key 的消息会被发往同一个分区，另外，由于 Kafka 可以保证同一个分区中的消息是有序的，相同 key 的消息的消费在一定程度上也能保证有序。</p>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>构建消息后，接下来就是发送了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> send(record, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 send 方法的返回值不难看出，该方法是一个异步方法，如果希望使用同步发送，则可以在拿到返回值后使用 <strong>Future#get</strong> 方法等发送结果。</p>
<p>发送结果是一个 RecordMetadata 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordMetadata</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Partition value for record without partition assigned</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNKNOWN_PARTITION = -<span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 消息的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> offset;</span><br><span class="line">    <span class="comment">// The timestamp of the message.</span></span><br><span class="line">    <span class="comment">// If LogAppendTime is used for the topic, the timestamp will be the timestamp returned by the broker.</span></span><br><span class="line">    <span class="comment">// If CreateTime is used for the topic, the timestamp is the timestamp in the corresponding ProducerRecord if the</span></span><br><span class="line">    <span class="comment">// user provided one. Otherwise, it will be the producer local time when the producer record was handed to the</span></span><br><span class="line">    <span class="comment">// producer.</span></span><br><span class="line">    <span class="comment">// 时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp;</span><br><span class="line">    <span class="comment">// key 大小 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> serializedKeySize;</span><br><span class="line">    <span class="comment">// 消息大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> serializedValueSize;</span><br><span class="line">    <span class="comment">// 主题和分区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TopicPartition topicPartition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Long checksum;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 RecordMetadata 中记录了消息的元数据信息，如消息的主题、分区、分区中消息的偏移量、时间戳等。</p>
<p>另外，Kafka 也提供了具有回调参数的 send 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// intercept the record, which can be potentially modified; this method does not throw exceptions</span></span><br><span class="line">    <span class="comment">// 生产者拦截器，发送前执行onSend方法</span></span><br><span class="line">    ProducerRecord&lt;K, V&gt; interceptedRecord = <span class="keyword">this</span>.interceptors.onSend(record);</span><br><span class="line">    <span class="keyword">return</span> doSend(interceptedRecord, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回调函数包含两个参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发送的消息被服务端确认成功后，消息的 metadata 将被返回；当发送出现异常时，可以通过 exception 拿到具体的异常，此时 metadata 对象中除 topicPartition 外的其他属性都将是-1。</p>
<p>来到 doSend 方法，消息发送的主逻辑得以展现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Future&lt;RecordMetadata&gt; <span class="title">doSend</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</span><br><span class="line">    TopicPartition tp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        throwIfProducerClosed();</span><br><span class="line">        <span class="comment">// 1. 确保该 topic 的元数据可用</span></span><br><span class="line">        <span class="comment">// first make sure the metadata for the topic is available</span></span><br><span class="line">        <span class="keyword">long</span> nowMs = time.milliseconds();</span><br><span class="line">        ClusterAndWaitTime clusterAndWaitTime;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), nowMs, maxBlockTimeMs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (metadata.isClosed())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">&quot;Producer closed while send in progress&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算剩余等待时间</span></span><br><span class="line">        nowMs += clusterAndWaitTime.waitedOnMetadataMs;</span><br><span class="line">        <span class="keyword">long</span> remainingWaitMs = Math.max(<span class="number">0</span>, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);</span><br><span class="line">        Cluster cluster = clusterAndWaitTime.cluster;</span><br><span class="line">        <span class="comment">// 2. 序列化 key 值和 value 值</span></span><br><span class="line">        <span class="keyword">byte</span>[] serializedKey;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serializedKey = keySerializer.serialize(record.topic(), record.headers(), record.key());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">&quot;Can&#x27;t convert key of class &quot;</span> + record.key().getClass().getName() +</span><br><span class="line">                    <span class="string">&quot; to class &quot;</span> + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() +</span><br><span class="line">                    <span class="string">&quot; specified in key.serializer&quot;</span>, cce);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] serializedValue;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">&quot;Can&#x27;t convert value of class &quot;</span> + record.value().getClass().getName() +</span><br><span class="line">                    <span class="string">&quot; to class &quot;</span> + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() +</span><br><span class="line">                    <span class="string">&quot; specified in value.serializer&quot;</span>, cce);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 通过分区器得到发往的分区</span></span><br><span class="line">        <span class="keyword">int</span> partition = partition(record, serializedKey, serializedValue, cluster);</span><br><span class="line">        tp = <span class="keyword">new</span> TopicPartition(record.topic(), partition);</span><br><span class="line"></span><br><span class="line">        setReadOnly(record.headers());</span><br><span class="line">        Header[] headers = record.headers().toArray();</span><br><span class="line">		<span class="comment">// 4. 预估消息的大小，如果超过消息大小限制或内存限制则报错</span></span><br><span class="line">        <span class="keyword">int</span> serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(),</span><br><span class="line">                compressionType, serializedKey, serializedValue, headers);</span><br><span class="line">        ensureValidRecordSize(serializedSize);</span><br><span class="line">        <span class="keyword">long</span> timestamp = record.timestamp() == <span class="keyword">null</span> ? nowMs : record.timestamp();</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Attempting to append record &#123;&#125; with callback &#123;&#125; to topic &#123;&#125; partition &#123;&#125;&quot;</span>, record, callback, record.topic(), partition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// producer callback will make sure to call both &#x27;callback&#x27; and interceptor callback</span></span><br><span class="line">        Callback interceptCallback = <span class="keyword">new</span> InterceptorCallback&lt;&gt;(callback, <span class="keyword">this</span>.interceptors, tp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (transactionManager != <span class="keyword">null</span> &amp;&amp; transactionManager.isTransactional()) &#123;</span><br><span class="line">            transactionManager.failIfNotReadyForSend();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 将消息缓存到 accumulator</span></span><br><span class="line">        RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey,</span><br><span class="line">                serializedValue, headers, interceptCallback, remainingWaitMs, <span class="keyword">true</span>, nowMs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.abortForNewBatch) &#123;</span><br><span class="line">            <span class="keyword">int</span> prevPartition = partition;</span><br><span class="line">            partitioner.onNewBatch(record.topic(), cluster, prevPartition);</span><br><span class="line">            partition = partition(record, serializedKey, serializedValue, cluster);</span><br><span class="line">            tp = <span class="keyword">new</span> TopicPartition(record.topic(), partition);</span><br><span class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(<span class="string">&quot;Retrying append due to new batch creation for topic &#123;&#125; partition &#123;&#125;. The old partition was &#123;&#125;&quot;</span>, record.topic(), partition, prevPartition);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// producer callback will make sure to call both &#x27;callback&#x27; and interceptor callback</span></span><br><span class="line">            interceptCallback = <span class="keyword">new</span> InterceptorCallback&lt;&gt;(callback, <span class="keyword">this</span>.interceptors, tp);</span><br><span class="line"></span><br><span class="line">            result = accumulator.append(tp, timestamp, serializedKey,</span><br><span class="line">                serializedValue, headers, interceptCallback, remainingWaitMs, <span class="keyword">false</span>, nowMs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (transactionManager != <span class="keyword">null</span> &amp;&amp; transactionManager.isTransactional())</span><br><span class="line">            transactionManager.maybeAddPartitionToTransaction(tp);</span><br><span class="line">		<span class="comment">// 6. batch 满了或创建了新的 batch 时，唤醒 sender 线程</span></span><br><span class="line">        <span class="keyword">if</span> (result.batchIsFull || result.newBatchCreated) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch&quot;</span>, record.topic(), partition);</span><br><span class="line">            <span class="keyword">this</span>.sender.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.future;</span><br><span class="line">        <span class="comment">// handling exceptions and record the errors;</span></span><br><span class="line">        <span class="comment">// for API exceptions return them in the future,</span></span><br><span class="line">        <span class="comment">// for other exceptions throw directly</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ApiException e) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Exception occurred during message send:&quot;</span>, e);</span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>)</span><br><span class="line">            callback.onCompletion(<span class="keyword">null</span>, e);</span><br><span class="line">        <span class="keyword">this</span>.errors.record();</span><br><span class="line">        <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureFailure(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.errors.record();</span><br><span class="line">        <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptException(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BufferExhaustedException e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.errors.record();</span><br><span class="line">        <span class="keyword">this</span>.metrics.sensor(<span class="string">&quot;buffer-exhausted-records&quot;</span>).record();</span><br><span class="line">        <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.errors.record();</span><br><span class="line">        <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// we notify interceptor about all exceptions, since onSend is called before anything else in this method</span></span><br><span class="line">        <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，发送消息主要分为几个步骤：</p>
<ol>
<li>等待获取 Kafka 集群元数据信息，这里会把最大阻塞时间参数 maxBlockTimeMs 传进去，方法返回后重新计算剩余等待时间 remainingWaitMs ；</li>
<li>使用 Serializer 器对消息的 key 和 value 序列化；</li>
<li>获取消息发往的目标分区 partition；</li>
<li>预估序列化后的消息大小，如果超过了限制，则抛出异常；</li>
<li>调用 RecordAccumulator#append 方法，将消息缓存到消息批次；</li>
<li>如果消息批次满了，或者创建了新的批次，唤醒 sender 线程，后续由 sender 线程从 RecordAccumulator 中批量发送消息到 Kafka。</li>
</ol>
<h3 id="生产者拦截器"><a href="#生产者拦截器" class="headerlink" title="生产者拦截器"></a>生产者拦截器</h3><p>在 KafkaProducer 里面，维护了一个生产者拦器集合 ProducerInterceptors ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProducerInterceptor</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Configurable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerRecord&lt;K, V&gt; <span class="title">onSend</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其 ProducerInterceptor 接口提供了三个方法，其中 onSend 方法可以用来对发送前的消息进行相应的定制化操作；onAcknowledgement 方法先于用户的 Callback 执行，可以用于对kafka集群响应进行预处理；close 方法则可以用于在关闭拦截器时执行一些资源的清理工作。</p>
<h3 id="获取目标分区"><a href="#获取目标分区" class="headerlink" title="获取目标分区"></a>获取目标分区</h3><p>在获取目标分区时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(ProducerRecord&lt;K, V&gt; record, <span class="keyword">byte</span>[] serializedKey, <span class="keyword">byte</span>[] serializedValue, Cluster cluster)</span> </span>&#123;</span><br><span class="line">    Integer partition = record.partition();</span><br><span class="line">    <span class="keyword">return</span> partition != <span class="keyword">null</span> ?</span><br><span class="line">            partition :</span><br><span class="line">            partitioner.partition(</span><br><span class="line">                    record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果指定了目标分区，则使用指定的；否则通过分区器 <strong>Partitioner#partition</strong> 计算得出，默认的分区器由 <strong>DefaultPartitioner</strong> 提供实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有消息 key ,则进一步通过 stickyPartitionCache 计算得到分区</span></span><br><span class="line">    <span class="keyword">if</span> (keyBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> stickyPartitionCache.partition(topic, cluster);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果存在消息 key，则通过用 key 值对分区数取模得到目标分区数</span></span><br><span class="line">    List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">    <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line">    <span class="comment">// hash the keyBytes to choose a partition</span></span><br><span class="line">    <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取目标分区时分两种情况 ：</p>
<ol>
<li>如果消息存在 key ，则使用 murmur2 算法取 key 的 hash 值，然后对分区总数取模，得到目标分区；</li>
<li>如果消息没有 key ，则由 StickyPartitionCache  进一步获取。</li>
</ol>
<p>那 StickyPartitionCache 的实现是什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Cluster cluster)</span> </span>&#123;</span><br><span class="line">    Integer part = indexCache.get(topic);</span><br><span class="line">    <span class="keyword">if</span> (part == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextPartition(topic, cluster, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> part;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>indexCache 中维护了 topic 到 分区的映射，如果为空的话，则通过 nextPartition 方法重新获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextPartition</span><span class="params">(String topic, Cluster cluster, <span class="keyword">int</span> prevPartition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 topic 的分区</span></span><br><span class="line">    List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">    Integer oldPart = indexCache.get(topic);</span><br><span class="line">    Integer newPart = oldPart;</span><br><span class="line">    <span class="comment">// Check that the current sticky partition for the topic is either not set or that the partition that </span></span><br><span class="line">    <span class="comment">// triggered the new batch matches the sticky partition that needs to be changed.</span></span><br><span class="line">    <span class="comment">// 当前 topic 没存有对应的分区，或分区需要更换时</span></span><br><span class="line">    <span class="keyword">if</span> (oldPart == <span class="keyword">null</span> || oldPart == prevPartition) &#123;</span><br><span class="line">        List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">        <span class="comment">// 没有可用分区</span></span><br><span class="line">        <span class="keyword">if</span> (availablePartitions.size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            Integer random = Utils.toPositive(ThreadLocalRandom.current().nextInt());</span><br><span class="line">            newPart = random % partitions.size();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (availablePartitions.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有一个分区</span></span><br><span class="line">            newPart = availablePartitions.get(<span class="number">0</span>).partition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取新的发送分区，新的发送分区不能跟之前的相同</span></span><br><span class="line">            <span class="keyword">while</span> (newPart == <span class="keyword">null</span> || newPart.equals(oldPart)) &#123;</span><br><span class="line">                Integer random = Utils.toPositive(ThreadLocalRandom.current().nextInt());</span><br><span class="line">                newPart = availablePartitions.get(random % availablePartitions.size()).partition();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Only change the sticky partition if it is null or prevPartition matches the current sticky partition.</span></span><br><span class="line">        <span class="comment">// 写入 indexCache</span></span><br><span class="line">        <span class="keyword">if</span> (oldPart == <span class="keyword">null</span>) &#123;</span><br><span class="line">            indexCache.putIfAbsent(topic, newPart);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            indexCache.replace(topic, prevPartition, newPart);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indexCache.get(topic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexCache.get(topic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初看起来 indexCache 中只要有值，那么向同一个 topic 发送消息时会一直使用同一个分区，其实不然，在 doSend 方法中，我们可以看到当需要创建一个新的消息批次时，也会触发 nextPartition 方法的执行。那么这样做的目的是什么呢？</p>
<p>前面我们提到发送消息时，会通过 RecordAccumulator 将消息先缓存起来，后续由 sender 线程发送，而触发发送的条件有两个：</p>
<ol>
<li>消息批次被填满；</li>
<li>消息发送的等待时间超过了 linger.ms 的配置。</li>
</ol>
<p>而 StickyPartitionCache 的作用其实是 “黏性选择”，能尽可能地将消息发往同一个分区，使消息批次能尽快的填满被发送出去，这样就可以一定程度上降低消息发送的延迟，同时也降低了发送的频次。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要对 Kafka 客户端的消息发送方法作了主要逻辑的梳理，同时对 Kafka 的默认分区器作了简单的分析，以及使用 StickyPartitionCache 带来的好处。发送流程中涉及到的 RecordAccumulator 、Sender 线程将在后续文章中一起学习下。</p>
]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
</search>
