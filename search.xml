<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>分布式事务 -两阶段提交及Atomikos在Spring Boot的使用</title>
    <url>/2022/05/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%20-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8F%8AAtomikos%E5%9C%A8Spring%20Boot%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="基于XA规范的两阶段提交方式"><a href="#基于XA规范的两阶段提交方式" class="headerlink" title="基于XA规范的两阶段提交方式"></a>基于XA规范的两阶段提交方式</h2><p>事务在业务的开发中有着至关重要的作用，事务具有的ACID的特性能保证业务处理前后数据的一致性：<br><strong>原子性（Atomicity）：</strong> 事务执行的所有操作，要么全部执行，要么全部不执行；<br><strong>一致性（Consistency）：</strong> 事务的执行前后，数据的完整性保持一致；<br><strong>隔离性（Isolation）：</strong> 两个或多个事务并行执行时是互不干扰的；<br><strong>持久性（Durability）：</strong> 事务执行完成后，其对数据库数据的更改会被永久保存下来；<br>在单机环境下，数据库系统对事务的支持是比较完善的；但当对数据进行水平或垂直拆分，一个数据库节点变为多个数据库节点时，分布式事务就出现了。</p>
<span id="more"></span>

<h3 id="XA规范"><a href="#XA规范" class="headerlink" title="XA规范"></a>XA规范</h3><p>XA是X/Open组织提出的一个分布式事务的规范，其定义了一个分布式事务的处理模型——DTP。在DTP中定义了三个组件：<br>Application Program（AP）：应用程序，即业务层，它定义了事务的边界，以及构成该事务的特定操作；<br>Resource Manager（RM）：资源管理器，可以理解为一个DBMS系统，或者消息服务器管理系统；<br>Transaction Manager（TM）：事务管理器，也称为协调者，负责协调和管理事务；</p>
<p>AP与RM之间，AP通过RM提供的API进行交互，当需要进行分布式事务时，则向TM发起一个全局事务，TM与RM之间则通过XA接口进行交互，TM管理了到RM的链接，并实现了两阶段提交。</p>
<h3 id="两阶段提交流程（2PC）"><a href="#两阶段提交流程（2PC）" class="headerlink" title="两阶段提交流程（2PC）"></a>两阶段提交流程（2PC）</h3><p>XA规范中，多个RM状态之间的协调通过TM进行，而这个资源协调的过程采用了两阶段提交协议（2PC），2PC实际上是一种在多节点之间实现事务原子提交的算法，它用来确保所有节点要么全部提交，要么全部中止。</p>
<p>在2PC中，分为准备阶段和提交阶段：<br>第一阶段：发送一个准备请求到所有参与者节点，询问他们是否可以提交；</p>
<p>第二阶段：如果所有参与者节点回答“是”，则表示他们已准备好提交，那么协调者将在阶段2发出提交请求；</p>
<p><img src="http://storage.laixiaoming.space/blog/1p.jpg" alt="1p"></p>
<p><img src="http://storage.laixiaoming.space/blog/2p.jpg" alt="2p"></p>
<p>如果在准备阶段，有一个RM返回失败时，则在第二个阶段将回滚所有资源</p>
<p><img src="http://storage.laixiaoming.space/blog/1pc-error.jpg" alt="1pc-error"></p>
<p><img src="http://storage.laixiaoming.space/blog/2pc-error.jpg" alt="2pc-error"></p>
<h3 id="2PC的局限性"><a href="#2PC的局限性" class="headerlink" title="2PC的局限性"></a>2PC的局限性</h3><p>2PC能基本满足了事务的 ACID 特性，但也存在着明显的缺点：</p>
<ul>
<li>在事务的执行过程中，所有的参与节点都是阻塞型的，在并发量高的系统中，性能受限严重；</li>
<li>如果TM在commit前发生故障，那么所有参与节点会因为无法提交事务而处于长时间锁定资源的状态；</li>
<li>在实际情况中，由于分布式环境下的复杂性，TM在发送commit请求后，可能因为局部网络原因，导致只有部分参与者收到commit请求时，系统便出现了数据不一致的现象；</li>
<li>XA协议要求所有参与者需要与TM进行直接交互，但在微服务架构下，一个服务与多个RM直接关联常常是被不允许的；</li>
</ul>
<h2 id="Atomikos在Spring-Boot的使用"><a href="#Atomikos在Spring-Boot的使用" class="headerlink" title="Atomikos在Spring Boot的使用"></a>Atomikos在Spring Boot的使用</h2><p>Atomikos在XA中作为一个事务管理器（TM）存在。在Spring Boot应用中，可以通过Atomikos在应用中方便的引入分布式事务。<br>下面以一个简单的订单创建流程的为例：</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jta-atomikos&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.11&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.22&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><p>application.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">      order-db:</span><br><span class="line">        name: order-db</span><br><span class="line">        url: jdbc:mysql:&#x2F;&#x2F;localhost:3307&#x2F;order?useSSL&#x3D;false&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: mysql</span><br><span class="line">      product-db:</span><br><span class="line">        name: order-db</span><br><span class="line">        url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;product?useSSL&#x3D;false&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: mysql</span><br><span class="line">  jta:</span><br><span class="line">    transaction-manager-id: order-product-tx-manager</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; &quot;gdou.laixiaoming.atomikos.demo.mapper.order&quot;, sqlSessionFactoryRef &#x3D; &quot;orderSqlSessionFactory&quot;)</span><br><span class="line">public class OrderDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;druidOrderDataSource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.druid.order-db&quot;)</span><br><span class="line">    public DruidXADataSource druidOrderDataSource()&#123;</span><br><span class="line">        DruidXADataSource xaDataSource &#x3D; new DruidXADataSource();</span><br><span class="line">        return xaDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;orderDataSource&quot;)</span><br><span class="line">    public DataSource orderDataSource(</span><br><span class="line">            @Qualifier(&quot;druidOrderDataSource&quot;) DruidXADataSource druidOrderDataSource) &#123;</span><br><span class="line">        AtomikosDataSourceBean ds &#x3D; new AtomikosDataSourceBean();</span><br><span class="line">        ds.setXaDataSource(druidOrderDataSource);</span><br><span class="line">        ds.setXaDataSourceClassName(&quot;com.alibaba.druid.pool.xa.DruidXADataSource&quot;);</span><br><span class="line">        ds.setUniqueResourceName(&quot;orderDataSource&quot;);</span><br><span class="line">        return ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactory orderSqlSessionFactory(</span><br><span class="line">            @Qualifier(&quot;orderDataSource&quot;) DataSource orderDataSource) throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(orderDataSource);</span><br><span class="line">        return sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; &quot;gdou.laixiaoming.atomikos.demo.mapper.product&quot;, sqlSessionFactoryRef &#x3D; &quot;productSqlSessionFactory&quot;)</span><br><span class="line">public class ProductDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;druidProductDataSource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.druid.product-db&quot;)</span><br><span class="line">    public DruidXADataSource druidProductDataSource()&#123;</span><br><span class="line">        DruidXADataSource xaDataSource &#x3D; new DruidXADataSource();</span><br><span class="line">        return xaDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;productDataSource&quot;)</span><br><span class="line">    public DataSource productDataSource(</span><br><span class="line">            @Qualifier(&quot;druidProductDataSource&quot;) DruidXADataSource druidProductDataSource) &#123;</span><br><span class="line">        AtomikosDataSourceBean ds &#x3D; new AtomikosDataSourceBean();</span><br><span class="line">        ds.setXaDataSource(druidProductDataSource);</span><br><span class="line">        ds.setXaDataSourceClassName(&quot;com.alibaba.druid.pool.xa.DruidXADataSource&quot;);</span><br><span class="line">        ds.setUniqueResourceName(&quot;productDataSource&quot;);</span><br><span class="line">        return ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactory productSqlSessionFactory(</span><br><span class="line">            @Qualifier(&quot;productDataSource&quot;) DataSource productDataSource) throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(productDataSource);</span><br><span class="line">        return sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="构建商品服务"><a href="#构建商品服务" class="headerlink" title="构建商品服务"></a>构建商品服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ProductServiceImpl implements ProductService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductMapper productMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void updateInventory(Long productId) &#123;</span><br><span class="line">    	&#x2F;&#x2F;模拟异常流程</span><br><span class="line">        if(productId &#x3D;&#x3D; 2)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;更新库存失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        productMapper.updateInventory(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建订单服务"><a href="#构建订单服务" class="headerlink" title="构建订单服务"></a>构建订单服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderMapper orderMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor &#x3D; RuntimeException.class)</span><br><span class="line">    @Override</span><br><span class="line">    public void order(Long productId) &#123;</span><br><span class="line">        orderMapper.addOrder(productId);</span><br><span class="line">        productService.updateInventory(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class ServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testCommit() &#123;</span><br><span class="line">        orderService.order(1L);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testRollback() &#123;</span><br><span class="line">        orderService.order(2L);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过运行测试用例，我们可以发现testCommit()方法在订单库以及商品库的成功完成的修改；而testRollback()方法则因为商品服务异常进行了回滚，回滚后的订单库和商品库数据都恢复到了事务开启前的状态。</p>
<p>参考：<br>《大型网站系统与Java中间件实践》<br><a href="https://www.jianshu.com/p/f9bac5822d30">SpringBoot Atomikos 多数据源分布式事务</a></p>
]]></content>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务-基于可靠消息的最终一致性实现</title>
    <url>/2022/05/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%9F%BA%E4%BA%8E%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="CAP与BASE"><a href="#CAP与BASE" class="headerlink" title="CAP与BASE"></a>CAP与BASE</h2><p>我们都知道，传统数据库事务具有ACID的特性，但在分布式环境下，追求强一致性在大多数情况下无法满足高性能需求。<br>分布式系统的CAP理论告诉我们，一致性、可用性、分区容忍性无法同时满足，最多只能满足其他两项。CAP理论描述如下：</p>
<ul>
<li>一致性（Consistency）：所有节点在同一时间读到同样的数据；</li>
<li>可用性（Availability）：无论是成功还是失败，每个请求都能收到一个反馈。可用性强调的是服务可用，不保证数据的正确性；</li>
<li>分区容忍性（Partition-Tolerance）：即使系统中有部分问题或者有消息的丢失，但系统仍然能够继续运行。分区容忍性强调的是集群对分区故障的容错能力；</li>
</ul>
<span id="more"></span>

<p>对于分布式系统而言，分区故障无法避免，因而分区容忍性在一个分布式系统中是必须要考虑的，这也意味着，设计一个分布式系统，我们只能在CAP中的C、A中作出选择，而BASE就是在C和A的选择中作出的一种权衡。<br>BASE可以说是AP系统的一种延伸，其描述如下：</p>
<ul>
<li>基本可用（Basically Available）：基本可用，允许分区失败；</li>
<li>软状态（Soft state）：软状态，一种中间状态，接受一段时间的状态不同步；</li>
<li>最终一致（Eventually consistent）：最终一致，系统在短暂时间内可能是不一致的，但能够保证最终的数据是一致的；<br>BASE通过牺牲了强一致性来获取高可用性，允许数据存在短暂的不一致，到这里其实我们可以发现，ACID强调的是数据一致性，而BASE强调的则是服务可用；</li>
</ul>
<h2 id="基于可靠消息的最终一致性"><a href="#基于可靠消息的最终一致性" class="headerlink" title="基于可靠消息的最终一致性"></a>基于可靠消息的最终一致性</h2><p>基于可靠消息实现的分布式事务遵循了BASE理论，它通过引入消息中间件，在基于可靠消息的前提下，协商多个节点异步完成整个分布式事务，如果某一步骤出现失败时，则进行一定次数的重试，必要情况下需要人工介入处理。<br>以下单为例，用户下单后，会给用户增加一定的积分，在这个流程中涉及了订单服务以及积分服务，如下图所示：</p>
<p><img src="http://storage.laixiaoming.space/blog/add-order.jpg" alt="add-order"></p>
<p>但这个流程其实存在3个问题：</p>
<ol>
<li>如果在订单服务的订单创建事务（1.2）执行成功了，在发送订单创建消息（1.3）后，由于网络不可达等因素，订单服务无法收到来自消息中间件的响应时，订单服务的本地事务是应该继续提交还是回滚呢；</li>
<li>如果订单创建消息发送成功，得到了消息中间件的正确响应，但订单服务的本地事务却提交失败了，但消息却已经投递出去了，这种情况又应该怎么处理呢；</li>
<li>订单创建消息已经成功投递到下游应用（积分服务），但积分服务的本地事务却执行失败了，又应该怎么处理呢<br>以上第1和第2个问题，其实可以归结于同一个问题，即如何保证消息发送的一致性，而第3个问题，即是如何确保消息一定能够消息成功；</li>
</ol>
<h3 id="如何保证消息发送的一致性"><a href="#如何保证消息发送的一致性" class="headerlink" title="如何保证消息发送的一致性"></a>如何保证消息发送的一致性</h3><p>我们可以采用两阶段提交的方式，但并不是所有的消息中间件都支持XA，况且，出现问题的概率不大，为此引入了两阶段提交，性能方面就需要有所妥协，这样的方案实现是否有点得不偿失？<br>这个问题其实RocketMQ有了实现方案，RocketMQ支持事务消息，其通过引入了“半消息”的概念（半消息对下游系统不可见），保证了本地事务执行与消息发送的一致性。其发送的正向流程如下：</p>
<ol>
<li>业务系统发送“半消息”；</li>
<li>消息中间件将“半消息”进行持久化；</li>
<li>业务系统得到消息发送结果，成功的话则执行本地事务，失败则结束流程；</li>
<li>本地事务执行，并将业务操作结果发送给消息中间件；</li>
<li>消息中间件根据业务系统的事务执行结果，选择将消息投放或者删除；</li>
</ol>
<p>但实际上仅凭以上这个流程其实还是没有办法保证消息发送的一致性的，比如<br>(1) 在业务系统接收消息中间件对“半消息”的处理结果时，由于网络、或者业务系统和消息中间件自身故障时，业务系统无法得知消息中间件的处理结果时，就会按照消息发送失败来处理，这个时候，就有可能存在，’本地事务未执行，但“半消息”却发送成功的不一致情况’；<br>(2) 本地事务执行后，将业务操作结果返回到消息中间件时，如果出现问题，那么消息中间件将不知道如何处理已经存在的“半消息”；<br>为应对以上两种不一致情况，RocketMQ在消息中间件一方引入了“事务回查”的反向流程，其执行流程如下：</p>
<ol>
<li>对于超过一定时长未处理的“半消息”，消息中间件将会回调业务系统询问本地事务的处理结果；</li>
<li>业务系统在检查事务操作结果，将结果返回给消息中间件；</li>
<li>消息中间件根据业务系统的事务执行结果，选择将消息投放或者删除；</li>
</ol>
<p>发送消息的正向流程和反向流程结合起来，就是解决消息发送一致性的整个方案。</p>
<p>以上面的下单流程为例，在引入了RocketMQ事务消息后，基本流程可以表示为：</p>
<p><img src="http://storage.laixiaoming.space/blog/add-order-rocketmq.jpg" alt="add-order-rocketmq"></p>
<h3 id="如何保证消息一定会被消费"><a href="#如何保证消息一定会被消费" class="headerlink" title="如何保证消息一定会被消费"></a>如何保证消息一定会被消费</h3><p>确保消息一定能够被消息的流程比较简单，我们只需要保证消息的持久化，并引入消息确认机制，只有在消息被明确消费完成后，将确认消息返回到消息中间时，消息才能够被丢弃，否则则进行一定次数的重试，需要注意的是，引入重试操作后，消费方的操作需要保证幂等性。</p>
<h2 id="RocketMQ整合实例"><a href="#RocketMQ整合实例" class="headerlink" title="RocketMQ整合实例"></a>RocketMQ整合实例</h2><p>该例子基于Spring Boot构建：</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.rocketmq&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.1.0&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="applition-yml配置"><a href="#applition-yml配置" class="headerlink" title="applition.yml配置"></a>applition.yml配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rocketmq:</span><br><span class="line">  name-server: localhost:9876</span><br><span class="line">  producer:</span><br><span class="line">    group: default-group</span><br><span class="line">    sendMessageTimeout: 5000</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  rocketmq:</span><br><span class="line">    orderTopic: order-paid-topic</span><br></pre></td></tr></table></figure>

<h3 id="构建订单服务"><a href="#构建订单服务" class="headerlink" title="构建订单服务"></a>构建订单服务</h3><h4 id="发送半消息"><a href="#发送半消息" class="headerlink" title="发送半消息"></a>发送半消息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;demo.rocketmq.orderTopic&#125;&quot;)</span><br><span class="line">    private String orderTopic;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addOrder() &#123;</span><br><span class="line">        int orderId &#x3D; new Random().nextInt(3) + 1;</span><br><span class="line">        Message message &#x3D; MessageBuilder.withPayload(orderId).build();</span><br><span class="line">        log.info(&quot;发送半消息, orderId &#x3D; &#123;&#125;&quot;, orderId);</span><br><span class="line">        rocketMQTemplate.sendMessageInTransaction(orderTopic, message, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="本地事务执行回调与事务状态回查"><a href="#本地事务执行回调与事务状态回查" class="headerlink" title="本地事务执行回调与事务状态回查"></a>本地事务执行回调与事务状态回查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RocketMQTransactionListener</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderTransactionListener implements RocketMQLocalTransactionListener &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;</span><br><span class="line">        &#x2F;&#x2F;执行本地事务</span><br><span class="line">        Integer orderId &#x3D; Integer.valueOf(new String((byte[])msg.getPayload()));</span><br><span class="line">        int status &#x3D; new Random().nextInt(3);</span><br><span class="line">        if (status &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            log.info(&quot;提交事务消息, orderId &#x3D; &#123;&#125;&quot;, orderId);</span><br><span class="line">            return RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (status &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            log.info(&quot;回滚事务消息, orderId &#x3D; &#123;&#125;&quot;, orderId);</span><br><span class="line">            return RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(&quot;事务消息中间状态, MQ需要回查事务状态&quot;);</span><br><span class="line">        return RocketMQLocalTransactionState.UNKNOWN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RocketMQLocalTransactionState checkLocalTransaction(Message msg) &#123;</span><br><span class="line">        Integer orderId &#x3D; Integer.valueOf(new String((byte[])msg.getPayload()));</span><br><span class="line">        RocketMQLocalTransactionState retState;</span><br><span class="line">        int status &#x3D; new Random().nextInt(3);</span><br><span class="line">        switch (status) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                retState &#x3D; RocketMQLocalTransactionState.UNKNOWN;</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                retState &#x3D; RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">            default:</span><br><span class="line">                retState &#x3D; RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;回查事务状态, orderId &#x3D; &#123;&#125;, status &#x3D; &#123;&#125;, retState &#x3D; &#123;&#125;&quot;,</span><br><span class="line">                orderId, status, retState);</span><br><span class="line">        return retState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建积分服务"><a href="#构建积分服务" class="headerlink" title="构建积分服务"></a>构建积分服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@RocketMQMessageListener(topic &#x3D; &quot;$&#123;demo.rocketmq.orderTopic&#125;&quot;, consumerGroup &#x3D; &quot;order_paid_consumer_default_group&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderPaidConsumer implements RocketMQListener&lt;MessageExt&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(MessageExt message) &#123;</span><br><span class="line">        Integer orderId &#x3D; Integer.valueOf(new String((byte[])message.getBody()));</span><br><span class="line">        log.info(&quot;orderId &#x3D; &#123;&#125;, 增加积分&quot;, orderId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<br>《大型网站系统与Java中间件实践》</p>
]]></content>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>认识高性能队列——Disruptor</title>
    <url>/2022/05/01/%E8%AE%A4%E8%AF%86%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Disruptor/</url>
    <content><![CDATA[<h2 id="Disruptor是什么"><a href="#Disruptor是什么" class="headerlink" title="Disruptor是什么"></a>Disruptor是什么</h2><p>Disruptor是一个由英国外汇交易公司LMAX研发并开源的高性能的有界内存队列，其主要用于在线程之间完成数据的传递。<a href="https://github.com/LMAX-Exchange/disruptor">github地址</a><br>那么，以高性能著称的Disruptor到底有多快呢<br>我将常用的2种线程安全队列（ArrayBlockingQueue和LinkedBlockingQueue）与Disruptor作了个简单对比，场景是启动两个线程，一个线程往队列填充自增数字，另一个线程取数字进行累加，其对比结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000w</span><br><span class="line">ArrayBlockingQueue耗时：927ms</span><br><span class="line">LinkedBlockingQueue耗时：1495ms</span><br><span class="line">Disruptor耗时：598ms</span><br><span class="line">5000w</span><br><span class="line">ArrayBlockingQueue耗时：4044ms</span><br><span class="line">LinkedBlockingQueue耗时：11145ms</span><br><span class="line">Disruptor耗时：2824ms</span><br><span class="line">1e</span><br><span class="line">ArrayBlockingQueue耗时：7514ms</span><br><span class="line">LinkedBlockingQueue耗时：23144ms</span><br><span class="line">Disruptor耗时：4668ms</span><br></pre></td></tr></table></figure>
<p>可以看到，Disruptor在速度上较其他两个队列有着明显的优势。</p>
<span id="more"></span>

<h2 id="为什么可以这么快"><a href="#为什么可以这么快" class="headerlink" title="为什么可以这么快"></a>为什么可以这么快</h2><h3 id="内存预分配"><a href="#内存预分配" class="headerlink" title="内存预分配"></a>内存预分配</h3><p>在Disruptor里，底层存储为数组结构，而事件（Event）作为真实数据的一个载体，在初始化时会调用预设的EventFactory创建对应数量的Event填充数组，加上其环形数组的设计，数组中的Event对象可以很方便地实现复用，这在一定程度可以减少GC的次数，提升了性能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void fill(EventFactory&lt;E&gt; eventFactory)&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; bufferSize; i++)&#123;</span><br><span class="line">        entries[BUFFER_PAD + i] &#x3D; eventFactory.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消除“伪共享”，充分利用硬件缓存"><a href="#消除“伪共享”，充分利用硬件缓存" class="headerlink" title="消除“伪共享”，充分利用硬件缓存"></a>消除“伪共享”，充分利用硬件缓存</h3><h4 id="什么是“伪共享”"><a href="#什么是“伪共享”" class="headerlink" title="什么是“伪共享”"></a>什么是“伪共享”</h4><p>每个CPU核心都有自己独立的cache和寄存器，主存与CPU之间存在着多级cache，L3，L2，L1，而越靠近CPU核心，速度也越快，为也提高处理速度，处理器不直接与主存通信，主存的访问首先会进入cache，所有的修改默认会异步刷新到主存。同时在多核心处理器下，为了保证各个核心的缓存是一致的，会实现缓存一致性协议。<br>而伪共享指的是由于共享缓存行（通常为64个字节）导致缓存无效的场景：</p>
<p><img src="http://storage.laixiaoming.space/blog/cpu_cache.jpg" alt="cpu_cache"></p>
<p>就上图场景而言，线程1和线程2运行分别运行在两个核心上，线程1对putIndex读写，线程2对takeIndex读写，由于putIndex与takeIndex内存的相邻性，在加载到缓存时将被读到同一个缓存行中，而由于对其中一个变量的写操作会使缓存回写到主存，造成整个缓存行的失效，这也导致了同处于同一个缓存行的其他变量的缓存失效。</p>
<h4 id="它是如何被消除的"><a href="#它是如何被消除的" class="headerlink" title="它是如何被消除的"></a>它是如何被消除的</h4><p>一方面，底层采用数组结构，CPU在加载数据时，会根据空间局部性原理，把相邻的数据一起加载进来，由于由于数组上结构的内存分配是连续的，也就能更好地利用CPU的缓存；<br>另一方面，通过增加无意义变量，增大变量间的间隔，使得一个变量可以独占一个缓存行，以空间换取时间（注： Java 8 可以使用@Contended注解，配合JVM参数-XX:-RestrictContended，来消除“伪共享”）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LhsPadding</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;7*8个字节</span><br><span class="line">    protected long p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Value extends LhsPadding</span><br><span class="line">&#123;</span><br><span class="line">    protected volatile long value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RhsPadding extends Value</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;7*8个字节</span><br><span class="line">    protected long p9, p10, p11, p12, p13, p14, p15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无锁数据结构RingBuffer"><a href="#无锁数据结构RingBuffer" class="headerlink" title="无锁数据结构RingBuffer"></a>无锁数据结构RingBuffer</h3><p><img src="http://storage.laixiaoming.space/blog/ringbuffer.jpg" alt="ringbuffer"></p>
<p>RingBuffer作为Disruptor的底层数据结构，其内部有一个cursor变量，表示当前可读的最大下标，cursor是Sequence类的一个对象，其内部维护了一个long类型的value成员，value使用了volatile修饰，在不使用锁的前提下保证了线程之间的可见性，并通过Unsafe工具封装了对value变量的CAS系列操作。<br>关于volatile变量，有以下两个特性：<br>可见性：对一个volatile变量读，总能看到（任意线程）对这个变量的最后写入；<br>原子性：对任意单个volatile变量的读/写具有原子性；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Sequence extends RhsPadding</span><br><span class="line">&#123;</span><br><span class="line">	static final long INITIAL_VALUE &#x3D; -1L;</span><br><span class="line">    private static final Unsafe UNSAFE;</span><br><span class="line">    private static final long VALUE_OFFSET;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h4><p>RingBuffer数据的写入分为两个阶段，在第一阶段会先申请下一个可写入节点（cursor+1），多写入者模式下通过CAS操作移动cursor，来保存线程安全性；第二阶段，数据提交，提交时为保证顺序写，需要保证cursor追上当前提交的写入位置。<br>写入成功后，再调用具体的WaitStrategy实现通知其他消费线程</p>
<p><img src="http://storage.laixiaoming.space/blog/ringbuffer_write.jpg" alt="ringbuffer_write"></p>
<h4 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h4><p>在读取数据的时候，多个消费者可以同时消费，每个消费者都会维护有一个读取位置，在没有可读数据时，通过具体的WaitStrategy进行等待（阻塞等待或自旋等）。</p>
<p><img src="http://storage.laixiaoming.space/blog/ringbuffer_read.jpg" alt="ringbuffer_read"></p>
<h2 id="简单上手-生产者-消费者模型"><a href="#简单上手-生产者-消费者模型" class="headerlink" title="简单上手(生产者-消费者模型)"></a>简单上手(生产者-消费者模型)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DisruptorStart &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; RingBuffer大小，2的幂次</span><br><span class="line">        int bufferSize &#x3D; 1024;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建Disruptor</span><br><span class="line">        Disruptor&lt;LongEvent&gt; disruptor &#x3D; new Disruptor&lt;&gt;(</span><br><span class="line">                LongEvent::new,</span><br><span class="line">                bufferSize,</span><br><span class="line">                DaemonThreadFactory.INSTANCE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 事件消费</span><br><span class="line">        disruptor.handleEventsWith((event, sequence, endOfBatch) -&gt; System.out.println(&quot;Event: &quot; + event));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 启动</span><br><span class="line">        disruptor.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 拿到RingBuffer，用于向队列传输数据</span><br><span class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer &#x3D; disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">        ByteBuffer bb &#x3D; ByteBuffer.allocate(8);</span><br><span class="line">        for (long l &#x3D; 0; true; l++) &#123;</span><br><span class="line">            bb.putLong(0, l);</span><br><span class="line">            &#x2F;&#x2F;往队列填充数据</span><br><span class="line">            ringBuffer.publishEvent((event, sequence, buffer) -&gt; event.set(buffer.getLong(0)), bb);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考：<br><a href="https://ifeve.com/disruptor">并发框架Disruptor译文</a><br><a href="https://tech.meituan.com/2016/11/18/disruptor.html">高性能队列——Disruptor</a><br><a href="https://blog.csdn.net/twypx/article/details/80398886">Disruptor系列3：Disruptor样例实战</a></p>
]]></content>
      <tags>
        <tag>内存队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot源码学习：自动配置原理</title>
    <url>/2022/05/02/Spring-Boot%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“约定优于配置”是Spring Boot倡导的一个思想，而其自动配置的特性则恰好体现了这一思想。而有了自动配置，不仅简化了Maven的依赖配置，更重要的是摆脱了以往使用Spring框架开发时，所必须编写的一堆繁琐的xml配置文件。</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于Spring Boot 2.1.9.RELEASE版本</p>
</blockquote>
<h2 id="从-SpringBootApplication注解说起"><a href="#从-SpringBootApplication注解说起" class="headerlink" title="从@SpringBootApplication注解说起"></a>从@SpringBootApplication注解说起</h2><p>我们都知道，一个Spring Boot主启动类上必须标注@SpringBootApplication注解，点开这个注解我们可以看到这是一个组合注解，其中关键的注解有@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan这3个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点开@SpringBootConfiguration，可以看到它被@Configuration标注，这表明了我们的启动类同时也是一个配置类，这一点需要注意，因为Spring Boot整个启动流程可以说都是围绕着我们的主启动类进行的。</p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Import注解的作用是将目标类作为Bean添加到IOC容器，通常用于将多个分散的配置类融合成一个更大的配置类。@Import支持导入<strong>普通类</strong>、<strong>配置类</strong>、<strong>ImportSelector 的实现类</strong>以及<strong>ImportBeanDefinitionRegistrar 的实现类</strong>。</p>
<h4 id="AutoConfigurationImportSelector的作用"><a href="#AutoConfigurationImportSelector的作用" class="headerlink" title="AutoConfigurationImportSelector的作用"></a>AutoConfigurationImportSelector的作用</h4><p><img src="http://storage.laixiaoming.space/blog/AutoConfigurationImportSelector.jpg" alt="AutoConfigurationImportSelector"></p>
<p>AutoConfigurationImportSelector是DeferredImportSelector的实现类，而DeferredImportSelector继承了ImportSelector，而ImportSelector#selectImports方法正是用来获取需要实际导入到IOC容器的类名数组的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,</span><br><span class="line">                                                                              annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，在selectImports方法中，获取类名数组的关键方法就在于getAutoConfigurationEntry方法</p>
<h5 id="AutoConfigurationImportSelector-getAutoConfigurationEntry"><a href="#AutoConfigurationImportSelector-getAutoConfigurationEntry" class="headerlink" title="AutoConfigurationImportSelector#getAutoConfigurationEntry"></a>AutoConfigurationImportSelector#getAutoConfigurationEntry</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">			AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//获取候选的自动配置类</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到getCandidateConfigurations方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">                                                                         getBeanClassLoader());</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面调用了SpringFactoriesLoader的loadFactoryNames方法，并传入了<strong>EnableAutoConfiguration.class</strong>这样一个参数，继续深入可以发现在里面又调用了loadSpringFactories方法：</p>
<h5 id="SpringFactoriesLoader-loadFactoryNames"><a href="#SpringFactoriesLoader-loadFactoryNames" class="headerlink" title="SpringFactoriesLoader#loadFactoryNames"></a>SpringFactoriesLoader#loadFactoryNames</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">					classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">					ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">    URL url = urls.nextElement();</span><br><span class="line">    UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">    Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">        String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">        <span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">            result.add(factoryClassName, factoryName.trim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>通过代码可以看出，loadSpringFactories方法做的事情就是：</p>
<ol>
<li>扫描所有jar包路径下<strong>META-INF/spring.factories</strong>文件；</li>
<li>以Properties的形式加载加载该文件，将将其收集到Map返回；</li>
</ol>
<p>回到loadFactoryNames方法，在前面拿到了<strong>META-INF/spring.factories</strong>的Map内容后，会取出<strong>EnableAutoConfiguration.class</strong>对应的值，随后便将其添加到容器中。</p>
<p>那么<strong>META-INF/spring.factories</strong>都有着什么内容呢</p>
<h5 id="META-INF-spring-factories文件"><a href="#META-INF-spring-factories文件" class="headerlink" title="META-INF/spring.factories文件"></a><code>META-INF/spring.factories</code>文件</h5><p>这个文件可以在<strong>spring-boot-autoconfiguration</strong>包下找到，我在其中截取了部分<strong>EnableAutoConfiguration.class</strong>内容，不难看到，这些都是我们在日常开发中常见的配置类，这其实也解释了，为什么即便我们在项目中没有显示添加任何配置，而只要我们添加了对应的starter依赖，Spring Boot便会帮助我们创建对应的Bean：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>



<h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是@Import注解，点进AutoConfigurationPackages.Registrar可以发现其手动注册了一个<strong>BasePackages.class</strong>的Bean，并把主启动类的成员设置到<strong>BasePackages</strong>对象成员里；</p>
<p>那这样做有什么用呢？其实AutoConfigurationPackages类上的注释已经告诉了我们答案，它是设计来给其他模块或组件用的，相当于提供给了其他模块或组件获取根包的一个入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class <span class="keyword">for</span> storing auto-<span class="function">configuration packages <span class="keyword">for</span> reference <span class="title">later</span> <span class="params">(e.g. by JPA entity</span></span></span><br><span class="line"><span class="function"><span class="params">scanner)</span></span></span><br></pre></td></tr></table></figure>



<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>开启组件扫描，可以指定扫描路径，在不指定的情况下，会扫描当前配置类所在包及子包的所有组件，这也解释了，为什么我们在使用Spring Boot的时候，启动类要放在最外层。</p>
<p>到这里，不知道读者是否会有疑问，启动类被@Configuration修饰，它既然也是一个配置类，那么它是什么时候被注册到IOC容器的呢？</p>
<p>通过dubug启动过程，其实不难发现是在SpringApplication#prepareContext方法进行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//获取主启动类位置</span></span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line"><span class="comment">//加载</span></span><br><span class="line">load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Spring Boot通过 AutoConfigurationImportSelector，并扫描所有jar包目录中<strong>META-INF/spring.factories</strong>配置文件，并加载<code>org.springframework.boot.autoconfigure.EnableutoConfiguration</code>配置项中对应的自动配置类，这也是自动配置生效的原理；</li>
<li>主启动类也是一个配置类，而**@ComponentScan**会默认扫描当前配置类所在包及子包的所有组件；</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
</search>
