<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"laixiaoming.space","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"AT64P6OJ8G","apiKey":"98870b25028b6803f2e798b0d7e939f8","indexName":"laixiaoming.space","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言在微服务架构中，服务注册和发现是核心组件之一，而 Nacos 能作为目前主流的注册中心，不仅仅是因为其功能特性、开源、成熟度等，更重要的是它在可用性方面所作的保障，确保了系统能在复杂的场景下稳定运行。本文就 Nacos 在客户端实现的一系列高可用机制，并结合相关源码一起学习下。">
<meta property="og:type" content="article">
<meta property="og:title" content="Nacos 客户端高可用机制学习">
<meta property="og:url" content="http://laixiaoming.space/2025/04/04/Nacos%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="赖小明">
<meta property="og:description" content="前言在微服务架构中，服务注册和发现是核心组件之一，而 Nacos 能作为目前主流的注册中心，不仅仅是因为其功能特性、开源、成熟度等，更重要的是它在可用性方面所作的保障，确保了系统能在复杂的场景下稳定运行。本文就 Nacos 在客户端实现的一系列高可用机制，并结合相关源码一起学习下。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-04-04T14:07:03.000Z">
<meta property="article:modified_time" content="2025-04-05T11:05:22.060Z">
<meta property="article:author" content="laixiaoming">
<meta property="article:tag" content="Nacos">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://laixiaoming.space/2025/04/04/Nacos%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Nacos 客户端高可用机制学习 | 赖小明</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">赖小明</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://laixiaoming.space/2025/04/04/Nacos%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="laixiaoming">
      <meta itemprop="description" content="就算红尘劫数都是空幻，也必须经历一遍才能领悟">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖小明">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Nacos 客户端高可用机制学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-04 22:07:03" itemprop="dateCreated datePublished" datetime="2025-04-04T22:07:03+08:00">2025-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-05 19:05:22" itemprop="dateModified" datetime="2025-04-05T19:05:22+08:00">2025-04-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在微服务架构中，服务注册和发现是核心组件之一，而 Nacos 能作为目前主流的注册中心，不仅仅是因为其功能特性、开源、成熟度等，更重要的是它在可用性方面所作的保障，确保了系统能在复杂的场景下稳定运行。本文就 Nacos 在客户端实现的一系列高可用机制，并结合相关源码一起学习下。</p>
<span id="more"></span>

<blockquote>
<p>以下内容基于 nacos-client 1.4.2版本</p>
</blockquote>
<h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>先来思考一个问题，假如我们实际使用 Dubbo 作为微服务框架，服务在运行过程中，Nacos 服务端宕机了，此时 Dubbo 服务还能正常调用其他服务吗？这个问题大多数人都能回答上来，答案是“可以”，因为 Dubbo 的消费端实际缓存了一份服务提供者列表，而只有当服务提供者列表发生上下线时，才会推送到服务消费端进行更新，所以此时服务依然能正常调用。但如果此时服务发生了重启呢，服务还能正常调用吗？答案也是可以，这就涉及到 Nacos 客户端的缓存机制了。</p>
<p><strong>ServiceInfo</strong> 是 Nacos 定义的服务注册信息类，客户端获取到的服务列表通过一个 serviceInfoMap 在内存进行维护：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.core.HostReactor</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ServiceInfo&gt; serviceInfoMap;</span><br></pre></td></tr></table></figure>



<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在客户端初始化时，如果启用了“加载缓存文件”开关（loadCacheAtStart），则从磁盘读取指定的缓存目录，并初始化内存中的 serviceInfoMap ，该开关可以通过传入 namingLoadCacheAtStart 配置进行指定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.core.HostReactor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HostReactor</span><span class="params">(NamingProxy serverProxy, BeatReactor beatReactor, String cacheDir, <span class="keyword">boolean</span> loadCacheAtStart,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> pushEmptyProtection, <span class="keyword">int</span> pollingThreadCount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// init executorService</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.beatReactor = beatReactor;</span><br><span class="line">    <span class="keyword">this</span>.serverProxy = serverProxy;</span><br><span class="line">    <span class="keyword">this</span>.cacheDir = cacheDir;</span><br><span class="line">    <span class="comment">// 是否加载磁盘缓存</span></span><br><span class="line">    <span class="keyword">if</span> (loadCacheAtStart) &#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceInfoMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ServiceInfo&gt;(DiskCache.read(<span class="keyword">this</span>.cacheDir));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceInfoMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ServiceInfo&gt;(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>在 Nacos 中，客户端通过 “主动查询“ + “被动通知”两种方式感知到服务列表的变化，在变化时会同时更新 serviceInfoMap 。</p>
<p>主动查询通过定时请求服务端的方式实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.core.HostReactor.UpdateTask</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询间隔为 1s</span></span><br><span class="line">    <span class="keyword">long</span> delayTime = DEFAULT_DELAY;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServiceInfo serviceObj = serviceInfoMap.get(ServiceInfo.getKey(serviceName, clusters));</span><br><span class="line">        <span class="comment">// 缓存中的服务为空时，更新一次</span></span><br><span class="line">        <span class="keyword">if</span> (serviceObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateService(serviceName, clusters);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 缓存的时间小于上次更新时间时</span></span><br><span class="line">        <span class="keyword">if</span> (serviceObj.getLastRefTime() &lt;= lastRefTime) &#123;</span><br><span class="line">            updateService(serviceName, clusters);</span><br><span class="line">            serviceObj = serviceInfoMap.get(ServiceInfo.getKey(serviceName, clusters));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if serviceName already updated by push, we should not override it</span></span><br><span class="line">            <span class="comment">// since the push data may be different from pull through force push</span></span><br><span class="line">            refreshOnly(serviceName, clusters);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        lastRefTime = serviceObj.getLastRefTime();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        incFailCount();</span><br><span class="line">        NAMING_LOGGER.warn(<span class="string">&quot;[NA] failed to update serviceName: &quot;</span> + serviceName, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        executor.schedule(<span class="keyword">this</span>, Math.min(delayTime &lt;&lt; failCount, DEFAULT_DELAY * <span class="number">60</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>被动通知则通过 udp 推送实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.core.PushReceiver</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!closed) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// byte[] is initialized with 0 full filled by default</span></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[UDP_MSS];</span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer, buffer.length);</span><br><span class="line">            <span class="comment">// 接收到服务端的通知时</span></span><br><span class="line">            udpSocket.receive(packet);</span><br><span class="line">            </span><br><span class="line">            String json = <span class="keyword">new</span> String(IoUtils.tryDecompress(packet.getData()), UTF_8).trim();</span><br><span class="line">            NAMING_LOGGER.info(<span class="string">&quot;received push data: &quot;</span> + json + <span class="string">&quot; from &quot;</span> + packet.getAddress().toString());</span><br><span class="line">            </span><br><span class="line">            PushPacket pushPacket = JacksonUtils.toObj(json, PushPacket.class);</span><br><span class="line">            String ack;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;dom&quot;</span>.equals(pushPacket.type) || <span class="string">&quot;service&quot;</span>.equals(pushPacket.type)) &#123;</span><br><span class="line">                hostReactor.processServiceJson(pushPacket.data);</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;dump&quot;</span>.equals(pushPacket.type)) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            udpSocket.send(<span class="keyword">new</span> DatagramPacket(ack.getBytes(UTF_8), ack.getBytes(UTF_8).length,</span><br><span class="line">                    packet.getSocketAddress()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            NAMING_LOGGER.error(<span class="string">&quot;[NA] error while receiving push data&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>不管是 “主动查询“，还是“被动通知”，最终都是通过 <strong>com.alibaba.nacos.client.naming.core.HostReactor#processServiceJson</strong> 进行处理，更新服务列表缓存 serviceInfoMap ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServiceInfo <span class="title">processServiceJson</span><span class="params">(String json)</span> </span>&#123;</span><br><span class="line">    ServiceInfo serviceInfo = JacksonUtils.toObj(json, ServiceInfo.class);</span><br><span class="line">    String serviceKey = serviceInfo.getKey();</span><br><span class="line">    <span class="keyword">if</span> (serviceKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ServiceInfo oldService = serviceInfoMap.get(serviceKey);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pushEmptyProtection &amp;&amp; !serviceInfo.validate()) &#123;</span><br><span class="line">        <span class="comment">//empty or error push, just ignore</span></span><br><span class="line">        <span class="keyword">return</span> oldService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 更新服务列表缓存</span></span><br><span class="line">        serviceInfoMap.put(serviceInfo.getKey(), serviceInfo);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断新获取的服务信息较于缓存中的服务信息是否产生了变化</span></span><br><span class="line">        Map&lt;String, Instance&gt; oldHostMap = <span class="keyword">new</span> HashMap&lt;String, Instance&gt;(oldService.getHosts().size());</span><br><span class="line">        <span class="keyword">for</span> (Instance host : oldService.getHosts()) &#123;</span><br><span class="line">            oldHostMap.put(host.toInetAddr(), host);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Instance&gt; newHostMap = <span class="keyword">new</span> HashMap&lt;String, Instance&gt;(serviceInfo.getHosts().size());</span><br><span class="line">        <span class="keyword">for</span> (Instance host : serviceInfo.getHosts()) &#123;</span><br><span class="line">            newHostMap.put(host.toInetAddr(), host);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Set&lt;Instance&gt; modHosts = <span class="keyword">new</span> HashSet&lt;Instance&gt;();</span><br><span class="line">        Set&lt;Instance&gt; newHosts = <span class="keyword">new</span> HashSet&lt;Instance&gt;();</span><br><span class="line">        Set&lt;Instance&gt; remvHosts = <span class="keyword">new</span> HashSet&lt;Instance&gt;();</span><br><span class="line">        </span><br><span class="line">        List&lt;Map.Entry&lt;String, Instance&gt;&gt; newServiceHosts = <span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;String, Instance&gt;&gt;(</span><br><span class="line">                newHostMap.entrySet());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Instance&gt; entry : newServiceHosts) &#123;</span><br><span class="line">            Instance host = entry.getValue();</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span> (oldHostMap.containsKey(key) &amp;&amp; !StringUtils</span><br><span class="line">                    .equals(host.toString(), oldHostMap.get(key).toString())) &#123;</span><br><span class="line">                modHosts.add(host);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!oldHostMap.containsKey(key)) &#123;</span><br><span class="line">                newHosts.add(host);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Instance&gt; entry : oldHostMap.entrySet()) &#123;</span><br><span class="line">            Instance host = entry.getValue();</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span> (newHostMap.containsKey(key)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!newHostMap.containsKey(key)) &#123;</span><br><span class="line">                remvHosts.add(host);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">        serviceInfo.setJsonFromServer(json);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (newHosts.size() &gt; <span class="number">0</span> || remvHosts.size() &gt; <span class="number">0</span> || modHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 推送服务变更事件</span></span><br><span class="line">            NotifyCenter.publishEvent(<span class="keyword">new</span> InstancesChangeEvent(serviceInfo.getName(), serviceInfo.getGroupName(),</span><br><span class="line">                    serviceInfo.getClusters(), serviceInfo.getHosts()));</span><br><span class="line">            <span class="comment">// 将缓存持久化一份到磁盘</span></span><br><span class="line">            DiskCache.write(serviceInfo, cacheDir);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">        NAMING_LOGGER.info(<span class="string">&quot;init new ips(&quot;</span> + serviceInfo.ipCount() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                + JacksonUtils.toJson(serviceInfo.getHosts()));</span><br><span class="line">        serviceInfoMap.put(serviceInfo.getKey(), serviceInfo);</span><br><span class="line">        <span class="comment">// 推送服务变更事件</span></span><br><span class="line">        NotifyCenter.publishEvent(<span class="keyword">new</span> InstancesChangeEvent(serviceInfo.getName(), serviceInfo.getGroupName(),</span><br><span class="line">                serviceInfo.getClusters(), serviceInfo.getHosts()));</span><br><span class="line">        serviceInfo.setJsonFromServer(json);</span><br><span class="line">        <span class="comment">// 将缓存持久化一份到磁盘</span></span><br><span class="line">        DiskCache.write(serviceInfo, cacheDir);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> serviceInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>在 processServiceJson 方法中，Nacos 客户端在更新的 serviceInfoMap 服务缓存时，会同时 <strong>com.alibaba.nacos.client.naming.cache.DiskCache#write</strong> 持久化一份到本地文件，其默认的存储路径为：{user.home}/nacos/ ，可以通过 “JM.SNAPSHOT.PATH” 参数指定。</p>
<h3 id="failover-容灾"><a href="#failover-容灾" class="headerlink" title="failover 容灾"></a>failover 容灾</h3><p>另外，我们注意到，除了缓存的持久化目录（cacheDir），同时存在于一个 “{cacheDir}/failover” 目录，存入的同样是服务列表文件信息，这是为什么呢？这其实时 Nacos 客户端的另一机制，用于本地容灾处理。</p>
<p>容灾一般有两种使用场景：</p>
<ol>
<li>在 Nacos 服务端发布的时候，可以打开容灾开关，Nacos 客户端将只使用本地容灾数据，这样 Nacos 服务的数据抖动或者数据错误都不会影响客户端，我们可以在 Nacos 服务端升级完成并且数据验证没问题之后再关闭容灾；</li>
<li>在 Nacos 运行期间，如果出现接口不可用或者数据异常时，可以打开容灾开关，减少服务受影响的窗口，等 Nacos 服务端恢复后再关闭容灾。</li>
</ol>
<p>在 Nacos 客户端中，容灾的处理逻辑集中在 <strong>FailoverReactor</strong> 类，Nacos 客户端的所有查询调用会先经过 FailoverReactor ，如果容灾开关打开，将直接使用容灾数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.core.HostReactor#getServiceInfo</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServiceInfo <span class="title">getServiceInfo</span><span class="params">(<span class="keyword">final</span> String serviceName, <span class="keyword">final</span> String clusters)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是不开启容灾，是的话则使用容灾数据</span></span><br><span class="line">    String key = ServiceInfo.getKey(serviceName, clusters);</span><br><span class="line">    <span class="keyword">if</span> (failoverReactor.isFailoverSwitch()) &#123;</span><br><span class="line">        <span class="keyword">return</span> failoverReactor.getService(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>FailoverReactor 在初始化时，会开启 2 个定时任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开关检测，在打开开关的情况下，将从磁盘加载服务数据到内存，每 5 秒执行</span></span><br><span class="line">    executorService.scheduleWithFixedDelay(<span class="keyword">new</span> SwitchRefresher(), <span class="number">0L</span>, <span class="number">5000L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 备份服务数据到磁盘, 初始化延迟 30 分钟, 每 24 小时执行一次</span></span><br><span class="line">    executorService.scheduleWithFixedDelay(<span class="keyword">new</span> DiskFileWriter(), <span class="number">30</span>, DAY_PERIOD_MINUTES, TimeUnit.MINUTES);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// backup file on startup if failover directory is empty.</span></span><br><span class="line">    <span class="comment">// 启动后备份一次服务数据，延迟 10 秒</span></span><br><span class="line">    executorService.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                File cacheDir = <span class="keyword">new</span> File(failoverDir);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!cacheDir.exists() &amp;&amp; !cacheDir.mkdirs()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;failed to create cache dir: &quot;</span> + failoverDir);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                File[] files = cacheDir.listFiles();</span><br><span class="line">                <span class="keyword">if</span> (files == <span class="keyword">null</span> || files.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">new</span> DiskFileWriter().run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                NAMING_LOGGER.error(<span class="string">&quot;[NA] failed to backup file on startup.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">10000L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>容灾开关检测任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.backups.FailoverReactor.SwitchRefresher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwitchRefresher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> lastModifiedMillis = <span class="number">0L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开关文件是否存在，文件名为 “00-00---000-VIPSRV_FAILOVER_SWITCH-000---00-00”</span></span><br><span class="line">            File switchFile = <span class="keyword">new</span> File(failoverDir + UtilAndComs.FAILOVER_SWITCH);</span><br><span class="line">            <span class="keyword">if</span> (!switchFile.exists()) &#123;</span><br><span class="line">                switchParams.put(<span class="string">&quot;failover-mode&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">                NAMING_LOGGER.debug(<span class="string">&quot;failover switch is not found, &quot;</span> + switchFile.getName());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查开关文件是否变更</span></span><br><span class="line">            <span class="keyword">long</span> modified = switchFile.lastModified();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (lastModifiedMillis &lt; modified) &#123;</span><br><span class="line">                lastModifiedMillis = modified;</span><br><span class="line">                String failover = ConcurrentDiskUtil.getFileContent(failoverDir + UtilAndComs.FAILOVER_SWITCH,</span><br><span class="line">                        Charset.defaultCharset().toString());</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.isEmpty(failover)) &#123;</span><br><span class="line">                    String[] lines = failover.split(DiskCache.getLineSeparator());</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span> (String line : lines) &#123;</span><br><span class="line">                        String line1 = line.trim();</span><br><span class="line">                        <span class="comment">// 开关文件内容为 “1”时，则为打开，此时加载磁盘服务数据到内存</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(line1)) &#123;</span><br><span class="line">                            switchParams.put(<span class="string">&quot;failover-mode&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">                            NAMING_LOGGER.info(<span class="string">&quot;failover-mode is on&quot;</span>);</span><br><span class="line">                            <span class="keyword">new</span> FailoverFileReader().run();</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;0&quot;</span>.equals(line1)) &#123;</span><br><span class="line">                            switchParams.put(<span class="string">&quot;failover-mode&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">                            NAMING_LOGGER.info(<span class="string">&quot;failover-mode is off&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    switchParams.put(<span class="string">&quot;failover-mode&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            NAMING_LOGGER.error(<span class="string">&quot;[NA] failed to read failover switch.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该任务主要用于检测容灾开关是否打开，检测的方法是检查容灾目录下是否存在文件名为“00-00—000-VIPSRV_FAILOVER_SWITCH-000—00-00” 的开关文件，存在且文件内容为“1”时，则认为是打开状态，同时加载容灾目录下的服务数据到内存。</p>
<h4 id="客户端重试"><a href="#客户端重试" class="headerlink" title="客户端重试"></a>客户端重试</h4><p>当 Nacos 客户端与服务端通信失败时，会进行多次重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reqApi</span><span class="params">(String api, Map&lt;String, String&gt; params, Map&lt;String, String&gt; body, List&lt;String&gt; servers,</span></span></span><br><span class="line"><span class="function"><span class="params">        String method)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    params.put(CommonParams.NAMESPACE_ID, getNamespaceId());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(servers) &amp;&amp; StringUtils.isBlank(nacosDomain)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.INVALID_PARAM, <span class="string">&quot;no server available&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NacosException exception = <span class="keyword">new</span> NacosException();</span><br><span class="line">    <span class="comment">// 当只配置了一个 Nacos 服务端地址时，进行一定次数的重试</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(nacosDomain)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxRetry; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> callServer(api, params, body, nacosDomain, method);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                exception = e;</span><br><span class="line">                <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                    NAMING_LOGGER.debug(<span class="string">&quot;request &#123;&#125; failed.&quot;</span>, nacosDomain, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当有多个 Nacos 服务端地址时，对不同地址进行重试</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">int</span> index = random.nextInt(servers.size());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; servers.size(); i++) &#123;</span><br><span class="line">            String server = servers.get(index);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> callServer(api, params, body, server, method);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                exception = e;</span><br><span class="line">                <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                    NAMING_LOGGER.debug(<span class="string">&quot;request &#123;&#125; failed.&quot;</span>, server, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index = (index + <span class="number">1</span>) % servers.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重试分为两种情况：</p>
<ol>
<li>当只配置了一个 Nacos 服务端地址时，进行一定次数的重试；</li>
<li>当有多个 Nacos 服务端地址时，对不同地址进行重试。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文针对 Nacos 客户端如何保障高可用进行了简单的总结学习。总的来说，Nacos 客户端通过多种机制（如本地缓存、failover 容灾、重试等）来保障高可用性。这些机制共同作用，确保了在 Nacos 服务端出现故障或网络异常时，客户端仍能正常运行并提供服务。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Nacos/" rel="tag"># Nacos</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/01/18/%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0HikariCP%EF%BC%9A%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" rel="prev" title="高性能数据库连接池HikariCP：源码学习">
      <i class="fa fa-chevron-left"></i> 高性能数据库连接池HikariCP：源码学习
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/06/29/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9AController%20%E6%B3%A8%E5%85%A5%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8/" rel="next" title="问题记录：Controller 注入空指针异常">
      问题记录：Controller 注入空指针异常 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="nav-number">2.</span> <span class="nav-text">本地缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0"><span class="nav-number">2.2.</span> <span class="nav-text">更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.3.</span> <span class="nav-text">持久化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#failover-%E5%AE%B9%E7%81%BE"><span class="nav-number">3.</span> <span class="nav-text">failover 容灾</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E8%AF%95"><span class="nav-number">3.1.</span> <span class="nav-text">客户端重试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="laixiaoming"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">laixiaoming</p>
  <div class="site-description" itemprop="description">就算红尘劫数都是空幻，也必须经历一遍才能领悟</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">laixiaoming</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

  
  
    <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
